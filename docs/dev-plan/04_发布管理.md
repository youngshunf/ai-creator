# 04 发布管理开发计划

> 需求来源: `docs/14-MVP需求规格.md` 2.3 多平台发布
> 参考文档: `docs/05-Agent-Runtime.md`, `docs/01-系统架构.md`

## 一、需求概述

实现跨平台的高效分发。

| 需求ID | 功能 | 优先级 |
|--------|------|--------|
| F-MVP-020 | 发布配置 | P0 |
| F-MVP-021 | 一键发布 | P0 |
| F-MVP-022 | 发布队列 | P1 |
| F-MVP-023 | 发布结果 | P0 |

---

## 二、Agent 工作流设计

### 2.1 复用 browser-use-agent Graph

发布功能复用已定义的 `browser-use-agent.yaml`，通过传入不同的 `goal` 来执行发布任务。

**已有定义**: `agent-definitions/browser-use-agent.yaml`

```yaml
apiVersion: agent/v1
kind: Graph
metadata:
  name: browser-use-agent
  version: "1.0.0"
  description: "自主浏览器代理，执行复杂的网页操作任务。"
spec:
  skills:
    - browser-user  # 提供 browser_use 工具集
  inputs:
    goal:
      type: string
      required: true
      description: "用户的浏览器操作目标"
  # ... planner -> executor 循环
```

### 2.2 发布工作流 Graph

发布流程组合 `browser-use-agent` 实现多平台发布。

**文件**: `agent-definitions/publish-workflow.yaml`

```yaml
apiVersion: agent/v1
kind: Graph
metadata:
  name: publish-workflow
  description: 多平台发布工作流
spec:
  inputs:
    content_id: { type: string, required: true }
    target_accounts: { type: array, required: true }
  
  state:
    adapted_contents: { type: object, default: {} }
    publish_results: { type: array, default: [] }
  
  nodes:
    - name: adapt_content
      tool: llm_generate
      params:
        system: "你是内容适配专家，将内容适配到不同平台格式"
        prompt: "将以下内容适配到 ${input.platform} 平台格式..."
    
    - name: execute_publish
      # 调用 browser-use-agent 子图
      graph: browser-use-agent
      params:
        goal: |
          请在 ${account.platform} 平台发布以下内容:
          标题: ${adapted.title}
          正文: ${adapted.text}
          图片: ${adapted.images}
          话题: ${adapted.tags}
          
          完成后返回发布的作品链接。
  
  edges:
    - from: START
      to: adapt_content
    - from: adapt_content
      to: execute_publish
    - from: execute_publish
      to: END
  
  outputs:
    results: "${state.publish_results}"
```

### 2.2 内容适配

不同平台有不同的内容格式要求：

| 平台 | 标题限制 | 正文限制 | 图片要求 |
|------|---------|---------|---------|
| 小红书 | 20字 | 1000字 | 9张以内 |
| 抖音 | 30字 | 500字 | 视频封面 |
| 公众号 | 64字 | 无限制 | 支持多图 |

**文件**: `packages/agent-core/src/agent_core/platforms/adapters/`

```python
class XiaohongshuContentAdapter:
    """小红书内容适配器"""
    
    def adapt(self, content: Content) -> dict:
        return {
            "title": content.title[:20],
            "text": self._add_emojis(content.text[:1000]),
            "images": content.images[:9],
            "tags": content.tags[:10],
        }
    
    def _add_emojis(self, text: str) -> str:
        """添加小红书风格 emoji"""
        pass
```

---

## 三、云端 API 开发

### 3.1 数据模型

**文件**: `services/cloud-backend/backend/app/models/publication.py`

```python
class Publication(Base):
    __tablename__ = "publications"
    
    id: Mapped[UUID] = mapped_column(primary_key=True)
    user_id: Mapped[UUID] = mapped_column(ForeignKey("users.id"))
    content_id: Mapped[UUID] = mapped_column(ForeignKey("contents.id"))
    account_id: Mapped[UUID] = mapped_column(ForeignKey("platform_accounts.id"))
    
    platform: Mapped[str]
    status: Mapped[str] = mapped_column(default="pending")
    # pending, publishing, published, failed, cancelled
    
    adapted_content: Mapped[dict] = mapped_column(JSONB)
    scheduled_at: Mapped[datetime | None]
    published_at: Mapped[datetime | None]
    
    # 发布结果
    platform_post_id: Mapped[str | None]
    platform_post_url: Mapped[str | None]
    
    error_message: Mapped[str | None]
    retry_count: Mapped[int] = mapped_column(default=0)
    
    # 同步元数据
    server_version: Mapped[int] = mapped_column(default=0)
    
    created_at: Mapped[datetime]
    updated_at: Mapped[datetime]
```

### 3.2 API 端点

**文件**: `services/cloud-backend/backend/app/api/v1/publications.py`

| Method | Path | 描述 |
|--------|------|------|
| POST | `/api/v1/publications` | 创建发布任务 |
| GET | `/api/v1/publications` | 获取发布列表 |
| GET | `/api/v1/publications/{id}` | 获取发布详情 |
| POST | `/api/v1/publications/{id}/retry` | 重试发布 |
| POST | `/api/v1/publications/{id}/cancel` | 取消发布 |
| GET | `/api/v1/publications/queue` | 获取发布队列 |

---

## 四、桌面端开发 (browser_use AI 自动化)

### 4.1 核心理念

使用 `browser_use` 库，通过 **AI Agent 驱动虚拟浏览器**，无需编写页面选择器或规则。AI 根据自然语言指令自主完成操作。

**优势**:
- ✅ 无需维护 CSS 选择器
- ✅ 平台 UI 变化自动适应
- ✅ 复杂交互由 AI 自主处理
- ✅ 减少代码维护成本

### 4.2 browser_use 集成

**文件**: `apps/sidecar/src/sidecar/tools/browser_use_publish.py`

```python
from browser_use import Agent, Controller
from browser_use.browser.browser import Browser, BrowserConfig
from agent_core.tools.base import ToolInterface, ToolResult
from agent_core.tools.registry import ToolRegistry
from agent_core.runtime.interfaces import RuntimeType

@ToolRegistry.register("browser_publish", RuntimeType.LOCAL)
class BrowserUsePublishTool(ToolInterface):
    """
    使用 browser_use AI Agent 发布内容
    
    AI 自主操作浏览器，无需编写选择器规则
    """
    
    async def execute(
        self,
        ctx: RuntimeContext,
        *,
        platform: str,
        account_id: str,
        content: dict,
    ) -> ToolResult:
        """AI 驱动的浏览器发布"""
        from ..storage.credential import credential_store
        from ..llm.client import get_llm_client
        
        # 1. 加载凭证 (Cookies)
        credential = await credential_store.load(account_id, platform)
        if not credential:
            return ToolResult(success=False, error="凭证不存在")
        
        # 2. 配置浏览器
        browser = Browser(
            config=BrowserConfig(
                headless=False,  # 可视化调试
                disable_security=True,
            )
        )
        
        # 3. 构建发布指令
        task = self._build_publish_task(platform, content)
        
        # 4. 创建 AI Agent
        agent = Agent(
            task=task,
            llm=get_llm_client(),
            browser=browser,
            controller=Controller(),
        )
        
        # 5. 注入登录凭证
        await self._inject_cookies(browser, credential, platform)
        
        try:
            # 6. AI 自主执行发布
            result = await agent.run()
            
            # 7. 解析发布结果
            return self._parse_result(result)
            
        except Exception as e:
            return ToolResult(success=False, error=str(e))
        finally:
            await browser.close()
    
    def _build_publish_task(self, platform: str, content: dict) -> str:
        """构建 AI 发布任务指令"""
        
        platform_urls = {
            "xiaohongshu": "https://creator.xiaohongshu.com/publish/publish",
            "douyin": "https://creator.douyin.com/creator-micro/content/upload",
            "wechat_mp": "https://mp.weixin.qq.com/",
        }
        
        return f"""
你是一个自媒体发布助手。请完成以下发布任务：

1. 打开 {platform_urls.get(platform)} 创作者后台
2. 点击发布/创作按钮
3. 在标题栏输入: {content['title']}
4. 在正文区域输入: {content['text']}
5. 如果有图片，依次上传这些图片: {content.get('images', [])}
6. 添加话题标签: {content.get('tags', [])}
7. 点击发布按钮
8. 等待发布成功提示
9. 返回发布后的作品链接

注意事项:
- 如果遇到任何弹窗，尝试关闭
- 如果需要选择分类，选择与内容最相关的
- 如果发布失败，记录失败原因
"""
    
    async def _inject_cookies(self, browser: Browser, credential: dict, platform: str):
        """注入登录 Cookies"""
        context = await browser.get_context()
        await context.add_cookies(credential.get("cookies", []))
    
    def _parse_result(self, agent_result) -> ToolResult:
        """解析 AI Agent 执行结果"""
        # 从 agent 历史中提取发布结果
        final_message = agent_result.final_result()
        
        if "成功" in final_message or "published" in final_message.lower():
            # 尝试提取作品链接
            import re
            url_match = re.search(r'https?://[^\s]+', final_message)
            post_url = url_match.group(0) if url_match else None
            
            return ToolResult(
                success=True,
                data={
                    "status": "published",
                    "post_url": post_url,
                    "message": final_message,
                }
            )
        else:
            return ToolResult(
                success=False,
                error=final_message,
            )
```

### 4.3 发布工作流 (Sidecar)

**文件**: `apps/sidecar/src/sidecar/workflows/publish.py`

```python
from agent_core.workflows.base import BaseWorkflow

class PublishWorkflow(BaseWorkflow):
    """发布工作流"""
    
    async def run(
        self,
        content_id: str,
        target_accounts: list[str],
    ):
        """执行发布流程"""
        
        # 1. 获取内容
        content = await self.get_content(content_id)
        
        # 2. 逐个账号发布
        results = []
        for account_id in target_accounts:
            account = await self.get_account(account_id)
            
            # 适配内容
            adapted = await self.adapt_content(content, account.platform)
            
            # AI 发布
            result = await self.tool_registry.get("browser_publish").execute(
                ctx=self.ctx,
                platform=account.platform,
                account_id=account_id,
                content=adapted,
            )
            
            results.append({
                "account_id": account_id,
                "platform": account.platform,
                "success": result.success,
                "data": result.data,
                "error": result.error,
            })
            
            # 发送进度事件
            await self.emit_event("publish_progress", {
                "completed": len(results),
                "total": len(target_accounts),
                "current_result": results[-1],
            })
        
        return {
            "success_count": sum(1 for r in results if r["success"]),
            "failed_count": sum(1 for r in results if not r["success"]),
            "results": results,
        }
```

### 4.4 前端 UI

#### 4.4.1 发布页面

**文件**: `apps/desktop/src/routes/publish/index.tsx` (已存在)

增强功能:
- 账号多选
- 发布进度显示 (AI 操作实时状态)
- 结果反馈

#### 4.4.2 发布预览

**文件**: `apps/desktop/src/components/publish/PlatformPreview.tsx` (新增)

- 显示各平台适配后的内容预览
- 支持微调

#### 4.4.3 发布队列

**文件**: `apps/desktop/src/components/publish/PublishQueue.tsx` (新增)

- 显示正在发布的任务
- 显示 AI 操作步骤进度
- 支持取消

### 4.5 Hooks

**文件**: `apps/desktop/src/hooks/usePublish.ts` (新增)

```typescript
export function usePublish() {
  const [queue, setQueue] = useState<Publication[]>([]);
  const [aiSteps, setAiSteps] = useState<string[]>([]);
  
  const startPublish = async (contentId: string, accountIds: string[]) => {
    // 启动发布工作流
    const stream = await invoke('start_publish_workflow', {
      content_id: contentId,
      account_ids: accountIds,
    });
    
    // 监听 AI 操作步骤
    for await (const event of stream) {
      if (event.type === 'ai_step') {
        setAiSteps(s => [...s, event.step]);
      } else if (event.type === 'publish_progress') {
        // 更新进度
      }
    }
  };
  
  return { queue, aiSteps, startPublish };
}
```

---

## 五、验证计划

### 5.1 手动测试

1. **发布配置**:
   - 进入发布页面
   - 选择要发布的内容
   - 勾选多个平台账号
   - 验证各平台预览正确

2. **AI 发布**:
   - 点击"一键发布"
   - 观察 AI 自主操作浏览器
   - 验证各平台依次发布

3. **发布结果**:
   - 发布成功显示链接
   - 发布失败显示 AI 反馈的原因
   - 支持重试

---

## 六、交付物清单

- [ ] `agent-definitions/publish-workflow.yaml`
- [ ] `services/cloud-backend/backend/app/models/publication.py`
- [ ] `services/cloud-backend/backend/app/api/v1/publications.py`
- [ ] `packages/agent-core/src/agent_core/platforms/adapters/`
- [ ] `apps/sidecar/src/sidecar/tools/browser_use_publish.py`
- [ ] `apps/sidecar/src/sidecar/workflows/publish.py`
- [ ] `apps/desktop/src/components/publish/PlatformPreview.tsx`
- [ ] `apps/desktop/src/components/publish/PublishQueue.tsx`
- [ ] `apps/desktop/src/hooks/usePublish.ts`
