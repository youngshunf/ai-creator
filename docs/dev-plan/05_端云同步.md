# 05 端云同步开发计划

> 需求来源: 离线创作 + 多设备同步需求
> 参考文档: `docs/16-数据库设计与同步策略.md`

## 一、需求概述

实现桌面端离线数据存储和云端数据同步，支持离线创作和多设备协作。

**核心目标**:
- 云端优先: PostgreSQL 为权威数据源
- 离线优先: 桌面端支持完全离线创作
- 自动同步: 联网后自动后台同步

---

## 二、云端 API 开发

### 2.1 同步 API

**文件**: `services/cloud-backend/backend/app/api/v1/sync.py`

| Method | Path | 描述 |
|--------|------|------|
| GET | `/api/v1/sync/changes` | 获取服务器变更 |
| POST | `/api/v1/sync/push` | 推送本地变更 |
| POST | `/api/v1/sync/resolve-conflict` | 解决冲突 |
| GET | `/api/v1/sync/status` | 获取同步状态 |

### 2.2 变更检测服务

**文件**: `services/cloud-backend/backend/app/services/sync_service.py`

```python
class SyncService:
    """同步服务"""
    
    async def get_changes(
        self,
        user_id: str,
        table: str,
        since_version: int,
        limit: int = 100,
    ) -> SyncChangesResponse:
        """获取指定版本后的变更"""
        changes = await self.db.query(
            f"""
            SELECT * FROM {table}
            WHERE user_id = :user_id
              AND server_version > :since_version
              AND is_deleted = false
            ORDER BY server_version
            LIMIT :limit
            """,
            {"user_id": user_id, "since_version": since_version, "limit": limit}
        )
        
        latest_version = changes[-1].server_version if changes else since_version
        
        return SyncChangesResponse(
            changes=changes,
            latest_version=latest_version,
            has_more=len(changes) == limit,
        )
    
    async def push_change(
        self,
        user_id: str,
        table: str,
        operation: str,
        data: dict,
        local_version: int,
    ) -> SyncPushResponse:
        """接收客户端变更"""
        record_id = data.get("id")
        
        # 检查服务器版本
        server_record = await self.db.get(table, record_id)
        
        if server_record and server_record.server_version > local_version:
            # 冲突
            return SyncPushResponse(
                conflict=True,
                server_data=server_record.to_dict(),
            )
        
        # 应用变更
        new_version = await self._apply_change(table, operation, data)
        
        return SyncPushResponse(
            conflict=False,
            server_version=new_version,
        )
```

---

## 三、桌面端开发

### 3.1 SQLite 数据库

**文件**: `apps/desktop/src-tauri/src/db/`

```text
db/
├── mod.rs
├── schema.sql      # 表结构定义
├── migrations/     # 迁移脚本
└── repository.rs   # 数据访问层
```

#### 3.1.1 同步元数据表

已在 `docs/16-数据库设计与同步策略.md` 中定义:

- `sync_metadata`: 同步状态跟踪
- `sync_conflicts`: 冲突记录
- `sync_queue`: 待同步变更队列

### 3.2 同步客户端

**文件**: `apps/sidecar/src/sidecar/sync/`

```text
sync/
├── __init__.py
├── client.py       # 同步客户端
├── conflict.py     # 冲突解决
├── queue.py        # 同步队列
└── scheduler.py    # 同步调度器
```

#### 3.2.1 同步客户端

**文件**: `apps/sidecar/src/sidecar/sync/client.py`

```python
class SyncClient:
    """同步客户端"""
    
    def __init__(self, api_base: str, api_key: str, db: Database):
        self.api_base = api_base
        self.api_key = api_key
        self.db = db
    
    async def sync_table(self, table_name: str):
        """同步单表"""
        # 1. 获取本地同步元数据
        local_meta = await self.db.get_sync_metadata(table_name)
        
        # 2. 拉取服务器变更 (Pull)
        server_changes = await self._pull_changes(
            table_name,
            local_meta.last_server_version,
        )
        
        # 3. 应用服务器变更
        for change in server_changes:
            await self._apply_server_change(table_name, change)
        
        # 4. 推送本地变更 (Push)
        local_changes = await self.db.get_pending_changes(table_name)
        for change in local_changes:
            await self._push_change(table_name, change)
        
        # 5. 更新同步元数据
        await self.db.update_sync_metadata(
            table_name,
            last_sync_at=datetime.now(),
            last_server_version=server_changes.latest_version,
        )
    
    async def full_sync(self):
        """完整同步所有表"""
        tables = ["projects", "platform_accounts", "contents", "publications"]
        for table in tables:
            await self.sync_table(table)
```

#### 3.2.2 同步调度器

**文件**: `apps/sidecar/src/sidecar/sync/scheduler.py`

```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler

class SyncScheduler:
    """同步调度器"""
    
    def __init__(self, sync_client: SyncClient):
        self.sync_client = sync_client
        self.scheduler = AsyncIOScheduler()
        self._is_online = True
    
    def start(self):
        """启动调度器"""
        # 定时同步 (每 5 分钟)
        self.scheduler.add_job(
            self._periodic_sync,
            'interval',
            minutes=5,
            id='periodic_sync',
        )
        self.scheduler.start()
    
    async def _periodic_sync(self):
        """定时同步"""
        if self._is_online:
            await self.sync_client.full_sync()
    
    def set_online(self, is_online: bool):
        """设置网络状态"""
        was_offline = not self._is_online
        self._is_online = is_online
        
        # 从离线转为在线，立即同步
        if was_offline and is_online:
            asyncio.create_task(self.sync_client.full_sync())
```

### 3.3 前端 UI

#### 3.3.1 同步状态指示器

**文件**: `apps/desktop/src/components/layout/SyncIndicator.tsx` (新增)

```tsx
export function SyncIndicator() {
  const { syncStatus, lastSyncAt, pendingChanges } = useSyncStore();
  
  return (
    <div className="flex items-center gap-2">
      {syncStatus === 'syncing' && <Loader2 className="animate-spin" />}
      {syncStatus === 'synced' && <Check className="text-green-500" />}
      {syncStatus === 'offline' && <CloudOff className="text-gray-400" />}
      {syncStatus === 'conflict' && <AlertTriangle className="text-yellow-500" />}
      
      <span className="text-xs text-gray-500">
        {formatLastSynced(lastSyncAt)}
      </span>
      
      {pendingChanges > 0 && (
        <span className="text-xs text-orange-500">
          {pendingChanges} 待同步
        </span>
      )}
    </div>
  );
}
```

#### 3.3.2 冲突解决弹窗

**文件**: `apps/desktop/src/components/sync/ConflictDialog.tsx` (新增)

- 显示本地 vs 服务器版本对比
- 支持选择"保留本地"/"使用服务器"
- 内容类冲突支持合并编辑器

### 3.4 状态管理

**文件**: `apps/desktop/src/stores/useSyncStore.ts` (新增)

```typescript
interface SyncStore {
  syncStatus: 'synced' | 'syncing' | 'offline' | 'conflict';
  lastSyncAt: Date | null;
  pendingChanges: number;
  conflicts: Conflict[];
  
  // Actions
  startSync: () => Promise<void>;
  setOnline: (isOnline: boolean) => void;
  resolveConflict: (id: string, choice: 'local' | 'server') => Promise<void>;
}
```

---

## 四、验证计划

### 4.1 单元测试

```bash
cd apps/sidecar
uv run pytest tests/test_sync.py -v
```

### 4.2 手动测试

1. **离线创作**:
   - 断开网络
   - 创建新内容
   - 验证内容保存到本地

2. **联网同步**:
   - 恢复网络
   - 验证自动触发同步
   - 验证内容上传到云端

3. **冲突解决**:
   - 设备 A 修改内容
   - 设备 B 离线修改同一内容
   - 设备 B 联网
   - 验证冲突弹窗出现
   - 选择解决方案

---

## 五、交付物清单

- [ ] `services/cloud-backend/backend/app/api/v1/sync.py`
- [ ] `services/cloud-backend/backend/app/services/sync_service.py`
- [ ] `apps/desktop/src-tauri/src/db/schema.sql`
- [ ] `apps/sidecar/src/sidecar/sync/client.py`
- [ ] `apps/sidecar/src/sidecar/sync/scheduler.py`
- [ ] `apps/desktop/src/components/layout/SyncIndicator.tsx`
- [ ] `apps/desktop/src/components/sync/ConflictDialog.tsx`
- [ ] `apps/desktop/src/stores/useSyncStore.ts`
