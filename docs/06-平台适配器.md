# AI Creator - 平台适配器

> Playwright浏览器自动化平台适配层

## 1. 设计理念

### 1.1 核心目标

**为每个自媒体平台提供统一的自动化接口**

- **接口统一**: 所有平台提供相同的操作接口
- **平台隔离**: 平台特性封装在适配器内部
- **可扩展性**: 易于添加新平台支持
- **稳定性**: 完善的错误处理和重试机制

### 1.2 发布策略优先级

```yaml
优先级顺序:
  1. 官方API: 最稳定、最推荐
  2. 浏览器自动化: Playwright模拟用户操作
  3. 逆向工程: 仅作为备选方案

各平台情况:
  微信公众号: 官方API (草稿箱接口)
  小红书: 浏览器自动化 (无官方API)
  抖音: 浏览器自动化 (创作者API限制大)
  微博: 官方API + 浏览器自动化混合
  B站: 浏览器自动化
  知乎: 浏览器自动化
  快手: 浏览器自动化
```

### 1.3 架构概览

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                            平台适配器层                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                        统一平台接口 (PlatformAdapter)                   │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │  │
│  │  │ 登录认证 │ │ 内容发布 │ │ 数据采集 │ │ 会话管理 │ │ 错误处理 │   │  │
│  │  │  login() │ │ publish()│ │analytics()│ │ session()│ │ handle() │   │  │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                      │                                      │
│                                      ▼                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         平台适配器实现                                  │  │
│  │                                                                       │  │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐         │  │
│  │  │ 小红书     │ │ 抖音       │ │ 微信公众号  │ │ 微博       │         │  │
│  │  │ Xiaohongshu│ │ Douyin     │ │ WeChat MP  │ │ Weibo      │         │  │
│  │  └────────────┘ └────────────┘ └────────────┘ └────────────┘         │  │
│  │                                                                       │  │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐         │  │
│  │  │ B站        │ │ 知乎       │ │ 快手       │ │ 更多...    │         │  │
│  │  │ Bilibili   │ │ Zhihu      │ │ Kuaishou   │ │ Extensible │         │  │
│  │  └────────────┘ └────────────┘ └────────────┘ └────────────┘         │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 统一接口定义

### 2.1 基础适配器接口

```python
# agent-core/src/platforms/base.py
from abc import ABC, abstractmethod
from typing import Optional
from dataclasses import dataclass
from enum import Enum
from datetime import datetime

class ContentType(Enum):
    """内容类型"""
    TEXT = "text"           # 纯文本
    IMAGE = "image"         # 图文
    VIDEO = "video"         # 视频
    ARTICLE = "article"     # 长文章

@dataclass
class PublishContent:
    """发布内容"""
    content_type: ContentType
    title: Optional[str] = None
    text: Optional[str] = None
    images: Optional[list[str]] = None      # 图片路径列表
    video: Optional[str] = None              # 视频路径
    cover: Optional[str] = None              # 封面图片
    tags: Optional[list[str]] = None         # 标签/话题
    location: Optional[str] = None           # 位置
    schedule_time: Optional[datetime] = None # 定时发布时间
    extra: Optional[dict] = None             # 平台特定参数

@dataclass
class PublishResult:
    """发布结果"""
    success: bool
    post_id: Optional[str] = None
    post_url: Optional[str] = None
    error: Optional[str] = None
    platform_response: Optional[dict] = None

@dataclass
class AnalyticsData:
    """数据分析"""
    post_id: str
    views: int = 0              # 浏览量
    likes: int = 0              # 点赞数
    comments: int = 0           # 评论数
    shares: int = 0             # 分享数
    favorites: int = 0          # 收藏数
    followers_gained: int = 0   # 涨粉数
    fetched_at: datetime = None
    raw_data: Optional[dict] = None

class PlatformAdapter(ABC):
    """平台适配器基类"""

    platform_name: str          # 平台名称
    platform_id: str            # 平台标识
    supported_types: list[ContentType]  # 支持的内容类型

    @abstractmethod
    async def check_session(self, page) -> bool:
        """检查登录会话是否有效"""
        pass

    @abstractmethod
    async def login(self, page, credentials: dict) -> bool:
        """执行登录（通常是恢复Cookie）"""
        pass

    @abstractmethod
    async def publish(self, page, content: PublishContent) -> PublishResult:
        """发布内容"""
        pass

    @abstractmethod
    async def fetch_analytics(self, page, post_id: str) -> AnalyticsData:
        """获取数据分析"""
        pass

    @abstractmethod
    async def get_profile(self, page) -> dict:
        """获取账号信息"""
        pass

    async def wait_for_ready(self, page, timeout: int = 30000):
        """等待页面就绪"""
        await page.wait_for_load_state('networkidle', timeout=timeout)

    async def handle_popup(self, page):
        """处理弹窗（广告、通知等）"""
        # 子类可重写
        pass

    async def take_screenshot(self, page, name: str) -> str:
        """截图用于调试"""
        path = f"/tmp/screenshot_{self.platform_id}_{name}.png"
        await page.screenshot(path=path)
        return path
```

### 2.2 适配器注册表

```python
# agent-core/src/platforms/__init__.py
from typing import Dict, Type
from .base import PlatformAdapter

_adapters: Dict[str, Type[PlatformAdapter]] = {}

def register_adapter(platform_id: str):
    """装饰器：注册平台适配器"""
    def decorator(cls: Type[PlatformAdapter]):
        _adapters[platform_id] = cls
        return cls
    return decorator

def get_adapter(platform_id: str) -> PlatformAdapter:
    """获取平台适配器实例"""
    if platform_id not in _adapters:
        raise ValueError(f"Unknown platform: {platform_id}")
    return _adapters[platform_id]()

def list_platforms() -> list[str]:
    """列出所有支持的平台"""
    return list(_adapters.keys())
```

---

## 3. 小红书适配器

### 3.1 完整实现

```python
# agent-core/src/platforms/xiaohongshu.py
from playwright.async_api import Page
from .base import (
    PlatformAdapter, ContentType, PublishContent,
    PublishResult, AnalyticsData
)
from . import register_adapter
from datetime import datetime
import asyncio

@register_adapter("xiaohongshu")
class XiaohongshuAdapter(PlatformAdapter):
    """小红书平台适配器"""

    platform_name = "小红书"
    platform_id = "xiaohongshu"
    supported_types = [ContentType.IMAGE, ContentType.VIDEO]

    # URL常量
    CREATOR_URL = "https://creator.xiaohongshu.com"
    LOGIN_CHECK_URL = "https://creator.xiaohongshu.com/publish/publish"
    PUBLISH_URL = "https://creator.xiaohongshu.com/publish/publish"

    async def check_session(self, page: Page) -> bool:
        """检查登录状态"""
        try:
            await page.goto(self.LOGIN_CHECK_URL, wait_until='networkidle')

            # 检查是否跳转到登录页
            current_url = page.url
            if 'login' in current_url:
                return False

            # 检查是否有发布按钮
            publish_btn = await page.query_selector('button:has-text("发布")')
            return publish_btn is not None

        except Exception:
            return False

    async def login(self, page: Page, credentials: dict) -> bool:
        """
        恢复登录态
        credentials应包含: cookies, localStorage, sessionStorage
        """
        try:
            # 恢复Cookies
            if credentials.get('cookies'):
                await page.context.add_cookies(credentials['cookies'])

            # 恢复localStorage
            if credentials.get('localStorage'):
                await page.goto(self.CREATOR_URL)
                for key, value in credentials['localStorage'].items():
                    await page.evaluate(
                        f"localStorage.setItem('{key}', '{value}')"
                    )

            # 验证登录状态
            return await self.check_session(page)

        except Exception as e:
            print(f"Login failed: {e}")
            return False

    async def publish(self, page: Page, content: PublishContent) -> PublishResult:
        """发布图文/视频笔记"""
        try:
            # 导航到发布页
            await page.goto(self.PUBLISH_URL, wait_until='networkidle')
            await self.handle_popup(page)

            if content.content_type == ContentType.VIDEO:
                return await self._publish_video(page, content)
            else:
                return await self._publish_image(page, content)

        except Exception as e:
            return PublishResult(
                success=False,
                error=str(e)
            )

    async def _publish_image(self, page: Page, content: PublishContent) -> PublishResult:
        """发布图文笔记"""

        # 1. 上传图片
        upload_input = await page.wait_for_selector('input[type="file"]')
        for image_path in content.images:
            await upload_input.set_input_files(image_path)
            await asyncio.sleep(1)  # 等待上传

        # 2. 等待上传完成
        await page.wait_for_selector('.upload-success', timeout=60000)

        # 3. 填写标题
        if content.title:
            title_input = await page.wait_for_selector('input[placeholder*="标题"]')
            await title_input.fill(content.title)

        # 4. 填写正文
        if content.text:
            text_area = await page.wait_for_selector('div[contenteditable="true"]')
            await text_area.fill(content.text)

        # 5. 添加话题标签
        if content.tags:
            for tag in content.tags[:5]:  # 小红书限制5个话题
                await page.click('text=添加话题')
                await page.fill('input[placeholder*="搜索话题"]', tag)
                await asyncio.sleep(0.5)
                # 选择第一个匹配的话题
                await page.click('.topic-item >> nth=0')

        # 6. 添加位置
        if content.location:
            await page.click('text=添加地点')
            await page.fill('input[placeholder*="搜索地点"]', content.location)
            await asyncio.sleep(0.5)
            await page.click('.location-item >> nth=0')

        # 7. 点击发布
        await page.click('button:has-text("发布")')

        # 8. 等待发布成功
        await page.wait_for_selector('text=发布成功', timeout=30000)

        # 9. 获取发布的笔记ID和URL
        # 通常发布成功后会跳转或显示笔记链接
        post_url = await self._get_latest_post_url(page)
        post_id = self._extract_post_id(post_url)

        return PublishResult(
            success=True,
            post_id=post_id,
            post_url=post_url
        )

    async def _publish_video(self, page: Page, content: PublishContent) -> PublishResult:
        """发布视频笔记"""

        # 1. 切换到视频发布Tab
        await page.click('text=发布视频')
        await asyncio.sleep(1)

        # 2. 上传视频
        upload_input = await page.wait_for_selector('input[type="file"][accept*="video"]')
        await upload_input.set_input_files(content.video)

        # 3. 等待视频上传完成（可能需要较长时间）
        await page.wait_for_selector('.upload-success', timeout=300000)  # 5分钟超时

        # 4. 上传封面（如果有）
        if content.cover:
            cover_input = await page.query_selector('input[type="file"][accept*="image"]')
            if cover_input:
                await cover_input.set_input_files(content.cover)

        # 5. 填写标题和描述
        if content.title:
            title_input = await page.wait_for_selector('input[placeholder*="标题"]')
            await title_input.fill(content.title)

        if content.text:
            text_area = await page.wait_for_selector('div[contenteditable="true"]')
            await text_area.fill(content.text)

        # 6. 添加话题和位置（同图文）
        # ...

        # 7. 发布
        await page.click('button:has-text("发布")')
        await page.wait_for_selector('text=发布成功', timeout=60000)

        post_url = await self._get_latest_post_url(page)
        post_id = self._extract_post_id(post_url)

        return PublishResult(
            success=True,
            post_id=post_id,
            post_url=post_url
        )

    async def fetch_analytics(self, page: Page, post_id: str) -> AnalyticsData:
        """获取笔记数据"""
        try:
            # 导航到笔记详情页
            analytics_url = f"{self.CREATOR_URL}/publish/note/{post_id}"
            await page.goto(analytics_url, wait_until='networkidle')

            # 提取数据
            views = await self._get_text_as_int(page, '.stat-views')
            likes = await self._get_text_as_int(page, '.stat-likes')
            comments = await self._get_text_as_int(page, '.stat-comments')
            favorites = await self._get_text_as_int(page, '.stat-favorites')
            shares = await self._get_text_as_int(page, '.stat-shares')

            return AnalyticsData(
                post_id=post_id,
                views=views,
                likes=likes,
                comments=comments,
                favorites=favorites,
                shares=shares,
                fetched_at=datetime.utcnow()
            )

        except Exception as e:
            return AnalyticsData(
                post_id=post_id,
                fetched_at=datetime.utcnow(),
                raw_data={"error": str(e)}
            )

    async def get_profile(self, page: Page) -> dict:
        """获取账号信息"""
        await page.goto(f"{self.CREATOR_URL}/user", wait_until='networkidle')

        return {
            "nickname": await self._get_text(page, '.nickname'),
            "followers": await self._get_text_as_int(page, '.followers-count'),
            "following": await self._get_text_as_int(page, '.following-count'),
            "notes_count": await self._get_text_as_int(page, '.notes-count'),
        }

    async def handle_popup(self, page: Page):
        """处理小红书常见弹窗"""
        try:
            # 关闭新手引导
            close_btn = await page.query_selector('.guide-close')
            if close_btn:
                await close_btn.click()

            # 关闭活动弹窗
            activity_close = await page.query_selector('.activity-modal .close')
            if activity_close:
                await activity_close.click()

        except Exception:
            pass

    async def _get_latest_post_url(self, page: Page) -> str:
        """获取最新发布的笔记URL"""
        await page.goto(f"{self.CREATOR_URL}/publish/note", wait_until='networkidle')
        first_note = await page.wait_for_selector('.note-item >> nth=0')
        return await first_note.get_attribute('href')

    def _extract_post_id(self, url: str) -> str:
        """从URL提取笔记ID"""
        # https://www.xiaohongshu.com/explore/xxxxx
        import re
        match = re.search(r'/explore/([a-zA-Z0-9]+)', url)
        return match.group(1) if match else ""

    async def _get_text(self, page: Page, selector: str) -> str:
        """获取元素文本"""
        element = await page.query_selector(selector)
        return await element.inner_text() if element else ""

    async def _get_text_as_int(self, page: Page, selector: str) -> int:
        """获取元素文本并转为整数"""
        text = await self._get_text(page, selector)
        # 处理 "1.2万" 这样的格式
        text = text.replace(',', '').strip()
        if '万' in text:
            return int(float(text.replace('万', '')) * 10000)
        if '亿' in text:
            return int(float(text.replace('亿', '')) * 100000000)
        try:
            return int(text)
        except ValueError:
            return 0
```

---

## 4. 抖音适配器

### 4.1 实现概要

```python
# agent-core/src/platforms/douyin.py
from playwright.async_api import Page
from .base import (
    PlatformAdapter, ContentType, PublishContent,
    PublishResult, AnalyticsData
)
from . import register_adapter
import asyncio

@register_adapter("douyin")
class DouyinAdapter(PlatformAdapter):
    """抖音平台适配器"""

    platform_name = "抖音"
    platform_id = "douyin"
    supported_types = [ContentType.VIDEO, ContentType.IMAGE]

    CREATOR_URL = "https://creator.douyin.com"
    PUBLISH_URL = "https://creator.douyin.com/creator-micro/content/upload"

    async def check_session(self, page: Page) -> bool:
        """检查登录状态"""
        try:
            await page.goto(self.CREATOR_URL, wait_until='networkidle')

            # 检查是否有用户头像（已登录标志）
            avatar = await page.query_selector('.user-avatar')
            return avatar is not None

        except Exception:
            return False

    async def login(self, page: Page, credentials: dict) -> bool:
        """恢复登录态"""
        try:
            if credentials.get('cookies'):
                await page.context.add_cookies(credentials['cookies'])
            return await self.check_session(page)
        except Exception:
            return False

    async def publish(self, page: Page, content: PublishContent) -> PublishResult:
        """发布视频/图集"""
        try:
            await page.goto(self.PUBLISH_URL, wait_until='networkidle')
            await self.handle_popup(page)

            if content.content_type == ContentType.VIDEO:
                return await self._publish_video(page, content)
            else:
                return await self._publish_image_set(page, content)

        except Exception as e:
            return PublishResult(success=False, error=str(e))

    async def _publish_video(self, page: Page, content: PublishContent) -> PublishResult:
        """发布视频"""

        # 1. 上传视频
        upload_input = await page.wait_for_selector('input[type="file"]')
        await upload_input.set_input_files(content.video)

        # 2. 等待上传和处理完成
        await page.wait_for_selector('.upload-success-icon', timeout=600000)  # 10分钟

        # 3. 填写描述
        if content.text:
            desc_input = await page.wait_for_selector('.editor-container')
            await desc_input.fill(content.text)

        # 4. 添加话题
        if content.tags:
            for tag in content.tags[:5]:
                await page.type('.editor-container', f'#{tag} ')

        # 5. 设置封面
        if content.cover:
            await page.click('text=选择封面')
            cover_input = await page.wait_for_selector('input[accept*="image"]')
            await cover_input.set_input_files(content.cover)
            await page.click('text=确定')

        # 6. 发布
        await page.click('button:has-text("发布")')
        await page.wait_for_selector('text=发布成功', timeout=60000)

        return PublishResult(success=True)

    async def _publish_image_set(self, page: Page, content: PublishContent) -> PublishResult:
        """发布图集"""

        # 1. 切换到图文模式
        await page.click('text=发布图文')
        await asyncio.sleep(1)

        # 2. 上传图片
        upload_input = await page.wait_for_selector('input[type="file"]')
        for image in content.images:
            await upload_input.set_input_files(image)
            await asyncio.sleep(1)

        # 3. 填写描述和标签
        if content.text:
            desc_input = await page.wait_for_selector('.editor-container')
            await desc_input.fill(content.text)

        # 4. 发布
        await page.click('button:has-text("发布")')
        await page.wait_for_selector('text=发布成功', timeout=60000)

        return PublishResult(success=True)

    async def fetch_analytics(self, page: Page, post_id: str) -> AnalyticsData:
        """获取视频数据"""
        analytics_url = f"{self.CREATOR_URL}/creator-micro/data/video/{post_id}"
        await page.goto(analytics_url, wait_until='networkidle')

        return AnalyticsData(
            post_id=post_id,
            views=await self._get_stat(page, '播放'),
            likes=await self._get_stat(page, '点赞'),
            comments=await self._get_stat(page, '评论'),
            shares=await self._get_stat(page, '分享'),
            favorites=await self._get_stat(page, '收藏'),
        )

    async def get_profile(self, page: Page) -> dict:
        """获取账号信息"""
        await page.goto(f"{self.CREATOR_URL}/creator-micro/home", wait_until='networkidle')

        return {
            "nickname": await self._get_text(page, '.nickname'),
            "followers": await self._get_stat(page, '粉丝'),
            "videos_count": await self._get_stat(page, '作品'),
        }

    async def handle_popup(self, page: Page):
        """处理弹窗"""
        try:
            # 关闭各种引导弹窗
            close_btns = await page.query_selector_all('.modal-close, .guide-close')
            for btn in close_btns:
                await btn.click()
        except Exception:
            pass

    async def _get_stat(self, page: Page, label: str) -> int:
        """获取统计数据"""
        element = await page.query_selector(f'text="{label}" >> .. >> .stat-value')
        if element:
            text = await element.inner_text()
            return self._parse_number(text)
        return 0

    async def _get_text(self, page: Page, selector: str) -> str:
        element = await page.query_selector(selector)
        return await element.inner_text() if element else ""

    def _parse_number(self, text: str) -> int:
        """解析数字（支持万、亿）"""
        text = text.strip().replace(',', '')
        if '万' in text:
            return int(float(text.replace('万', '')) * 10000)
        if '亿' in text:
            return int(float(text.replace('亿', '')) * 100000000)
        try:
            return int(text)
        except ValueError:
            return 0
```

---

## 5. 微信公众号适配器

### 5.1 官方API集成

```python
# agent-core/src/platforms/wechat_mp.py
from .base import (
    PlatformAdapter, ContentType, PublishContent,
    PublishResult, AnalyticsData
)
from . import register_adapter
import httpx
from datetime import datetime

@register_adapter("wechat_mp")
class WeChatMPAdapter(PlatformAdapter):
    """微信公众号适配器 - 优先使用官方API"""

    platform_name = "微信公众号"
    platform_id = "wechat_mp"
    supported_types = [ContentType.ARTICLE]

    # 微信公众号API
    BASE_URL = "https://api.weixin.qq.com/cgi-bin"

    def __init__(self):
        self.access_token = None
        self.token_expires_at = None

    async def _get_access_token(self, appid: str, secret: str) -> str:
        """获取或刷新access_token"""
        if self.access_token and self.token_expires_at > datetime.utcnow():
            return self.access_token

        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{self.BASE_URL}/token",
                params={
                    "grant_type": "client_credential",
                    "appid": appid,
                    "secret": secret
                }
            )
            data = response.json()

            if "access_token" in data:
                self.access_token = data["access_token"]
                # 提前5分钟刷新
                expires_in = data.get("expires_in", 7200) - 300
                self.token_expires_at = datetime.utcnow() + timedelta(seconds=expires_in)
                return self.access_token

            raise Exception(f"获取access_token失败: {data}")

    async def check_session(self, page) -> bool:
        """检查API凭证是否有效"""
        return self.access_token is not None

    async def login(self, page, credentials: dict) -> bool:
        """初始化API凭证"""
        try:
            await self._get_access_token(
                credentials['appid'],
                credentials['secret']
            )
            return True
        except Exception:
            return False

    async def publish(self, page, content: PublishContent) -> PublishResult:
        """
        发布文章（通过草稿箱API）

        流程:
        1. 上传素材（图片）
        2. 新建草稿
        3. 提交发布
        """
        try:
            # 1. 上传封面图
            thumb_media_id = None
            if content.cover:
                thumb_media_id = await self._upload_material(
                    content.cover, "image"
                )

            # 2. 处理正文中的图片
            processed_content = await self._process_content_images(content.text)

            # 3. 创建草稿
            article = {
                "title": content.title,
                "author": content.extra.get("author", ""),
                "digest": content.extra.get("digest", ""),
                "content": processed_content,
                "thumb_media_id": thumb_media_id,
                "need_open_comment": 1,
                "only_fans_can_comment": 0,
            }

            async with httpx.AsyncClient() as client:
                # 添加草稿
                response = await client.post(
                    f"{self.BASE_URL}/draft/add",
                    params={"access_token": self.access_token},
                    json={"articles": [article]}
                )
                draft_data = response.json()

                if draft_data.get("errcode", 0) != 0:
                    return PublishResult(
                        success=False,
                        error=draft_data.get("errmsg")
                    )

                media_id = draft_data["media_id"]

                # 发布草稿
                publish_response = await client.post(
                    f"{self.BASE_URL}/freepublish/submit",
                    params={"access_token": self.access_token},
                    json={"media_id": media_id}
                )
                publish_data = publish_response.json()

                if publish_data.get("errcode", 0) != 0:
                    return PublishResult(
                        success=False,
                        error=publish_data.get("errmsg")
                    )

                return PublishResult(
                    success=True,
                    post_id=publish_data.get("publish_id"),
                    platform_response=publish_data
                )

        except Exception as e:
            return PublishResult(success=False, error=str(e))

    async def _upload_material(self, file_path: str, media_type: str) -> str:
        """上传素材"""
        async with httpx.AsyncClient() as client:
            with open(file_path, 'rb') as f:
                files = {'media': (file_path.split('/')[-1], f)}
                response = await client.post(
                    f"{self.BASE_URL}/material/add_material",
                    params={
                        "access_token": self.access_token,
                        "type": media_type
                    },
                    files=files
                )
                data = response.json()
                return data.get("media_id")

    async def _process_content_images(self, content: str) -> str:
        """处理正文中的图片，上传到微信服务器"""
        import re

        # 查找所有本地图片路径
        img_pattern = r'<img[^>]+src=["\']([^"\']+)["\']'
        matches = re.findall(img_pattern, content)

        for local_path in matches:
            if local_path.startswith('/') or local_path.startswith('./'):
                # 上传图片
                media_url = await self._upload_content_image(local_path)
                content = content.replace(local_path, media_url)

        return content

    async def _upload_content_image(self, file_path: str) -> str:
        """上传正文图片（永久素材）"""
        async with httpx.AsyncClient() as client:
            with open(file_path, 'rb') as f:
                files = {'media': (file_path.split('/')[-1], f)}
                response = await client.post(
                    f"{self.BASE_URL}/media/uploadimg",
                    params={"access_token": self.access_token},
                    files=files
                )
                data = response.json()
                return data.get("url")

    async def fetch_analytics(self, page, post_id: str) -> AnalyticsData:
        """获取文章数据"""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.BASE_URL}/datacube/getarticlesummary",
                params={"access_token": self.access_token},
                json={
                    "begin_date": "2024-01-01",
                    "end_date": datetime.utcnow().strftime("%Y-%m-%d")
                }
            )
            data = response.json()

            # 解析数据
            return AnalyticsData(
                post_id=post_id,
                views=data.get("int_page_read_count", 0),
                shares=data.get("share_count", 0),
                favorites=data.get("add_to_fav_count", 0),
            )

    async def get_profile(self, page) -> dict:
        """获取公众号信息"""
        # 通过API获取
        return {}
```

---

## 6. 错误处理与重试

### 6.1 重试装饰器

```python
# agent-core/src/platforms/utils.py
import asyncio
from functools import wraps
from typing import Callable, Any

def retry_on_error(
    max_retries: int = 3,
    delay: float = 1.0,
    backoff: float = 2.0,
    exceptions: tuple = (Exception,)
):
    """
    重试装饰器

    Args:
        max_retries: 最大重试次数
        delay: 初始延迟（秒）
        backoff: 退避倍数
        exceptions: 需要重试的异常类型
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            current_delay = delay
            last_exception = None

            for attempt in range(max_retries + 1):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    if attempt < max_retries:
                        print(f"Attempt {attempt + 1} failed: {e}. Retrying in {current_delay}s...")
                        await asyncio.sleep(current_delay)
                        current_delay *= backoff
                    else:
                        raise

            raise last_exception

        return wrapper
    return decorator

# 使用示例
class SomeAdapter(PlatformAdapter):

    @retry_on_error(max_retries=3, delay=2.0)
    async def publish(self, page, content):
        # 发布逻辑
        pass
```

### 6.2 常见错误处理

```python
# agent-core/src/platforms/exceptions.py

class PlatformError(Exception):
    """平台错误基类"""
    pass

class SessionExpiredError(PlatformError):
    """会话过期"""
    pass

class RateLimitError(PlatformError):
    """频率限制"""
    def __init__(self, retry_after: int = 60):
        self.retry_after = retry_after
        super().__init__(f"Rate limited. Retry after {retry_after}s")

class ContentBlockedError(PlatformError):
    """内容被屏蔽"""
    pass

class UploadFailedError(PlatformError):
    """上传失败"""
    pass

class PublishFailedError(PlatformError):
    """发布失败"""
    pass
```

---

## 7. 测试与验证

### 7.1 适配器测试框架

```python
# tests/platforms/test_base.py
import pytest
from agent_core.platforms.base import PlatformAdapter, PublishContent, ContentType

class AdapterTestBase:
    """适配器测试基类"""

    adapter: PlatformAdapter = None

    @pytest.fixture
    async def browser_context(self):
        """创建测试用浏览器上下文"""
        from playwright.async_api import async_playwright

        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context()
            page = await context.new_page()
            yield page
            await browser.close()

    @pytest.mark.asyncio
    async def test_check_session_logged_out(self, browser_context):
        """测试未登录状态检测"""
        result = await self.adapter.check_session(browser_context)
        assert result is False

    @pytest.mark.asyncio
    async def test_login_with_valid_credentials(self, browser_context, credentials):
        """测试有效凭证登录"""
        result = await self.adapter.login(browser_context, credentials)
        assert result is True

    @pytest.mark.asyncio
    async def test_publish_image_content(self, browser_context, credentials):
        """测试图文发布"""
        await self.adapter.login(browser_context, credentials)

        content = PublishContent(
            content_type=ContentType.IMAGE,
            title="测试标题",
            text="测试内容",
            images=["test_image.jpg"],
            tags=["测试"]
        )

        result = await self.adapter.publish(browser_context, content)
        assert result.success is True
```

---

## 8. 浏览器会话管理模块

### 8.1 模块架构总览

```text
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                              浏览器发布模块 (松耦合架构)                                    │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │                           Agent工具层 (Tool Interface)                           │   │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐    │   │
│  │  │ BindAccountTool│  │ PublishTool   │  │ FetchDataTool │  │ SessionTool   │    │   │
│  │  │ 绑定账号       │  │ 发布内容      │  │ 采集数据      │  │ 会话管理      │    │   │
│  │  └───────────────┘  └───────────────┘  └───────────────┘  └───────────────┘    │   │
│  └──────────────────────────────────────┬──────────────────────────────────────────┘   │
│                                         │                                               │
│                                         ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │                           发布编排层 (Publishing Orchestrator)                    │   │
│  │  ┌───────────────────────────────────────────────────────────────────────────┐  │   │
│  │  │                         PublishingOrchestrator                             │  │   │
│  │  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │  │   │
│  │  │  │ 会话恢复     │  │ 内容适配     │  │ 发布执行     │  │ 结果记录     │   │  │   │
│  │  │  │ SessionRestore│  │ ContentAdapt │  │ PublishExec  │  │ ResultRecord │   │  │   │
│  │  │  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘   │  │   │
│  │  └───────────────────────────────────────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────┬──────────────────────────────────────────┘   │
│                                         │                                               │
│         ┌───────────────────────────────┼───────────────────────────────┐              │
│         │                               │                               │              │
│         ▼                               ▼                               ▼              │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐            │
│  │ BrowserSessionManager│  │   CredentialStore   │  │  PublishResultStore │            │
│  │  ┌───────────────┐  │  │  ┌───────────────┐  │  │  ┌───────────────┐  │            │
│  │  │ Playwright    │  │  │  │ Cookies       │  │  │  │ 发布记录      │  │            │
│  │  │ 上下文管理    │  │  │  │ Tokens        │  │  │  │ URL存储       │  │            │
│  │  │ 页面生命周期  │  │  │  │ LocalStorage  │  │  │  │ 状态追踪      │  │            │
│  │  └───────────────┘  │  │  └───────────────┘  │  │  └───────────────┘  │            │
│  │  ┌───────────────┐  │  │  ┌───────────────┐  │  │  ┌───────────────┐  │            │
│  │  │ DeviceFingerprint│  │  │ AES-256加密   │  │  │  │ 数据分析存储  │  │            │
│  │  │ 设备指纹管理  │  │  │  │ 本地/云端同步 │  │  │  │ 历史版本      │  │            │
│  │  └───────────────┘  │  │  └───────────────┘  │  │  └───────────────┘  │            │
│  └─────────────────────┘  └─────────────────────┘  └─────────────────────┘            │
│                                         │                                               │
│                                         ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │                              平台适配器层 (Platform Adapters)                     │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐     │   │
│  │  │ 小红书     │ │ 抖音       │ │ 微信公众号  │ │ 微博       │ │ 更多平台   │     │   │
│  │  └────────────┘ └────────────┘ └────────────┘ └────────────┘ └────────────┘     │   │
│  └─────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

### 8.2 核心组件设计

#### 8.2.1 BrowserSessionManager

```python
# agent-core/src/browser/session_manager.py
from playwright.async_api import async_playwright, Browser, BrowserContext, Page
from typing import Optional, Dict
from dataclasses import dataclass
from datetime import datetime
import asyncio

@dataclass
class BrowserSession:
    """浏览器会话"""
    session_id: str
    platform_id: str
    account_id: str
    context: BrowserContext
    page: Page
    created_at: datetime
    last_active: datetime
    fingerprint: "DeviceFingerprint"

class BrowserSessionManager:
    """
    浏览器会话管理器

    职责:
    - 管理Playwright浏览器实例和上下文
    - 维护会话生命周期
    - 支持会话复用和清理
    - 集成设备指纹
    """

    def __init__(
        self,
        credential_store: "CredentialStore",
        fingerprint_store: "FingerprintStore",
        max_sessions: int = 10,
        session_timeout: int = 3600,  # 1小时
    ):
        self.credential_store = credential_store
        self.fingerprint_store = fingerprint_store
        self.max_sessions = max_sessions
        self.session_timeout = session_timeout

        self._playwright = None
        self._browser: Optional[Browser] = None
        self._sessions: Dict[str, BrowserSession] = {}
        self._lock = asyncio.Lock()

    async def initialize(self):
        """初始化Playwright"""
        self._playwright = await async_playwright().start()
        self._browser = await self._playwright.chromium.launch(
            headless=True,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--no-sandbox',
                '--disable-dev-shm-usage',
                '--disable-web-security',
            ]
        )

    async def get_session(
        self,
        platform_id: str,
        account_id: str,
        user_id: str,
    ) -> BrowserSession:
        """
        获取或创建浏览器会话

        Args:
            platform_id: 平台标识
            account_id: 账号标识
            user_id: 用户ID

        Returns:
            BrowserSession: 可用的浏览器会话
        """
        session_key = f"{platform_id}:{account_id}"

        async with self._lock:
            # 检查现有会话
            if session_key in self._sessions:
                session = self._sessions[session_key]
                if self._is_session_valid(session):
                    session.last_active = datetime.utcnow()
                    return session
                else:
                    await self._close_session(session)

            # 清理过期会话
            await self._cleanup_expired_sessions()

            # 创建新会话
            return await self._create_session(platform_id, account_id, user_id)

    async def _create_session(
        self,
        platform_id: str,
        account_id: str,
        user_id: str,
    ) -> BrowserSession:
        """创建新的浏览器会话"""
        import uuid

        session_id = str(uuid.uuid4())

        # 获取或生成设备指纹
        fingerprint = await self.fingerprint_store.get_or_create(
            platform_id, account_id, user_id
        )

        # 创建浏览器上下文(应用指纹)
        context = await self._browser.new_context(
            viewport=fingerprint.viewport,
            user_agent=fingerprint.user_agent,
            locale=fingerprint.locale,
            timezone_id=fingerprint.timezone,
            device_scale_factor=fingerprint.device_scale_factor,
            color_scheme=fingerprint.color_scheme,
            extra_http_headers=fingerprint.extra_headers,
        )

        # 注入指纹脚本(WebGL, Canvas等)
        await self._inject_fingerprint_scripts(context, fingerprint)

        # 恢复凭证
        credentials = await self.credential_store.get(
            user_id, platform_id, account_id
        )
        if credentials:
            await self._restore_credentials(context, credentials)

        # 创建页面
        page = await context.new_page()

        session = BrowserSession(
            session_id=session_id,
            platform_id=platform_id,
            account_id=account_id,
            context=context,
            page=page,
            created_at=datetime.utcnow(),
            last_active=datetime.utcnow(),
            fingerprint=fingerprint,
        )

        session_key = f"{platform_id}:{account_id}"
        self._sessions[session_key] = session

        return session

    async def _restore_credentials(
        self,
        context: BrowserContext,
        credentials: "StoredCredentials",
    ):
        """恢复凭证到浏览器上下文"""
        # 恢复Cookies
        if credentials.cookies:
            await context.add_cookies(credentials.cookies)

        # localStorage和sessionStorage需要在页面加载后注入
        # 通过route拦截或init_script实现
        if credentials.local_storage or credentials.session_storage:
            await context.add_init_script(
                self._generate_storage_script(credentials)
            )

    def _generate_storage_script(self, credentials: "StoredCredentials") -> str:
        """生成存储恢复脚本"""
        import json
        script_parts = []

        if credentials.local_storage:
            for key, value in credentials.local_storage.items():
                escaped_value = json.dumps(value)
                script_parts.append(
                    f"localStorage.setItem('{key}', {escaped_value});"
                )

        if credentials.session_storage:
            for key, value in credentials.session_storage.items():
                escaped_value = json.dumps(value)
                script_parts.append(
                    f"sessionStorage.setItem('{key}', {escaped_value});"
                )

        return "\n".join(script_parts)

    async def _inject_fingerprint_scripts(
        self,
        context: BrowserContext,
        fingerprint: "DeviceFingerprint",
    ):
        """注入指纹伪装脚本"""
        script = f"""
        // WebGL指纹伪装
        const getParameterProxyHandler = {{
            apply: function(target, thisArg, args) {{
                const param = args[0];
                const gl = thisArg;
                if (param === 37445) {{ // UNMASKED_VENDOR_WEBGL
                    return '{fingerprint.webgl_vendor}';
                }}
                if (param === 37446) {{ // UNMASKED_RENDERER_WEBGL
                    return '{fingerprint.webgl_renderer}';
                }}
                return Reflect.apply(target, thisArg, args);
            }}
        }};

        // Canvas指纹噪声
        const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
        HTMLCanvasElement.prototype.toDataURL = function(type) {{
            if (type === 'image/png') {{
                const context = this.getContext('2d');
                const imageData = context.getImageData(0, 0, this.width, this.height);
                for (let i = 0; i < imageData.data.length; i += 4) {{
                    imageData.data[i] ^= {fingerprint.canvas_noise};
                }}
                context.putImageData(imageData, 0, 0);
            }}
            return originalToDataURL.apply(this, arguments);
        }};

        // Navigator属性
        Object.defineProperty(navigator, 'hardwareConcurrency', {{
            get: () => {fingerprint.hardware_concurrency}
        }});
        Object.defineProperty(navigator, 'deviceMemory', {{
            get: () => {fingerprint.device_memory}
        }});
        Object.defineProperty(navigator, 'platform', {{
            get: () => '{fingerprint.platform}'
        }});

        // 屏蔽webdriver属性
        Object.defineProperty(navigator, 'webdriver', {{
            get: () => undefined
        }});
        """

        await context.add_init_script(script)

    def _is_session_valid(self, session: BrowserSession) -> bool:
        """检查会话是否有效"""
        if session.context.browser is None:
            return False

        elapsed = (datetime.utcnow() - session.last_active).total_seconds()
        return elapsed < self.session_timeout

    async def _close_session(self, session: BrowserSession):
        """关闭会话"""
        try:
            await session.page.close()
            await session.context.close()
        except Exception:
            pass

    async def _cleanup_expired_sessions(self):
        """清理过期会话"""
        expired_keys = []
        for key, session in self._sessions.items():
            if not self._is_session_valid(session):
                expired_keys.append(key)

        for key in expired_keys:
            session = self._sessions.pop(key)
            await self._close_session(session)

    async def save_session_credentials(
        self,
        session: BrowserSession,
        user_id: str,
    ):
        """保存当前会话凭证"""
        # 提取Cookies
        cookies = await session.context.cookies()

        # 提取localStorage和sessionStorage
        local_storage = await session.page.evaluate(
            "() => Object.assign({}, localStorage)"
        )
        session_storage = await session.page.evaluate(
            "() => Object.assign({}, sessionStorage)"
        )

        credentials = StoredCredentials(
            platform_id=session.platform_id,
            account_id=session.account_id,
            cookies=cookies,
            local_storage=local_storage,
            session_storage=session_storage,
            updated_at=datetime.utcnow(),
        )

        await self.credential_store.save(user_id, credentials)

    async def close(self):
        """关闭所有会话和浏览器"""
        for session in self._sessions.values():
            await self._close_session(session)

        self._sessions.clear()

        if self._browser:
            await self._browser.close()

        if self._playwright:
            await self._playwright.stop()
```

#### 8.2.2 CredentialStore

```python
# agent-core/src/browser/credential_store.py
from dataclasses import dataclass, field
from typing import Optional, Dict, List, Any
from datetime import datetime
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import json
import aiosqlite

@dataclass
class StoredCredentials:
    """存储的凭证"""
    platform_id: str
    account_id: str
    cookies: List[Dict[str, Any]] = field(default_factory=list)
    local_storage: Dict[str, str] = field(default_factory=dict)
    session_storage: Dict[str, str] = field(default_factory=dict)
    tokens: Dict[str, str] = field(default_factory=dict)  # access_token, refresh_token等
    updated_at: datetime = None

class CredentialStore:
    """
    凭证存储

    职责:
    - 加密存储用户凭证
    - 支持本地存储和云端同步
    - 提供凭证的CRUD操作
    """

    def __init__(
        self,
        db_path: str,
        encryption_key: bytes,
        sync_service: Optional["CredentialSyncService"] = None,
    ):
        self.db_path = db_path
        self.sync_service = sync_service

        # 初始化加密器
        self._fernet = Fernet(encryption_key)

    @classmethod
    def derive_key(cls, password: str, salt: bytes) -> bytes:
        """从密码派生加密密钥"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key

    async def initialize(self):
        """初始化数据库"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                CREATE TABLE IF NOT EXISTS credentials (
                    user_id TEXT NOT NULL,
                    platform_id TEXT NOT NULL,
                    account_id TEXT NOT NULL,
                    encrypted_data BLOB NOT NULL,
                    updated_at TEXT NOT NULL,
                    PRIMARY KEY (user_id, platform_id, account_id)
                )
            """)
            await db.commit()

    async def save(
        self,
        user_id: str,
        credentials: StoredCredentials,
    ):
        """保存凭证"""
        # 序列化并加密
        data = {
            "platform_id": credentials.platform_id,
            "account_id": credentials.account_id,
            "cookies": credentials.cookies,
            "local_storage": credentials.local_storage,
            "session_storage": credentials.session_storage,
            "tokens": credentials.tokens,
            "updated_at": credentials.updated_at.isoformat(),
        }
        encrypted = self._fernet.encrypt(json.dumps(data).encode())

        # 存储到本地数据库
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT OR REPLACE INTO credentials
                (user_id, platform_id, account_id, encrypted_data, updated_at)
                VALUES (?, ?, ?, ?, ?)
            """, (
                user_id,
                credentials.platform_id,
                credentials.account_id,
                encrypted,
                credentials.updated_at.isoformat(),
            ))
            await db.commit()

        # 可选: 同步到云端
        if self.sync_service:
            await self.sync_service.upload(user_id, credentials.platform_id,
                                           credentials.account_id, encrypted)

    async def get(
        self,
        user_id: str,
        platform_id: str,
        account_id: str,
    ) -> Optional[StoredCredentials]:
        """获取凭证"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute("""
                SELECT encrypted_data FROM credentials
                WHERE user_id = ? AND platform_id = ? AND account_id = ?
            """, (user_id, platform_id, account_id))
            row = await cursor.fetchone()

        if not row:
            # 尝试从云端同步
            if self.sync_service:
                encrypted = await self.sync_service.download(
                    user_id, platform_id, account_id
                )
                if encrypted:
                    return self._decrypt_credentials(encrypted)
            return None

        return self._decrypt_credentials(row[0])

    def _decrypt_credentials(self, encrypted: bytes) -> StoredCredentials:
        """解密凭证"""
        decrypted = self._fernet.decrypt(encrypted)
        data = json.loads(decrypted)

        return StoredCredentials(
            platform_id=data["platform_id"],
            account_id=data["account_id"],
            cookies=data["cookies"],
            local_storage=data["local_storage"],
            session_storage=data["session_storage"],
            tokens=data.get("tokens", {}),
            updated_at=datetime.fromisoformat(data["updated_at"]),
        )

    async def delete(
        self,
        user_id: str,
        platform_id: str,
        account_id: str,
    ):
        """删除凭证"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                DELETE FROM credentials
                WHERE user_id = ? AND platform_id = ? AND account_id = ?
            """, (user_id, platform_id, account_id))
            await db.commit()

        if self.sync_service:
            await self.sync_service.delete(user_id, platform_id, account_id)

    async def list_accounts(
        self,
        user_id: str,
        platform_id: Optional[str] = None,
    ) -> List[Dict[str, str]]:
        """列出用户的所有账号"""
        async with aiosqlite.connect(self.db_path) as db:
            if platform_id:
                cursor = await db.execute("""
                    SELECT platform_id, account_id, updated_at FROM credentials
                    WHERE user_id = ? AND platform_id = ?
                """, (user_id, platform_id))
            else:
                cursor = await db.execute("""
                    SELECT platform_id, account_id, updated_at FROM credentials
                    WHERE user_id = ?
                """, (user_id,))

            rows = await cursor.fetchall()

        return [
            {
                "platform_id": row[0],
                "account_id": row[1],
                "updated_at": row[2],
            }
            for row in rows
        ]
```

#### 8.2.3 DeviceFingerprint

```python
# agent-core/src/browser/fingerprint.py
from dataclasses import dataclass, field
from typing import Dict, Optional, List
import random
import hashlib
import json

@dataclass
class DeviceFingerprint:
    """设备指纹"""
    fingerprint_id: str

    # 视口和显示
    viewport: Dict[str, int] = field(default_factory=lambda: {"width": 1920, "height": 1080})
    device_scale_factor: float = 1.0
    color_scheme: str = "light"

    # User-Agent
    user_agent: str = ""
    platform: str = "Win32"

    # 地区和时区
    locale: str = "zh-CN"
    timezone: str = "Asia/Shanghai"

    # 硬件信息
    hardware_concurrency: int = 8
    device_memory: int = 8

    # WebGL指纹
    webgl_vendor: str = "Google Inc. (NVIDIA)"
    webgl_renderer: str = "ANGLE (NVIDIA, NVIDIA GeForce GTX 1080 Direct3D11 vs_5_0 ps_5_0)"

    # Canvas噪声种子
    canvas_noise: int = 1

    # 额外HTTP头
    extra_headers: Dict[str, str] = field(default_factory=dict)

class FingerprintGenerator:
    """指纹生成器"""

    # 常见User-Agent模板
    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
    ]

    # 常见分辨率
    VIEWPORTS = [
        {"width": 1920, "height": 1080},
        {"width": 1536, "height": 864},
        {"width": 1440, "height": 900},
        {"width": 1366, "height": 768},
        {"width": 2560, "height": 1440},
    ]

    # WebGL渲染器
    WEBGL_RENDERERS = [
        ("Google Inc. (NVIDIA)", "ANGLE (NVIDIA, NVIDIA GeForce GTX 1080 Direct3D11 vs_5_0 ps_5_0)"),
        ("Google Inc. (NVIDIA)", "ANGLE (NVIDIA, NVIDIA GeForce RTX 3060 Direct3D11 vs_5_0 ps_5_0)"),
        ("Google Inc. (AMD)", "ANGLE (AMD, AMD Radeon RX 580 Series Direct3D11 vs_5_0 ps_5_0)"),
        ("Google Inc. (Intel)", "ANGLE (Intel, Intel(R) UHD Graphics 630 Direct3D11 vs_5_0 ps_5_0)"),
    ]

    @classmethod
    def generate(cls, seed: Optional[str] = None) -> DeviceFingerprint:
        """
        生成设备指纹

        Args:
            seed: 可选的种子,用于生成确定性指纹
        """
        if seed:
            random.seed(hashlib.md5(seed.encode()).hexdigest())

        user_agent = random.choice(cls.USER_AGENTS)
        viewport = random.choice(cls.VIEWPORTS)
        webgl = random.choice(cls.WEBGL_RENDERERS)

        # 根据UA确定平台
        if "Macintosh" in user_agent:
            platform = "MacIntel"
        else:
            platform = "Win32"

        fingerprint_id = hashlib.sha256(
            f"{user_agent}{viewport}{webgl}".encode()
        ).hexdigest()[:16]

        return DeviceFingerprint(
            fingerprint_id=fingerprint_id,
            viewport=viewport,
            device_scale_factor=random.choice([1.0, 1.25, 1.5, 2.0]),
            user_agent=user_agent,
            platform=platform,
            hardware_concurrency=random.choice([4, 6, 8, 12, 16]),
            device_memory=random.choice([4, 8, 16, 32]),
            webgl_vendor=webgl[0],
            webgl_renderer=webgl[1],
            canvas_noise=random.randint(1, 10),
            extra_headers={
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
                "sec-ch-ua": '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"Windows"' if platform == "Win32" else '"macOS"',
            },
        )

class FingerprintStore:
    """指纹存储"""

    def __init__(self, db_path: str):
        self.db_path = db_path

    async def initialize(self):
        """初始化数据库"""
        import aiosqlite
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                CREATE TABLE IF NOT EXISTS fingerprints (
                    platform_id TEXT NOT NULL,
                    account_id TEXT NOT NULL,
                    user_id TEXT NOT NULL,
                    fingerprint_data TEXT NOT NULL,
                    created_at TEXT NOT NULL,
                    PRIMARY KEY (platform_id, account_id, user_id)
                )
            """)
            await db.commit()

    async def get_or_create(
        self,
        platform_id: str,
        account_id: str,
        user_id: str,
    ) -> DeviceFingerprint:
        """获取或创建指纹"""
        import aiosqlite

        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute("""
                SELECT fingerprint_data FROM fingerprints
                WHERE platform_id = ? AND account_id = ? AND user_id = ?
            """, (platform_id, account_id, user_id))
            row = await cursor.fetchone()

        if row:
            data = json.loads(row[0])
            return DeviceFingerprint(**data)

        # 生成新指纹(使用账号信息作为种子,保证同一账号指纹一致)
        seed = f"{platform_id}:{account_id}:{user_id}"
        fingerprint = FingerprintGenerator.generate(seed)

        # 存储
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT INTO fingerprints (platform_id, account_id, user_id, fingerprint_data, created_at)
                VALUES (?, ?, ?, ?, datetime('now'))
            """, (
                platform_id,
                account_id,
                user_id,
                json.dumps(fingerprint.__dict__),
            ))
            await db.commit()

        return fingerprint
```

---

## 9. Agent工具封装

### 9.1 发布工具 (PublishTool)

```python
# agent-core/src/tools/publish_tool.py
from typing import Optional, List
from pydantic import BaseModel, Field
from ..tools.base import BaseTool, ToolResult
from ..browser.session_manager import BrowserSessionManager
from ..platforms import get_adapter
from ..platforms.base import PublishContent, ContentType

class PublishParams(BaseModel):
    """发布参数"""
    platform_id: str = Field(..., description="平台标识: xiaohongshu, douyin, weibo等")
    account_id: str = Field(..., description="账号标识")
    content_type: str = Field(..., description="内容类型: image, video, article")
    title: Optional[str] = Field(None, description="标题")
    text: str = Field(..., description="正文内容")
    images: Optional[List[str]] = Field(None, description="图片路径列表")
    video: Optional[str] = Field(None, description="视频路径")
    cover: Optional[str] = Field(None, description="封面图路径")
    tags: Optional[List[str]] = Field(None, description="话题标签列表")
    location: Optional[str] = Field(None, description="位置")

class PublishTool(BaseTool):
    """
    发布工具 - 供Agent调用的发布接口

    职责:
    - 封装发布流程供LangGraph Agent调用
    - 自动管理会话和凭证
    - 记录发布结果
    """

    name = "publish_content"
    description = """
    发布内容到自媒体平台。
    支持的平台: xiaohongshu(小红书), douyin(抖音), weibo(微博), wechat_mp(微信公众号), bilibili(B站), zhihu(知乎)
    支持的内容类型: image(图文), video(视频), article(文章)
    """

    def __init__(
        self,
        session_manager: BrowserSessionManager,
        result_store: "PublishResultStore",
        user_id: str,
    ):
        self.session_manager = session_manager
        self.result_store = result_store
        self.user_id = user_id

    async def execute(self, **kwargs) -> ToolResult:
        """执行发布"""
        try:
            params = PublishParams(**kwargs)

            # 1. 获取浏览器会话
            session = await self.session_manager.get_session(
                platform_id=params.platform_id,
                account_id=params.account_id,
                user_id=self.user_id,
            )

            # 2. 获取平台适配器
            adapter = get_adapter(params.platform_id)

            # 3. 检查登录状态
            if not await adapter.check_session(session.page):
                return ToolResult(
                    success=False,
                    data=None,
                    error=f"账号 {params.account_id} 登录状态已失效，请重新绑定"
                )

            # 4. 构建发布内容
            content = PublishContent(
                content_type=ContentType(params.content_type),
                title=params.title,
                text=params.text,
                images=params.images,
                video=params.video,
                cover=params.cover,
                tags=params.tags,
                location=params.location,
            )

            # 5. 执行发布
            result = await adapter.publish(session.page, content)

            # 6. 记录结果
            if result.success:
                await self.result_store.save(
                    user_id=self.user_id,
                    platform_id=params.platform_id,
                    account_id=params.account_id,
                    post_id=result.post_id,
                    post_url=result.post_url,
                    content_snapshot={
                        "title": params.title,
                        "text": params.text[:200] if params.text else None,
                        "content_type": params.content_type,
                    },
                )

            return ToolResult(
                success=result.success,
                data={
                    "post_id": result.post_id,
                    "post_url": result.post_url,
                    "platform": params.platform_id,
                },
                error=result.error,
            )

        except Exception as e:
            return ToolResult(success=False, data=None, error=str(e))

    def get_input_schema(self) -> dict:
        return PublishParams.model_json_schema()
```

### 9.2 账号绑定工具 (BindAccountTool)

```python
# agent-core/src/tools/bind_account_tool.py
from pydantic import BaseModel, Field
from ..tools.base import BaseTool, ToolResult
from ..browser.session_manager import BrowserSessionManager
from ..platforms import get_adapter

class BindAccountParams(BaseModel):
    """绑定账号参数"""
    platform_id: str = Field(..., description="平台标识")
    account_id: str = Field(..., description="账号标识/昵称")

class BindAccountTool(BaseTool):
    """
    账号绑定工具

    职责:
    - 打开内置浏览器供用户登录
    - 登录成功后保存凭证
    - 支持扫码/账密等多种登录方式
    """

    name = "bind_account"
    description = """
    绑定自媒体平台账号。会打开内置浏览器让用户完成登录，登录成功后自动保存凭证。
    """

    def __init__(
        self,
        session_manager: BrowserSessionManager,
        user_id: str,
        on_login_required: callable = None,  # 回调函数,通知前端打开登录窗口
    ):
        self.session_manager = session_manager
        self.user_id = user_id
        self.on_login_required = on_login_required

    async def execute(self, **kwargs) -> ToolResult:
        """执行账号绑定"""
        try:
            params = BindAccountParams(**kwargs)

            # 1. 创建新会话(不恢复凭证)
            session = await self.session_manager._create_session(
                platform_id=params.platform_id,
                account_id=params.account_id,
                user_id=self.user_id,
            )

            # 2. 获取平台适配器
            adapter = get_adapter(params.platform_id)

            # 3. 导航到登录页
            login_url = self._get_login_url(params.platform_id)
            await session.page.goto(login_url)

            # 4. 通知前端显示浏览器窗口
            if self.on_login_required:
                await self.on_login_required(
                    session_id=session.session_id,
                    platform_id=params.platform_id,
                    message="请在浏览器中完成登录",
                )

            # 5. 等待用户登录完成(轮询检查登录状态)
            max_wait = 300  # 5分钟超时
            for _ in range(max_wait):
                if await adapter.check_session(session.page):
                    break
                await asyncio.sleep(1)
            else:
                return ToolResult(
                    success=False,
                    data=None,
                    error="登录超时,请重试"
                )

            # 6. 保存凭证
            await self.session_manager.save_session_credentials(
                session, self.user_id
            )

            # 7. 获取账号信息
            profile = await adapter.get_profile(session.page)

            return ToolResult(
                success=True,
                data={
                    "platform_id": params.platform_id,
                    "account_id": params.account_id,
                    "profile": profile,
                    "message": "账号绑定成功",
                },
            )

        except Exception as e:
            return ToolResult(success=False, data=None, error=str(e))

    def _get_login_url(self, platform_id: str) -> str:
        """获取平台登录URL"""
        urls = {
            "xiaohongshu": "https://creator.xiaohongshu.com/login",
            "douyin": "https://creator.douyin.com/",
            "weibo": "https://weibo.com/login.php",
            "bilibili": "https://member.bilibili.com/",
            "zhihu": "https://www.zhihu.com/signin",
        }
        return urls.get(platform_id, "")

    def get_input_schema(self) -> dict:
        return BindAccountParams.model_json_schema()
```

### 9.3 数据采集工具 (FetchAnalyticsTool)

```python
# agent-core/src/tools/fetch_analytics_tool.py
from typing import Optional, List
from pydantic import BaseModel, Field
from ..tools.base import BaseTool, ToolResult
from ..browser.session_manager import BrowserSessionManager
from ..platforms import get_adapter

class FetchAnalyticsParams(BaseModel):
    """采集参数"""
    platform_id: str = Field(..., description="平台标识")
    account_id: str = Field(..., description="账号标识")
    post_ids: Optional[List[str]] = Field(None, description="指定采集的帖子ID列表")
    fetch_all: bool = Field(False, description="是否采集所有帖子")

class FetchAnalyticsTool(BaseTool):
    """
    数据采集工具

    职责:
    - 采集帖子的互动数据
    - 支持批量采集
    - 存储历史数据
    """

    name = "fetch_analytics"
    description = """
    采集自媒体平台的数据分析。可以获取阅读量、点赞、评论、分享、收藏等数据。
    """

    def __init__(
        self,
        session_manager: BrowserSessionManager,
        analytics_store: "AnalyticsStore",
        user_id: str,
    ):
        self.session_manager = session_manager
        self.analytics_store = analytics_store
        self.user_id = user_id

    async def execute(self, **kwargs) -> ToolResult:
        """执行数据采集"""
        try:
            params = FetchAnalyticsParams(**kwargs)

            session = await self.session_manager.get_session(
                platform_id=params.platform_id,
                account_id=params.account_id,
                user_id=self.user_id,
            )

            adapter = get_adapter(params.platform_id)

            if not await adapter.check_session(session.page):
                return ToolResult(
                    success=False,
                    data=None,
                    error="登录状态已失效"
                )

            results = []
            post_ids = params.post_ids or []

            # 如果需要采集所有,先获取帖子列表
            if params.fetch_all:
                post_ids = await self._get_all_post_ids(adapter, session.page)

            for post_id in post_ids:
                analytics = await adapter.fetch_analytics(session.page, post_id)
                await self.analytics_store.save(
                    user_id=self.user_id,
                    platform_id=params.platform_id,
                    analytics=analytics,
                )
                results.append({
                    "post_id": analytics.post_id,
                    "views": analytics.views,
                    "likes": analytics.likes,
                    "comments": analytics.comments,
                    "shares": analytics.shares,
                    "favorites": analytics.favorites,
                })

            return ToolResult(
                success=True,
                data={"analytics": results, "count": len(results)},
            )

        except Exception as e:
            return ToolResult(success=False, data=None, error=str(e))

    async def _get_all_post_ids(self, adapter, page) -> List[str]:
        """获取所有帖子ID"""
        # 实现获取帖子列表的逻辑
        pass

    def get_input_schema(self) -> dict:
        return FetchAnalyticsParams.model_json_schema()
```

---

## 10. 发布结果存储

### 10.1 PublishResultStore

```python
# agent-core/src/browser/result_store.py
from dataclasses import dataclass
from typing import Optional, Dict, Any, List
from datetime import datetime
import aiosqlite
import json

@dataclass
class PublishRecord:
    """发布记录"""
    record_id: str
    user_id: str
    platform_id: str
    account_id: str
    post_id: str
    post_url: str
    content_snapshot: Dict[str, Any]
    published_at: datetime
    analytics_last_updated: Optional[datetime] = None
    latest_analytics: Optional[Dict[str, int]] = None

class PublishResultStore:
    """
    发布结果存储

    职责:
    - 记录所有发布结果
    - 存储帖子URL
    - 关联数据分析
    """

    def __init__(self, db_path: str):
        self.db_path = db_path

    async def initialize(self):
        """初始化数据库"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                CREATE TABLE IF NOT EXISTS publish_records (
                    record_id TEXT PRIMARY KEY,
                    user_id TEXT NOT NULL,
                    platform_id TEXT NOT NULL,
                    account_id TEXT NOT NULL,
                    post_id TEXT,
                    post_url TEXT,
                    content_snapshot TEXT,
                    published_at TEXT NOT NULL,
                    analytics_last_updated TEXT,
                    latest_analytics TEXT
                )
            """)

            await db.execute("""
                CREATE INDEX IF NOT EXISTS idx_publish_user
                ON publish_records(user_id)
            """)

            await db.execute("""
                CREATE INDEX IF NOT EXISTS idx_publish_platform
                ON publish_records(user_id, platform_id)
            """)

            await db.commit()

    async def save(
        self,
        user_id: str,
        platform_id: str,
        account_id: str,
        post_id: Optional[str],
        post_url: Optional[str],
        content_snapshot: Dict[str, Any],
    ) -> str:
        """保存发布记录"""
        import uuid

        record_id = str(uuid.uuid4())
        now = datetime.utcnow().isoformat()

        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT INTO publish_records
                (record_id, user_id, platform_id, account_id, post_id, post_url,
                 content_snapshot, published_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                record_id,
                user_id,
                platform_id,
                account_id,
                post_id,
                post_url,
                json.dumps(content_snapshot),
                now,
            ))
            await db.commit()

        return record_id

    async def update_analytics(
        self,
        record_id: str,
        analytics: Dict[str, int],
    ):
        """更新数据分析"""
        now = datetime.utcnow().isoformat()

        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                UPDATE publish_records
                SET analytics_last_updated = ?, latest_analytics = ?
                WHERE record_id = ?
            """, (now, json.dumps(analytics), record_id))
            await db.commit()

    async def get_records(
        self,
        user_id: str,
        platform_id: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> List[PublishRecord]:
        """获取发布记录"""
        async with aiosqlite.connect(self.db_path) as db:
            if platform_id:
                cursor = await db.execute("""
                    SELECT * FROM publish_records
                    WHERE user_id = ? AND platform_id = ?
                    ORDER BY published_at DESC
                    LIMIT ? OFFSET ?
                """, (user_id, platform_id, limit, offset))
            else:
                cursor = await db.execute("""
                    SELECT * FROM publish_records
                    WHERE user_id = ?
                    ORDER BY published_at DESC
                    LIMIT ? OFFSET ?
                """, (user_id, limit, offset))

            rows = await cursor.fetchall()

        return [self._row_to_record(row) for row in rows]

    def _row_to_record(self, row) -> PublishRecord:
        """转换数据库行到记录对象"""
        return PublishRecord(
            record_id=row[0],
            user_id=row[1],
            platform_id=row[2],
            account_id=row[3],
            post_id=row[4],
            post_url=row[5],
            content_snapshot=json.loads(row[6]) if row[6] else {},
            published_at=datetime.fromisoformat(row[7]),
            analytics_last_updated=datetime.fromisoformat(row[8]) if row[8] else None,
            latest_analytics=json.loads(row[9]) if row[9] else None,
        )
```

---

## 11. 发布编排器

### 11.1 PublishingOrchestrator

```python
# agent-core/src/browser/orchestrator.py
from typing import Optional, List
from dataclasses import dataclass
from enum import Enum
from datetime import datetime

class PublishStatus(Enum):
    """发布状态"""
    PENDING = "pending"
    SESSION_RESTORING = "session_restoring"
    CONTENT_ADAPTING = "content_adapting"
    PUBLISHING = "publishing"
    SUCCESS = "success"
    FAILED = "failed"

@dataclass
class PublishTask:
    """发布任务"""
    task_id: str
    user_id: str
    platform_id: str
    account_id: str
    content: "PublishContent"
    status: PublishStatus = PublishStatus.PENDING
    progress: float = 0.0
    error: Optional[str] = None
    result: Optional["PublishResult"] = None
    created_at: datetime = None
    completed_at: datetime = None

class PublishingOrchestrator:
    """
    发布编排器

    职责:
    - 编排完整的发布流程
    - 管理发布状态和进度
    - 支持批量发布
    - 提供发布事件通知
    """

    def __init__(
        self,
        session_manager: "BrowserSessionManager",
        credential_store: "CredentialStore",
        result_store: "PublishResultStore",
        event_emitter: Optional["EventEmitter"] = None,
    ):
        self.session_manager = session_manager
        self.credential_store = credential_store
        self.result_store = result_store
        self.event_emitter = event_emitter

        self._tasks: dict[str, PublishTask] = {}

    async def create_task(
        self,
        user_id: str,
        platform_id: str,
        account_id: str,
        content: "PublishContent",
    ) -> PublishTask:
        """创建发布任务"""
        import uuid

        task = PublishTask(
            task_id=str(uuid.uuid4()),
            user_id=user_id,
            platform_id=platform_id,
            account_id=account_id,
            content=content,
            created_at=datetime.utcnow(),
        )

        self._tasks[task.task_id] = task
        return task

    async def execute_task(self, task_id: str) -> PublishTask:
        """执行发布任务"""
        task = self._tasks.get(task_id)
        if not task:
            raise ValueError(f"Task not found: {task_id}")

        try:
            # 阶段1: 恢复会话
            await self._update_status(task, PublishStatus.SESSION_RESTORING, 0.1)
            session = await self.session_manager.get_session(
                platform_id=task.platform_id,
                account_id=task.account_id,
                user_id=task.user_id,
            )

            # 阶段2: 检查登录状态
            adapter = get_adapter(task.platform_id)
            if not await adapter.check_session(session.page):
                raise Exception("登录状态已失效,请重新绑定账号")

            await self._update_status(task, PublishStatus.SESSION_RESTORING, 0.3)

            # 阶段3: 内容适配
            await self._update_status(task, PublishStatus.CONTENT_ADAPTING, 0.4)
            adapted_content = await self._adapt_content(
                task.content, task.platform_id
            )

            await self._update_status(task, PublishStatus.CONTENT_ADAPTING, 0.5)

            # 阶段4: 执行发布
            await self._update_status(task, PublishStatus.PUBLISHING, 0.6)
            result = await adapter.publish(session.page, adapted_content)

            await self._update_status(task, PublishStatus.PUBLISHING, 0.9)

            # 阶段5: 记录结果
            if result.success:
                await self.result_store.save(
                    user_id=task.user_id,
                    platform_id=task.platform_id,
                    account_id=task.account_id,
                    post_id=result.post_id,
                    post_url=result.post_url,
                    content_snapshot={
                        "title": task.content.title,
                        "text": task.content.text[:200] if task.content.text else None,
                    },
                )

                task.result = result
                await self._update_status(task, PublishStatus.SUCCESS, 1.0)
            else:
                task.error = result.error
                await self._update_status(task, PublishStatus.FAILED, 1.0)

        except Exception as e:
            task.error = str(e)
            await self._update_status(task, PublishStatus.FAILED, 1.0)

        task.completed_at = datetime.utcnow()
        return task

    async def execute_batch(
        self,
        tasks: List[PublishTask],
        parallel: bool = False,
    ) -> List[PublishTask]:
        """批量执行发布任务"""
        if parallel:
            import asyncio
            results = await asyncio.gather(
                *[self.execute_task(t.task_id) for t in tasks],
                return_exceptions=True
            )
            return [r if isinstance(r, PublishTask) else tasks[i]
                    for i, r in enumerate(results)]
        else:
            results = []
            for task in tasks:
                result = await self.execute_task(task.task_id)
                results.append(result)
            return results

    async def _adapt_content(
        self,
        content: "PublishContent",
        platform_id: str,
    ) -> "PublishContent":
        """适配内容到目标平台"""
        # 根据平台调整内容
        # - 标题长度
        # - 正文长度
        # - 标签数量
        # - 图片尺寸
        return content

    async def _update_status(
        self,
        task: PublishTask,
        status: PublishStatus,
        progress: float,
    ):
        """更新任务状态"""
        task.status = status
        task.progress = progress

        if self.event_emitter:
            await self.event_emitter.emit("publish_progress", {
                "task_id": task.task_id,
                "status": status.value,
                "progress": progress,
            })

    def get_task(self, task_id: str) -> Optional[PublishTask]:
        """获取任务"""
        return self._tasks.get(task_id)
```

---

## 12. 与Agent工作流集成

### 12.1 LangGraph发布节点

```python
# agent-core/src/workflows/publish/nodes.py
from ..browser.orchestrator import PublishingOrchestrator
from ..platforms.base import PublishContent, ContentType

async def publish_node(state: dict) -> dict:
    """
    发布节点 - 在LangGraph工作流中执行发布

    输入状态:
    - user_id: 用户ID
    - platforms: 目标平台列表 [{platform_id, account_id}]
    - content: 待发布内容

    输出状态:
    - publish_results: 发布结果列表
    """
    orchestrator: PublishingOrchestrator = state["orchestrator"]
    user_id = state["user_id"]
    platforms = state["platforms"]
    content_data = state["content"]

    # 构建发布内容
    content = PublishContent(
        content_type=ContentType(content_data["type"]),
        title=content_data.get("title"),
        text=content_data.get("text"),
        images=content_data.get("images"),
        video=content_data.get("video"),
        tags=content_data.get("tags"),
    )

    # 创建发布任务
    tasks = []
    for platform in platforms:
        task = await orchestrator.create_task(
            user_id=user_id,
            platform_id=platform["platform_id"],
            account_id=platform["account_id"],
            content=content,
        )
        tasks.append(task)

    # 执行发布
    results = await orchestrator.execute_batch(tasks, parallel=True)

    return {
        **state,
        "publish_results": [
            {
                "platform_id": r.platform_id,
                "account_id": r.account_id,
                "success": r.status.value == "success",
                "post_url": r.result.post_url if r.result else None,
                "error": r.error,
            }
            for r in results
        ]
    }
```

### 12.2 完整发布工作流

```python
# agent-core/src/workflows/publish/graph.py
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Optional

class PublishWorkflowState(TypedDict):
    """发布工作流状态"""
    user_id: str
    content: dict                    # 待发布内容
    platforms: List[dict]            # 目标平台列表
    publish_results: List[dict]      # 发布结果
    error: Optional[str]

def create_publish_workflow(orchestrator: "PublishingOrchestrator"):
    """创建发布工作流"""

    workflow = StateGraph(PublishWorkflowState)

    # 添加节点
    workflow.add_node("validate_content", validate_content_node)
    workflow.add_node("check_accounts", check_accounts_node)
    workflow.add_node("publish", lambda s: publish_node({**s, "orchestrator": orchestrator}))
    workflow.add_node("record_results", record_results_node)

    # 设置入口
    workflow.set_entry_point("validate_content")

    # 添加边
    workflow.add_edge("validate_content", "check_accounts")
    workflow.add_conditional_edges(
        "check_accounts",
        lambda s: "publish" if not s.get("error") else END,
    )
    workflow.add_edge("publish", "record_results")
    workflow.add_edge("record_results", END)

    return workflow.compile()

async def validate_content_node(state: PublishWorkflowState) -> dict:
    """验证内容节点"""
    content = state["content"]

    # 验证必要字段
    if not content.get("text") and not content.get("images") and not content.get("video"):
        return {**state, "error": "内容不能为空"}

    return state

async def check_accounts_node(state: PublishWorkflowState) -> dict:
    """检查账号状态节点"""
    # 检查所有目标账号是否可用
    return state

async def record_results_node(state: PublishWorkflowState) -> dict:
    """记录结果节点"""
    # 记录发布结果到数据库
    return state
```

---

## 相关文档

- [Agent Runtime](./05-Agent-Runtime.md)
- [云端服务设计](./04-云端服务设计.md)
- [AI工作流](./07-AI工作流.md)
