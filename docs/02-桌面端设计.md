# åˆ›æµ (CreatorFlow) - æ¡Œé¢ç«¯è®¾è®¡

> Tauri 2.0 + Python Sidecar (å†…åµŒPython) æ¡Œé¢ç«¯ä¸“å±æ–¹æ¡ˆ | ç‰ˆæœ¬: v2.4 | æ›´æ–°: 2025-12-28
>
> **é‡è¦å˜æ›´**: Python Sidecar ç°ä½¿ç”¨ `agent-core` å…±äº«åŒ…ï¼Œä¸å†é‡å¤å®šä¹‰ Agent ç›¸å…³ä»£ç ã€‚è¯¦è§ [Agent Runtime](./05-Agent-Runtime.md)ã€‚

## 1. è®¾è®¡ç†å¿µ

### 1.1 æ¡Œé¢ç«¯å®šä½

```yaml
æ ¸å¿ƒå®šä½: å®Œæ•´åŠŸèƒ½ + æœ¬åœ°èƒ½åŠ› + éšç§ä¼˜å…ˆ + é›¶ä¾èµ–éƒ¨ç½²

ç‰¹ç‚¹:
  - Python Sidecar æ”¯æŒæœ¬åœ° Agent æ‰§è¡Œ
  - å†…åµŒ Python ç¯å¢ƒï¼Œä¸ä¾èµ–ç”¨æˆ·ç³»ç»Ÿ
  - Playwright æœ¬åœ°æµè§ˆå™¨è‡ªåŠ¨åŒ–
  - æœ¬åœ°å‡­è¯åŠ å¯†å­˜å‚¨
  - ç¦»çº¿èƒ½åŠ›å®Œæ•´
  - æ€§èƒ½æœ€ä¼˜ï¼Œéšç§æœ€å¼º

ç›®æ ‡ç”¨æˆ·:
  - ä¸“ä¸šåˆ›ä½œè€…ï¼ˆéœ€è¦å®Œæ•´åŠŸèƒ½ï¼‰
  - éšç§æ•æ„Ÿç”¨æˆ·ï¼ˆä¸æ„¿ä¸Šä¼ å‡­è¯ï¼‰
  - é‡åº¦ç”¨æˆ·ï¼ˆé«˜é¢‘å‘å¸ƒã€æ‰¹é‡æ“ä½œï¼‰
  - å›¢é˜Ÿ/æœºæ„ç”¨æˆ·ï¼ˆæœ¬åœ°åŒ–éƒ¨ç½²éœ€æ±‚ï¼‰
```

### 1.2 æ ¸å¿ƒä¼˜åŠ¿

| èƒ½åŠ› | æè¿° | ä»·å€¼ |
|------|------|------|
| **å†…åµŒ Python** | æ‰“åŒ…å®Œæ•´ Python ç¯å¢ƒ | é›¶ä¾èµ–å®‰è£…ï¼Œå¼€ç®±å³ç”¨ |
| **æœ¬åœ° Agent** | Python Sidecar è¿è¡Œ AI Agent | éšç§ä¿æŠ¤ã€å“åº”å¿«é€Ÿ |
| **æµè§ˆå™¨è‡ªåŠ¨åŒ–** | Playwright æœ¬åœ°æ‰§è¡Œ | å‡­è¯ä¸ç¦»å¼€æœ¬åœ° |
| **å®šæ—¶ä»»åŠ¡** | APScheduler æœ¬åœ°è°ƒåº¦ | æ— éœ€äº‘ç«¯ï¼Œç¦»çº¿å¯ç”¨ |
| **æ•°æ®å­˜å‚¨** | SQLite æœ¬åœ°æ•°æ®åº“ | å®Œå…¨æŒæ§æ•°æ® |
| **å‡­è¯å®‰å…¨** | æœ¬åœ°åŠ å¯†å­˜å‚¨ | æœ€é«˜å®‰å…¨ç­‰çº§ |
| **ç¦»çº¿èƒ½åŠ›** | å®Œæ•´åŠŸèƒ½å¯ç¦»çº¿ä½¿ç”¨ | ä¸ä¾èµ–ç½‘ç»œ |
| **LLM ç®¡ç†** | æœ¬åœ° LLM ç½‘å…³é…ç½® | å¤šä¾›åº”å•†åˆ‡æ¢ã€æˆæœ¬æ§åˆ¶ |

---

## 2. æ¶æ„æ¦‚è¿°

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          æ¡Œé¢ç«¯åº”ç”¨ (Tauri 2.0)                                   â”‚
â”‚                                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         å‰ç«¯ UI (React + TypeScript)                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚ åˆ›ä½œå·¥ä½œå° â”‚ â”‚  ç´ æç®¡ç†  â”‚ â”‚  å‘å¸ƒä¸­å¿ƒ  â”‚ â”‚  æ•°æ®çœ‹æ¿  â”‚ â”‚ è´¦å·ç®¡ç† â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ æ™ºèƒ½å†™ä½œ   â”‚ â”‚  æƒ³æ³•åº“    â”‚ â”‚  å®šæ—¶å‘å¸ƒ  â”‚ â”‚  èˆ†æƒ…åˆ†æ  â”‚ â”‚ å‡­è¯ç®¡ç† â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ AIé…å›¾    â”‚ â”‚  çŸ¥è¯†åº“    â”‚ â”‚  æ‰¹é‡å‘å¸ƒ  â”‚ â”‚  æ•°æ®é‡‡é›†  â”‚ â”‚ å¹³å°ç»‘å®š â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚ IPC (Tauri Commands)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                           Rust Core (Tauri åç«¯)                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚ â”‚
â”‚  â”‚  â”‚  æ–‡ä»¶ç³»ç»Ÿ  â”‚ â”‚  æ•°æ®å­˜å‚¨  â”‚ â”‚  ç³»ç»Ÿæ‰˜ç›˜  â”‚ â”‚  è¿›ç¨‹ç®¡ç†  â”‚              â”‚ â”‚
â”‚  â”‚  â”‚  è¯»å†™æ“ä½œ  â”‚ â”‚  SQLite    â”‚ â”‚  é€šçŸ¥ç®¡ç†  â”‚ â”‚  Sidecar   â”‚              â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚ â”‚
â”‚  â”‚  â”‚  å‡­è¯åŠ å¯†  â”‚ â”‚  çª—å£ç®¡ç†  â”‚ â”‚  è‡ªåŠ¨æ›´æ–°  â”‚ â”‚  äº‘ç«¯é€šä¿¡  â”‚              â”‚ â”‚
â”‚  â”‚  â”‚  Keychain  â”‚ â”‚  å¤šçª—å£    â”‚ â”‚  çƒ­æ›´æ–°    â”‚ â”‚  APIåŒæ­¥   â”‚              â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚ JSON-RPC over stdio                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                        Python Sidecar (ç‹¬ç«‹è¿›ç¨‹)                            â”‚ â”‚
â”‚  â”‚                                                                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚                       agent-core (å…±äº«æ ¸å¿ƒåŒ…)                          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  GraphLoader    â”‚ â”‚  GraphCompiler  â”‚ â”‚  ToolRegistry   â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Graph åŠ è½½å™¨   â”‚ â”‚   Graph ç¼–è¯‘å™¨   â”‚ â”‚   å·¥å…·æ³¨å†Œè¡¨     â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ RuntimeContext  â”‚ â”‚ ExecutorInterfaceâ”‚ â”‚ AssetResolver   â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚   è¿è¡Œæ—¶ä¸Šä¸‹æ–‡   â”‚ â”‚    æ‰§è¡Œå™¨æ¥å£    â”‚ â”‚   èµ„æºè§£æå™¨     â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚                       LocalExecutor (æœ¬åœ°æ‰§è¡Œå™¨)                       â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  æœ¬åœ°æµè§ˆå™¨å·¥å…·  â”‚ â”‚   æœ¬åœ°å‡­è¯å·¥å…·   â”‚ â”‚  BettaFish å·¥å…·  â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  browser_publishâ”‚ â”‚ credential_storeâ”‚ â”‚   hot_topicç­‰    â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚                       è‡ªåŠ¨åŒ–å¼•æ“ (Automation)                          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚   Playwright    â”‚ â”‚   APScheduler   â”‚ â”‚  Platform       â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  æµè§ˆå™¨è‡ªåŠ¨åŒ–    â”‚ â”‚    å®šæ—¶ä»»åŠ¡      â”‚ â”‚   Adapters      â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚                       å†…å®¹å¤„ç† (Content)                               â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  è§†é¢‘å¤„ç†       â”‚ â”‚  å›¾ç‰‡å¤„ç†        â”‚ â”‚  æ–‡æ¡£å¤„ç†       â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  FFmpeg         â”‚ â”‚  Pillow         â”‚ â”‚  Markdown       â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚                       LLM ç®¡ç† (LLM Gateway)                          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  ä¾›åº”å•†ç®¡ç†      â”‚ â”‚   æ¨¡å‹é…ç½®       â”‚ â”‚   ç”¨é‡ç»Ÿè®¡       â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  API Key ç®¡ç†   â”‚ â”‚   æ¨¡å‹ç»„         â”‚ â”‚   æˆæœ¬æ§åˆ¶       â”‚          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                                  â”‚
â”‚  Windows / macOS / Linux                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. å‰ç«¯æŠ€æœ¯é€‰å‹

### 3.1 æŠ€æœ¯æ ˆæ€»è§ˆ

```yaml
æ ¸å¿ƒæ¡†æ¶:
  æ„å»ºå·¥å…·: Vite 6.x
  æ¡†æ¶: React 19
  è¯­è¨€: TypeScript 5.x

UI å±‚:
  ç»„ä»¶åº“: shadcn/ui (åŸºäº Radix UI)
  æ ·å¼æ–¹æ¡ˆ: Tailwind CSS 4.x
  å›¾æ ‡åº“: Lucide React
  åŠ¨ç”»: Framer Motion

çŠ¶æ€ç®¡ç†:
  å…¨å±€çŠ¶æ€: Zustand
  æœåŠ¡ç«¯çŠ¶æ€: TanStack Query v5
  è¡¨å•çŠ¶æ€: React Hook Form

è·¯ç”±:
  æ–¹æ¡ˆ: TanStack Router

æ•°æ®éªŒè¯:
  æ–¹æ¡ˆ: Zod

ç¼–è¾‘å™¨ (åˆ›ä½œæ ¸å¿ƒ):
  å¯Œæ–‡æœ¬: TipTap (åŸºäº ProseMirror)
  Markdown: @uiw/react-md-editor

å›¾è¡¨:
  æ–¹æ¡ˆ: Recharts / ECharts
```

### 3.2 UI æ¡†æ¶é€‰å‹ä¾æ®

| ç»´åº¦ | Ant Design | Radix UI | shadcn/ui âœ… |
|------|-----------|----------|--------------|
| **åŒ…ä½“ç§¯** | è¾ƒå¤§ (~1MB+) | è½»é‡ (~50KB) | è½»é‡ (æŒ‰éœ€å¤åˆ¶) |
| **æ ·å¼æ–¹æ¡ˆ** | Less/CSS-in-JS | æ— æ ·å¼åŸè¯­ | Tailwind CSS |
| **å®šåˆ¶æ€§** | ä¸­ç­‰ | æé«˜ | é«˜ |
| **è®¾è®¡é£æ ¼** | ä¼ä¸šç®¡ç†ç³»ç»Ÿ | æ— é¢„è®¾ | ç°ä»£ç®€æ´ |
| **Tauri é€‚é…** | ä¸€èˆ¬ | ä¼˜ç§€ | ä¼˜ç§€ |

**é€‰æ‹© shadcn/ui çš„ç†ç”±**:

1. **è½»é‡**: ä»£ç å¤åˆ¶åˆ°é¡¹ç›®ï¼Œæ— é¢å¤–ä¾èµ–ï¼ŒTauri åŒ…ä½“ç§¯å¯æ§
2. **å®šåˆ¶æ€§**: åŸºäº Radix UI åŸè¯­ï¼Œå¯æ·±åº¦å®šåˆ¶åˆ›ä½œç±»ç•Œé¢
3. **ç°ä»£è®¾è®¡**: é£æ ¼æ›´é€‚åˆåˆ›ä½œè€…å·¥å…·ï¼Œä¸åƒ Ant Design é‚£ä¹ˆ"ç®¡ç†ç³»ç»Ÿ"
4. **Tailwind**: ä¸ Tauri ç”Ÿæ€é…åˆå¥½ï¼Œæ ·å¼éš”ç¦»æ¸…æ™°
5. **å¯æ‰©å±•**: éœ€è¦å¤æ‚ç»„ä»¶æ—¶å¯æŒ‰éœ€å¼•å…¥å…¶ä»–åº“è¡¥å……

### 3.3 ç›®å½•ç»“æ„

```text
tauri-app/
â”œâ”€â”€ src/                              # React å‰ç«¯æºç 
â”‚   â”œâ”€â”€ main.tsx                      # åº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ App.tsx                       # æ ¹ç»„ä»¶
â”‚   â”œâ”€â”€ routes/                       # è·¯ç”±é…ç½® (TanStack Router)
â”‚   â”‚   â”œâ”€â”€ __root.tsx                # æ ¹è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ index.tsx                 # é¦–é¡µ
â”‚   â”‚   â”œâ”€â”€ creation/                 # åˆ›ä½œæ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ index.tsx
â”‚   â”‚   â”‚   â””â”€â”€ $draftId.tsx
â”‚   â”‚   â”œâ”€â”€ publish/                  # å‘å¸ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ analytics/                # æ•°æ®æ¨¡å—
â”‚   â”‚   â””â”€â”€ settings/                 # è®¾ç½®æ¨¡å—
â”‚   â”‚
â”‚   â”œâ”€â”€ components/                   # ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ui/                       # shadcn/ui ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ button.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ dialog.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ input.tsx
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ layout/                   # å¸ƒå±€ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”‚   â””â”€â”€ MainLayout.tsx
â”‚   â”‚   â”œâ”€â”€ editor/                   # ç¼–è¾‘å™¨ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ TiptapEditor.tsx
â”‚   â”‚   â”‚   â””â”€â”€ EditorToolbar.tsx
â”‚   â”‚   â””â”€â”€ shared/                   # å…±äº«ä¸šåŠ¡ç»„ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/                        # è‡ªå®šä¹‰ Hooks
â”‚   â”‚   â”œâ”€â”€ useAgent.ts               # Agent è°ƒç”¨
â”‚   â”‚   â”œâ”€â”€ useSidecar.ts             # Sidecar é€šä¿¡
â”‚   â”‚   â””â”€â”€ useHotTopics.ts           # çƒ­ç‚¹è¯é¢˜
â”‚   â”‚
â”‚   â”œâ”€â”€ stores/                       # Zustand çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ useAppStore.ts            # åº”ç”¨çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ useDraftStore.ts          # è‰ç¨¿çŠ¶æ€
â”‚   â”‚   â””â”€â”€ useAccountStore.ts        # è´¦å·çŠ¶æ€
â”‚   â”‚
â”‚   â”œâ”€â”€ lib/                          # å·¥å…·åº“
â”‚   â”‚   â”œâ”€â”€ sidecar-client.ts         # Sidecar å®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ llm-client.ts             # LLM å®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ utils.ts                  # é€šç”¨å·¥å…·
â”‚   â”‚   â””â”€â”€ cn.ts                     # className åˆå¹¶
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                          # API å±‚ (TanStack Query)
â”‚   â”‚   â”œâ”€â”€ queries/                  # æŸ¥è¯¢
â”‚   â”‚   â””â”€â”€ mutations/                # å˜æ›´
â”‚   â”‚
â”‚   â””â”€â”€ styles/                       # æ ·å¼
â”‚       â””â”€â”€ globals.css               # å…¨å±€æ ·å¼ + Tailwind
â”‚
â”œâ”€â”€ src-tauri/                        # Tauri Rust åç«¯
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ components.json                   # shadcn/ui é…ç½®
â”œâ”€â”€ tailwind.config.ts                # Tailwind é…ç½®
â”œâ”€â”€ tsconfig.json                     # TypeScript é…ç½®
â”œâ”€â”€ vite.config.ts                    # Vite é…ç½®
â””â”€â”€ package.json
```

### 3.4 æ ¸å¿ƒä¾èµ–

```json
{
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "@tauri-apps/api": "^2.0.0",
    "@tanstack/react-router": "^1.90.0",
    "@tanstack/react-query": "^5.60.0",
    "zustand": "^5.0.0",
    "react-hook-form": "^7.54.0",
    "@hookform/resolvers": "^3.9.0",
    "zod": "^3.24.0",
    "@tiptap/react": "^2.10.0",
    "@tiptap/starter-kit": "^2.10.0",
    "@radix-ui/react-dialog": "^1.1.0",
    "@radix-ui/react-dropdown-menu": "^2.1.0",
    "@radix-ui/react-select": "^2.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.5.0",
    "lucide-react": "^0.460.0",
    "framer-motion": "^11.12.0",
    "recharts": "^2.14.0"
  },
  "devDependencies": {
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@vitejs/plugin-react": "^4.3.0",
    "typescript": "^5.7.0",
    "vite": "^6.0.0",
    "tailwindcss": "^4.0.0",
    "postcss": "^8.4.0",
    "autoprefixer": "^10.4.0"
  }
}
```

### 3.5 é¡¹ç›®åˆå§‹åŒ–

```bash
# 1. åˆ›å»º Tauri + Vite + React é¡¹ç›®
pnpm create tauri-app tauri-app --template react-ts

cd tauri-app

# 2. å®‰è£… Tailwind CSS
pnpm add -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

# 3. åˆå§‹åŒ– shadcn/ui
pnpm dlx shadcn@latest init

# 4. å®‰è£… shadcn/ui å¸¸ç”¨ç»„ä»¶
pnpm dlx shadcn@latest add button dialog input select tabs dropdown-menu \
  form toast tooltip popover command sheet avatar badge card

# 5. å®‰è£…çŠ¶æ€ç®¡ç†
pnpm add zustand @tanstack/react-query

# 6. å®‰è£…è·¯ç”±
pnpm add @tanstack/react-router
pnpm add -D @tanstack/router-plugin @tanstack/router-devtools

# 7. å®‰è£…è¡¨å•éªŒè¯
pnpm add react-hook-form @hookform/resolvers zod

# 8. å®‰è£…ç¼–è¾‘å™¨
pnpm add @tiptap/react @tiptap/starter-kit @tiptap/extension-placeholder \
  @tiptap/extension-image @tiptap/extension-link

# 9. å®‰è£…å›¾è¡¨
pnpm add recharts

# 10. å®‰è£…åŠ¨ç”»
pnpm add framer-motion
```

### 3.6 é…ç½®æ–‡ä»¶

#### Vite é…ç½®

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { TanStackRouterVite } from '@tanstack/router-plugin/vite';
import path from 'path';

export default defineConfig({
  plugins: [
    TanStackRouterVite(),
    react(),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  clearScreen: false,
  server: {
    port: 1420,
    strictPort: true,
    watch: {
      ignored: ['**/src-tauri/**'],
    },
  },
});
```

#### Tailwind é…ç½®

```typescript
// tailwind.config.ts
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: ['./src/**/*.{ts,tsx}'],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};

export default config;
```

#### TypeScript é…ç½®

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

## 4. Python Sidecar è®¾è®¡

> **é‡è¦**: Python Sidecar ä½¿ç”¨ `agent-core` å…±äº«åŒ…ï¼Œä¸é‡å¤å®šä¹‰ Agent ç›¸å…³ä»£ç ã€‚
> è¯¦è§ [Agent Runtime](./05-Agent-Runtime.md) æ–‡æ¡£ã€‚

### 4.1 ç›®å½•ç»“æ„

```text
apps/sidecar/                     # æ¡Œé¢ç«¯ Python Sidecar (Monorepo ç»“æ„)
â”œâ”€â”€ pyproject.toml                # ä¾èµ–ç®¡ç† (uv)ï¼Œä¾èµ– agent-core
â”œâ”€â”€ src/
â”‚   â””â”€â”€ sidecar/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ main.py               # å…¥å£ç‚¹
â”‚       â”œâ”€â”€ server.py             # JSON-RPC æœåŠ¡å™¨
â”‚       â”œâ”€â”€ executor.py           # LocalExecutor (ç»§æ‰¿ agent-core)
â”‚       â”‚
â”‚       â”œâ”€â”€ tools/                # ğŸ”¥ æœ¬åœ°ä¸“å±å·¥å…·ï¼ˆæ³¨å†Œåˆ° agent-coreï¼‰
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ browser.py        # æœ¬åœ°æµè§ˆå™¨å‘å¸ƒå·¥å…·
â”‚       â”‚   â”œâ”€â”€ credential.py     # æœ¬åœ°å‡­è¯å·¥å…·
â”‚       â”‚   â””â”€â”€ bettafish/        # BettaFish æœ¬åœ°å·¥å…·
â”‚       â”‚       â”œâ”€â”€ __init__.py
â”‚       â”‚       â”œâ”€â”€ hot_topic.py
â”‚       â”‚       â””â”€â”€ sentiment.py
â”‚       â”‚
â”‚       â”œâ”€â”€ automation/           # è‡ªåŠ¨åŒ–æ¨¡å—
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ browser/          # æµè§ˆå™¨è‡ªåŠ¨åŒ–
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â”œâ”€â”€ manager.py    # æµè§ˆå™¨å®ä¾‹ç®¡ç†
â”‚       â”‚   â”‚   â””â”€â”€ stealth.py    # åæ£€æµ‹
â”‚       â”‚   â”œâ”€â”€ scheduler.py      # å®šæ—¶ä»»åŠ¡
â”‚       â”‚   â””â”€â”€ task_queue.py     # ä»»åŠ¡é˜Ÿåˆ—
â”‚       â”‚
â”‚       â”œâ”€â”€ content/              # å†…å®¹å¤„ç†
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ video/            # è§†é¢‘å¤„ç†
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â””â”€â”€ processor.py
â”‚       â”‚   â”œâ”€â”€ image/            # å›¾ç‰‡å¤„ç†
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â””â”€â”€ processor.py
â”‚       â”‚   â””â”€â”€ document/         # æ–‡æ¡£å¤„ç†
â”‚       â”‚       â”œâ”€â”€ __init__.py
â”‚       â”‚       â””â”€â”€ markdown.py
â”‚       â”‚
â”‚       â”œâ”€â”€ storage/              # å­˜å‚¨å±‚
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ credential.py     # å‡­è¯ç®¡ç†
â”‚       â”‚   â””â”€â”€ asset.py          # èµ„æºç®¡ç† (LocalAssetResolver)
â”‚       â”‚
â”‚       â”œâ”€â”€ llm/                  # LLM ç®¡ç†æ¨¡å—
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ gateway.py        # LLM ç½‘å…³
â”‚       â”‚   â”œâ”€â”€ provider.py       # ä¾›åº”å•†ç®¡ç†
â”‚       â”‚   â”œâ”€â”€ model_config.py   # æ¨¡å‹é…ç½®
â”‚       â”‚   â”œâ”€â”€ rate_limiter.py   # é€Ÿç‡é™åˆ¶
â”‚       â”‚   â””â”€â”€ usage_tracker.py  # ç”¨é‡ç»Ÿè®¡
â”‚       â”‚
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ __init__.py
â”‚           â”œâ”€â”€ config.py
â”‚           â”œâ”€â”€ logger.py
â”‚           â””â”€â”€ crypto.py         # å‡­è¯åŠ å¯†
â”‚
â””â”€â”€ tests/

# Graph å®šä¹‰æ–‡ä»¶ä½äº Monorepo æ ¹ç›®å½•ï¼ˆç«¯äº‘å…±äº«ï¼‰
agent-definitions/                # ğŸ”¥ å…±äº« Graph å®šä¹‰
â”œâ”€â”€ content-creation.yaml
â”œâ”€â”€ viral-content.yaml
â”œâ”€â”€ publish-workflow.yaml
â””â”€â”€ analytics.yaml
```

### 4.2 ä¸ agent-core çš„å…³ç³»

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ä»£ç å…±äº«æ¶æ„                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  packages/agent-core/           # ğŸ”¥ å…±äº«æ ¸å¿ƒåŒ…                              â”‚
â”‚  â”œâ”€â”€ graph/                     # Graph åŠ è½½/ç¼–è¯‘                           â”‚
â”‚  â”œâ”€â”€ runtime/                   # ExecutorInterface, RuntimeContext         â”‚
â”‚  â”œâ”€â”€ tools/                     # ToolInterface, ToolRegistry               â”‚
â”‚  â”‚   â”œâ”€â”€ builtin/               # ç«¯äº‘å…±ç”¨å·¥å…· (llm_generate, web_search)   â”‚
â”‚  â”‚   â””â”€â”€ stubs/                 # å·¥å…·æ¥å£æ¡© (browser, credential)          â”‚
â”‚  â”œâ”€â”€ resource/                  # AssetURI, AssetResolver                   â”‚
â”‚  â””â”€â”€ platforms/                 # å¹³å°é€‚é…å™¨åŸºç±»                             â”‚
â”‚                                                                             â”‚
â”‚  apps/sidecar/                  # æ¡Œé¢ç«¯ Sidecar                            â”‚
â”‚  â”œâ”€â”€ executor.py                # LocalExecutor (å®ç° ExecutorInterface)    â”‚
â”‚  â””â”€â”€ tools/                     # ğŸ”¥ æœ¬åœ°ä¸“å±å·¥å…·å®ç°                        â”‚
â”‚      â”œâ”€â”€ browser.py             # æ³¨å†Œåˆ° RuntimeType.LOCAL                  â”‚
â”‚      â””â”€â”€ credential.py          # æ³¨å†Œåˆ° RuntimeType.LOCAL                  â”‚
â”‚                                                                             â”‚
â”‚  agent-definitions/             # ğŸ”¥ å…±äº« Graph å®šä¹‰ï¼ˆå”¯ä¸€æ¥æºï¼‰              â”‚
â”‚  â””â”€â”€ *.yaml                     # ç«¯äº‘ä½¿ç”¨åŒä¸€ä»½ Graph                       â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.3 pyproject.toml é…ç½®

```toml
# apps/sidecar/pyproject.toml

[project]
name = "ai-creator-sidecar"
version = "0.1.0"
description = "AI Creator æ¡Œé¢ç«¯ Python Sidecar"
requires-python = ">=3.11"

dependencies = [
    "agent-core",           # ğŸ”¥ workspace å¼•ç”¨ï¼Œå…±äº«æ ¸å¿ƒåŒ…
    "playwright>=1.40.0",   # æœ¬åœ°æµè§ˆå™¨è‡ªåŠ¨åŒ–
    "apscheduler>=3.10.0",  # æœ¬åœ°å®šæ—¶ä»»åŠ¡
    "uvicorn>=0.30.0",
    "loguru>=0.7.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/sidecar"]
```

### 4.4 JSON-RPC æœåŠ¡å™¨

```python
# apps/sidecar/src/sidecar/server.py
import asyncio
import json
import sys
from typing import Any, Callable
from dataclasses import dataclass
from loguru import logger

@dataclass
class RpcMethod:
    """RPC æ–¹æ³•å®šä¹‰"""
    name: str
    handler: Callable
    description: str = ""

class JsonRpcServer:
    """JSON-RPC æœåŠ¡å™¨ï¼Œé€šè¿‡ stdio ä¸ Tauri é€šä¿¡"""

    def __init__(self):
        self.handlers: dict[str, Callable] = {}
        self._running = False
        self._request_handlers: dict[int, asyncio.Future] = {}

    def register(self, method: str, description: str = ""):
        """è£…é¥°å™¨ï¼šæ³¨å†Œ RPC æ–¹æ³•"""
        def decorator(func: Callable):
            self.handlers[method] = func
            logger.info(f"Registered RPC method: {method}")
            return func
        return decorator

    async def handle_request(self, request: dict) -> dict:
        """å¤„ç†å•ä¸ªè¯·æ±‚"""
        method = request.get("method")
        params = request.get("params", {})
        request_id = request.get("id")

        if method not in self.handlers:
            return {
                "jsonrpc": "2.0",
                "error": {"code": -32601, "message": f"Method not found: {method}"},
                "id": request_id
            }

        try:
            handler = self.handlers[method]
            if asyncio.iscoroutinefunction(handler):
                result = await handler(**params)
            else:
                result = handler(**params)
            return {"jsonrpc": "2.0", "result": result, "id": request_id}
        except Exception as e:
            logger.exception(f"Error handling {method}")
            return {
                "jsonrpc": "2.0",
                "error": {"code": -32000, "message": str(e)},
                "id": request_id
            }

    async def send_notification(self, method: str, params: dict):
        """å‘é€é€šçŸ¥åˆ° Tauriï¼ˆæ— éœ€å“åº”ï¼‰"""
        notification = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params
        }
        sys.stdout.write(json.dumps(notification) + "\n")
        sys.stdout.flush()

    async def run(self):
        """ä¸»å¾ªç¯ï¼šä» stdin è¯»å–ï¼Œå†™å…¥ stdout"""
        self._running = True
        logger.info("Python Sidecar started")

        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await asyncio.get_event_loop().connect_read_pipe(lambda: protocol, sys.stdin)

        while self._running:
            try:
                line = await reader.readline()
                if not line:
                    break

                request = json.loads(line.decode().strip())
                response = await self.handle_request(request)

                sys.stdout.write(json.dumps(response) + "\n")
                sys.stdout.flush()

            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON: {e}")
            except Exception as e:
                logger.exception("Error in main loop")

        logger.info("Python Sidecar stopped")

    def stop(self):
        """åœæ­¢æœåŠ¡å™¨"""
        self._running = False

# å…¨å±€æœåŠ¡å™¨å®ä¾‹
server = JsonRpcServer()
```

### 4.5 Agent é›†æˆï¼ˆä½¿ç”¨ agent-coreï¼‰

```python
# apps/sidecar/src/sidecar/executor.py
"""
æœ¬åœ°æ‰§è¡Œå™¨ - ç»§æ‰¿ agent-core çš„ ExecutorInterface
è¯¦è§ 05-Agent-Runtime.md ä¸­çš„å®Œæ•´å®ç°
"""
from typing import AsyncIterator
from datetime import datetime

from agent_core.runtime.interfaces import (
    ExecutorInterface, RuntimeType, RuntimeContext,
    ExecutionRequest, ExecutionResponse, AgentEvent
)
from agent_core.graph.loader import GraphLoader
from agent_core.graph.compiler import GraphCompiler
from agent_core.tools.registry import ToolRegistry
from agent_core.resource.resolver import LocalAssetResolver

from .server import server
from .automation.browser.manager import browser_manager


class LocalExecutor(ExecutorInterface):
    """
    æœ¬åœ°æ‰§è¡Œå™¨ - æ¡Œé¢ç«¯ Python Sidecar

    ç»§æ‰¿ agent-core çš„ ExecutorInterfaceï¼Œå®ç°æœ¬åœ°ä¸“å±é€»è¾‘ï¼š
    - ä½¿ç”¨æœ¬åœ°æµè§ˆå™¨ç®¡ç†å™¨
    - ä½¿ç”¨æœ¬åœ°å‡­è¯å­˜å‚¨
    - ä½¿ç”¨æœ¬åœ°èµ„æºè§£æå™¨
    """

    runtime_type = RuntimeType.LOCAL

    def __init__(self, config: dict):
        self.config = config
        self.graph_loader = GraphLoader(
            definitions_path=config.get('definitions_path', 'agent-definitions')
        )
        self.tool_registry = ToolRegistry(RuntimeType.LOCAL)
        self.compiler = GraphCompiler(self.tool_registry)
        self._executions: dict[str, dict] = {}

        # æ³¨å†Œæœ¬åœ°ä¸“å±å·¥å…·
        self._register_local_tools()

    def _register_local_tools(self):
        """æ³¨å†Œæœ¬åœ°ä¸“å±å·¥å…·åˆ° ToolRegistry"""
        # æœ¬åœ°å·¥å…·åœ¨ sidecar/tools/ ç›®å½•ä¸‹å®šä¹‰
        # ä½¿ç”¨ @ToolRegistry.register("tool_name", RuntimeType.LOCAL) è£…é¥°å™¨
        from .tools import browser, credential, bettafish
        # å·¥å…·ä¼šåœ¨å¯¼å…¥æ—¶è‡ªåŠ¨æ³¨å†Œ

    def _create_context(self, request: ExecutionRequest) -> RuntimeContext:
        """åˆ›å»ºè¿è¡Œæ—¶ä¸Šä¸‹æ–‡"""
        return RuntimeContext(
            runtime_type=RuntimeType.LOCAL,
            user_id=request.user_id,
            inputs=request.inputs,
            model_default=self.config.get('default_model', 'claude-sonnet-4-20250514'),
            model_fast=self.config.get('fast_model', 'claude-3-5-haiku-20241022'),
            api_keys={
                "anthropic": self.config.get('anthropic_api_key'),
            },
            asset_resolver=LocalAssetResolver(self.config),
            extra={
                "browser_manager": browser_manager,  # æœ¬åœ°æµè§ˆå™¨ç®¡ç†å™¨
            }
        )

    async def execute(self, request: ExecutionRequest) -> ExecutionResponse:
        """æ‰§è¡Œ Graph - è¯¦è§ 05-Agent-Runtime.md"""
        # å®ç°ç»§æ‰¿è‡ª agent-coreï¼Œæ­¤å¤„çœç•¥
        pass

    async def execute_stream(
        self, request: ExecutionRequest
    ) -> AsyncIterator[AgentEvent]:
        """æµå¼æ‰§è¡Œ Graphï¼Œè¿”å›äº‹ä»¶æµ"""
        # å®ç°ç»§æ‰¿è‡ª agent-coreï¼Œæ­¤å¤„çœç•¥
        pass

    async def get_status(self, execution_id: str) -> dict:
        return self._executions.get(execution_id, {"status": "not_found"})

    async def cancel(self, execution_id: str) -> bool:
        if execution_id in self._executions:
            self._executions[execution_id]["status"] = "cancelled"
            return True
        return False

    async def health_check(self) -> bool:
        return True


# åˆ›å»ºæ‰§è¡Œå™¨å®ä¾‹
executor: LocalExecutor = None


def init_executor(config: dict):
    """åˆå§‹åŒ–æ‰§è¡Œå™¨"""
    global executor
    executor = LocalExecutor(config)


# RPC æ¥å£
@server.register("agent.execute_graph")
async def execute_graph(
    graph_name: str,
    inputs: dict,
    user_id: str,
    config: dict | None = None
) -> dict:
    """æ‰§è¡Œ Agent Graph"""
    request = ExecutionRequest(
        graph_name=graph_name,
        inputs=inputs,
        user_id=user_id,
    )

    # å‘é€äº‹ä»¶åˆ°å‰ç«¯
    async for event in executor.execute_stream(request):
        await server.send_notification("agent.event", {
            "event_type": event.event_type,
            "run_id": event.run_id,
            "data": event.data,
        })

    response = await executor.execute(request)
    return {
        "success": response.success,
        "outputs": response.outputs,
        "error": response.error,
        "execution_id": response.execution_id,
        "execution_time": response.execution_time,
    }


@server.register("agent.list_graphs")
async def list_graphs() -> list[str]:
    """åˆ—å‡ºå¯ç”¨çš„ Graph"""
    return executor.graph_loader.list_graphs()


@server.register("agent.get_graph_schema")
async def get_graph_schema(graph_name: str) -> dict:
    """è·å– Graph çš„è¾“å…¥è¾“å‡º Schema"""
    definition = executor.graph_loader.load(graph_name)
    return {
        "inputs": definition['spec'].get('inputs', {}),
        "outputs": definition['spec'].get('outputs', {}),
    }
```

### 4.6 æœ¬åœ°ä¸“å±å·¥å…·ç¤ºä¾‹

```python
# apps/sidecar/src/sidecar/tools/browser.py
"""
æœ¬åœ°æµè§ˆå™¨å‘å¸ƒå·¥å…· - ä»…åœ¨æ¡Œé¢ç«¯å¯ç”¨
ä½¿ç”¨ Playwright è¿›è¡Œæœ¬åœ°æµè§ˆå™¨è‡ªåŠ¨åŒ–
"""
from agent_core.tools.base import ToolInterface, ToolMetadata, ToolCapability, ToolResult
from agent_core.tools.registry import ToolRegistry
from agent_core.runtime.interfaces import RuntimeType, RuntimeContext
from agent_core.platforms import get_adapter


@ToolRegistry.register("browser_publish", RuntimeType.LOCAL)
class LocalBrowserPublishTool(ToolInterface):
    """æœ¬åœ°æµè§ˆå™¨å‘å¸ƒå·¥å…· - ä»…ç«¯ä¾§å¯ç”¨"""

    metadata = ToolMetadata(
        name="browser_publish",
        description="ä½¿ç”¨æœ¬åœ° Playwright æµè§ˆå™¨å‘å¸ƒå†…å®¹åˆ°ç¤¾äº¤å¹³å°",
        capabilities=[ToolCapability.BROWSER_AUTOMATION],
        supported_runtimes=[RuntimeType.LOCAL],  # ä»…æœ¬åœ°
    )

    async def execute(
        self,
        ctx: RuntimeContext,
        *,
        platform: str,
        account_id: str,
        content: dict,
    ) -> ToolResult:
        """ä½¿ç”¨æœ¬åœ° Playwright å‘å¸ƒ"""
        try:
            # ä»ä¸Šä¸‹æ–‡è·å–æµè§ˆå™¨ç®¡ç†å™¨
            browser_manager = ctx.extra.get("browser_manager")
            if not browser_manager:
                return ToolResult(
                    success=False,
                    data=None,
                    error="Browser manager not available"
                )

            # åˆ›å»ºæµè§ˆå™¨ä¼šè¯
            session = await browser_manager.create_session(
                session_id=f"{platform}_{account_id}",
                platform=platform,
            )

            # åŠ è½½æœ¬åœ°ä¿å­˜çš„å‡­è¯
            await self._load_credentials(session.context, platform, account_id)

            # ä½¿ç”¨å¹³å°é€‚é…å™¨å‘å¸ƒ
            adapter = get_adapter(platform)
            result = await adapter.publish(session.page, content)

            # å…³é—­ä¼šè¯
            await browser_manager.close_session(session.id)

            return ToolResult(success=True, data=result)

        except Exception as e:
            return ToolResult(success=False, data=None, error=str(e))

    async def _load_credentials(self, context, platform: str, account_id: str):
        """åŠ è½½æœ¬åœ°åŠ å¯†çš„å‡­è¯"""
        from ..storage.credential import credential_manager
        credential = credential_manager.load_credential(platform, account_id)
        if credential and credential.cookies:
            await context.add_cookies(credential.cookies)

    def get_schema(self) -> dict:
        return {
            "type": "object",
            "properties": {
                "platform": {
                    "type": "string",
                    "enum": ["xiaohongshu", "douyin", "weibo", "bilibili", "wechat_mp"],
                    "description": "ç›®æ ‡å¹³å°"
                },
                "account_id": {"type": "string", "description": "è´¦å·ID"},
                "content": {
                    "type": "object",
                    "description": "å‘å¸ƒå†…å®¹",
                    "properties": {
                        "title": {"type": "string"},
                        "text": {"type": "string"},
                        "images": {"type": "array", "items": {"type": "string"}},
                        "video": {"type": "string"},
                    }
                },
            },
            "required": ["platform", "account_id", "content"]
        }
```

### 4.7 æµè§ˆå™¨è‡ªåŠ¨åŒ–

```python
# apps/sidecar/src/sidecar/automation/browser/manager.py
import asyncio
from typing import Optional
from playwright.async_api import async_playwright, Browser, BrowserContext, Page
from dataclasses import dataclass
from loguru import logger

@dataclass
class BrowserSession:
    """æµè§ˆå™¨ä¼šè¯"""
    id: str
    platform: str
    context: BrowserContext
    page: Page
    created_at: float

class BrowserManager:
    """æµè§ˆå™¨å®ä¾‹ç®¡ç†å™¨"""

    def __init__(self):
        self._playwright = None
        self._browser: Optional[Browser] = None
        self._sessions: dict[str, BrowserSession] = {}
        self._lock = asyncio.Lock()

    async def initialize(self):
        """åˆå§‹åŒ–æµè§ˆå™¨"""
        if self._playwright is None:
            self._playwright = await async_playwright().start()
            self._browser = await self._playwright.chromium.launch(
                headless=False,  # æ¡Œé¢ç«¯é»˜è®¤éæ— å¤´
                args=[
                    '--disable-blink-features=AutomationControlled',
                    '--disable-infobars',
                ]
            )
            logger.info("Browser initialized")

    async def create_session(
        self,
        session_id: str,
        platform: str,
        cookies: list[dict] | None = None,
        storage_state: dict | None = None,
    ) -> BrowserSession:
        """åˆ›å»ºæµè§ˆå™¨ä¼šè¯"""
        async with self._lock:
            if self._browser is None:
                await self.initialize()

            # åˆ›å»ºéš”ç¦»çš„æµè§ˆå™¨ä¸Šä¸‹æ–‡
            context = await self._browser.new_context(
                viewport={'width': 1920, 'height': 1080},
                user_agent=self._get_user_agent(platform),
                storage_state=storage_state,
            )

            # æ³¨å…¥åæ£€æµ‹è„šæœ¬
            await self._inject_stealth(context)

            # è®¾ç½® Cookies
            if cookies:
                await context.add_cookies(cookies)

            page = await context.new_page()

            session = BrowserSession(
                id=session_id,
                platform=platform,
                context=context,
                page=page,
                created_at=asyncio.get_event_loop().time(),
            )
            self._sessions[session_id] = session

            logger.info(f"Created browser session: {session_id} for {platform}")
            return session

    async def get_session(self, session_id: str) -> Optional[BrowserSession]:
        """è·å–ä¼šè¯"""
        return self._sessions.get(session_id)

    async def close_session(self, session_id: str):
        """å…³é—­ä¼šè¯"""
        if session_id in self._sessions:
            session = self._sessions.pop(session_id)
            await session.context.close()
            logger.info(f"Closed browser session: {session_id}")

    async def export_cookies(self, session_id: str) -> list[dict]:
        """å¯¼å‡ºä¼šè¯çš„ Cookies"""
        session = self._sessions.get(session_id)
        if session:
            return await session.context.cookies()
        return []

    async def export_storage_state(self, session_id: str) -> dict:
        """å¯¼å‡ºå®Œæ•´çš„å­˜å‚¨çŠ¶æ€ï¼ˆCookies + LocalStorageï¼‰"""
        session = self._sessions.get(session_id)
        if session:
            return await session.context.storage_state()
        return {}

    def _get_user_agent(self, platform: str) -> str:
        """è·å–å¹³å°å¯¹åº”çš„ User-Agent"""
        user_agents = {
            "xiaohongshu": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "douyin": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "weibo": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "bilibili": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        }
        return user_agents.get(platform, user_agents["xiaohongshu"])

    async def _inject_stealth(self, context: BrowserContext):
        """æ³¨å…¥åæ£€æµ‹è„šæœ¬"""
        await context.add_init_script("""
            // éšè— webdriver æ ‡è®°
            Object.defineProperty(navigator, 'webdriver', { get: () => undefined });

            // ä¿®æ”¹ plugins
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5]
            });

            // ä¿®æ”¹ languages
            Object.defineProperty(navigator, 'languages', {
                get: () => ['zh-CN', 'zh', 'en']
            });
        """)

# å…¨å±€ç®¡ç†å™¨
browser_manager = BrowserManager()
```

### 4.8 å®šæ—¶ä»»åŠ¡è°ƒåº¦

```python
# apps/sidecar/src/sidecar/automation/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.date import DateTrigger
from datetime import datetime
from typing import Optional
from dataclasses import dataclass
from loguru import logger

from ..server import server

@dataclass
class ScheduledTask:
    """å®šæ—¶ä»»åŠ¡"""
    id: str
    task_type: str
    params: dict
    trigger_type: str  # "date" | "cron"
    trigger_config: str
    created_at: datetime
    next_run: Optional[datetime] = None
    last_run: Optional[datetime] = None
    status: str = "active"

class TaskScheduler:
    """å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨"""

    def __init__(self):
        self.scheduler = AsyncIOScheduler()
        self._tasks: dict[str, ScheduledTask] = {}

    def start(self):
        """å¯åŠ¨è°ƒåº¦å™¨"""
        self.scheduler.start()
        logger.info("Task scheduler started")

    def stop(self):
        """åœæ­¢è°ƒåº¦å™¨"""
        self.scheduler.shutdown()
        logger.info("Task scheduler stopped")

    async def add_publish_task(
        self,
        task_id: str,
        platform: str,
        content: dict,
        schedule_time: datetime
    ) -> ScheduledTask:
        """æ·»åŠ å®šæ—¶å‘å¸ƒä»»åŠ¡"""
        task = ScheduledTask(
            id=task_id,
            task_type="publish",
            params={"platform": platform, "content": content},
            trigger_type="date",
            trigger_config=schedule_time.isoformat(),
            created_at=datetime.now(),
            next_run=schedule_time,
        )

        self.scheduler.add_job(
            self._execute_publish,
            trigger=DateTrigger(run_date=schedule_time),
            id=task_id,
            kwargs={"task": task},
            replace_existing=True,
        )

        self._tasks[task_id] = task
        logger.info(f"Added publish task: {task_id} scheduled for {schedule_time}")
        return task

    async def add_analytics_task(
        self,
        task_id: str,
        platform: str,
        post_id: str,
        cron: str
    ) -> ScheduledTask:
        """æ·»åŠ å®šæ—¶æ•°æ®é‡‡é›†ä»»åŠ¡"""
        task = ScheduledTask(
            id=task_id,
            task_type="analytics",
            params={"platform": platform, "post_id": post_id},
            trigger_type="cron",
            trigger_config=cron,
            created_at=datetime.now(),
        )

        self.scheduler.add_job(
            self._execute_analytics,
            trigger=CronTrigger.from_crontab(cron),
            id=task_id,
            kwargs={"task": task},
            replace_existing=True,
        )

        self._tasks[task_id] = task
        logger.info(f"Added analytics task: {task_id} with cron {cron}")
        return task

    async def remove_task(self, task_id: str):
        """ç§»é™¤ä»»åŠ¡"""
        if task_id in self._tasks:
            self.scheduler.remove_job(task_id)
            del self._tasks[task_id]
            logger.info(f"Removed task: {task_id}")

    async def list_tasks(self) -> list[dict]:
        """åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡"""
        return [
            {
                "id": task.id,
                "task_type": task.task_type,
                "params": task.params,
                "trigger_type": task.trigger_type,
                "trigger_config": task.trigger_config,
                "next_run": task.next_run.isoformat() if task.next_run else None,
                "last_run": task.last_run.isoformat() if task.last_run else None,
                "status": task.status,
            }
            for task in self._tasks.values()
        ]

    async def _execute_publish(self, task: ScheduledTask):
        """æ‰§è¡Œå‘å¸ƒä»»åŠ¡"""
        logger.info(f"Executing publish task: {task.id}")
        try:
            from .browser.platforms import get_adapter

            platform = task.params["platform"]
            content = task.params["content"]

            adapter = get_adapter(platform)
            result = await adapter.publish(**content)

            task.last_run = datetime.now()
            task.status = "completed"

            # é€šçŸ¥å‰ç«¯
            await server.send_notification("scheduler.task_completed", {
                "task_id": task.id,
                "task_type": "publish",
                "result": result,
            })

        except Exception as e:
            logger.exception(f"Publish task failed: {task.id}")
            task.status = "failed"
            await server.send_notification("scheduler.task_failed", {
                "task_id": task.id,
                "error": str(e),
            })

    async def _execute_analytics(self, task: ScheduledTask):
        """æ‰§è¡Œæ•°æ®é‡‡é›†ä»»åŠ¡"""
        logger.info(f"Executing analytics task: {task.id}")
        try:
            from .browser.platforms import get_adapter

            platform = task.params["platform"]
            post_id = task.params["post_id"]

            adapter = get_adapter(platform)
            data = await adapter.fetch_analytics(post_id)

            task.last_run = datetime.now()

            # é€šçŸ¥å‰ç«¯
            await server.send_notification("scheduler.analytics_updated", {
                "task_id": task.id,
                "platform": platform,
                "post_id": post_id,
                "data": data,
            })

        except Exception as e:
            logger.exception(f"Analytics task failed: {task.id}")
            await server.send_notification("scheduler.task_failed", {
                "task_id": task.id,
                "error": str(e),
            })

# å…¨å±€è°ƒåº¦å™¨
task_scheduler = TaskScheduler()

# RPC æ¥å£
@server.register("scheduler.add_publish")
async def add_publish_task(
    task_id: str,
    platform: str,
    content: dict,
    schedule_time: str
) -> dict:
    """æ·»åŠ å®šæ—¶å‘å¸ƒä»»åŠ¡"""
    dt = datetime.fromisoformat(schedule_time)
    task = await task_scheduler.add_publish_task(task_id, platform, content, dt)
    return {"success": True, "task_id": task.id}

@server.register("scheduler.add_analytics")
async def add_analytics_task(
    task_id: str,
    platform: str,
    post_id: str,
    cron: str
) -> dict:
    """æ·»åŠ å®šæ—¶æ•°æ®é‡‡é›†ä»»åŠ¡"""
    task = await task_scheduler.add_analytics_task(task_id, platform, post_id, cron)
    return {"success": True, "task_id": task.id}

@server.register("scheduler.remove")
async def remove_task(task_id: str) -> dict:
    """ç§»é™¤ä»»åŠ¡"""
    await task_scheduler.remove_task(task_id)
    return {"success": True}

@server.register("scheduler.list")
async def list_tasks() -> list[dict]:
    """åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡"""
    return await task_scheduler.list_tasks()
```

---

## 5. Rust Core (Tauri åç«¯)

### 5.1 Sidecar ç®¡ç†å™¨

```rust
// src-tauri/src/sidecar/manager.rs
use tauri::api::process::{Command, CommandChild, CommandEvent};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, oneshot, mpsc};
use log::{info, error, warn};

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcRequest {
    jsonrpc: String,
    method: String,
    params: serde_json::Value,
    id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcResponse {
    jsonrpc: String,
    result: Option<serde_json::Value>,
    error: Option<JsonRpcError>,
    id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcError {
    code: i32,
    message: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcNotification {
    jsonrpc: String,
    method: String,
    params: serde_json::Value,
}

pub struct PythonSidecar {
    child: Option<CommandChild>,
    request_id: Arc<Mutex<u64>>,
    pending: Arc<Mutex<HashMap<u64, oneshot::Sender<Result<serde_json::Value, String>>>>>,
    notification_tx: Option<mpsc::UnboundedSender<JsonRpcNotification>>,
}

impl PythonSidecar {
    pub fn new() -> Self {
        Self {
            child: None,
            request_id: Arc::new(Mutex::new(0)),
            pending: Arc::new(Mutex::new(HashMap::new())),
            notification_tx: None,
        }
    }

    pub async fn start(
        &mut self,
        notification_tx: mpsc::UnboundedSender<JsonRpcNotification>,
    ) -> Result<(), String> {
        self.notification_tx = Some(notification_tx);

        let (mut rx, child) = Command::new_sidecar("python-sidecar")
            .map_err(|e| format!("Failed to create sidecar command: {}", e))?
            .spawn()
            .map_err(|e| format!("Failed to spawn sidecar: {}", e))?;

        self.child = Some(child);
        let pending = Arc::clone(&self.pending);
        let notification_tx = self.notification_tx.clone();

        // å¤„ç† Sidecar è¾“å‡º
        tokio::spawn(async move {
            while let Some(event) = rx.recv().await {
                match event {
                    CommandEvent::Stdout(line) => {
                        // å°è¯•è§£æä¸ºå“åº”
                        if let Ok(response) = serde_json::from_str::<JsonRpcResponse>(&line) {
                            let mut pending_guard = pending.lock().await;
                            if let Some(tx) = pending_guard.remove(&response.id) {
                                let result = if let Some(error) = response.error {
                                    Err(error.message)
                                } else {
                                    Ok(response.result.unwrap_or(serde_json::Value::Null))
                                };
                                let _ = tx.send(result);
                            }
                        }
                        // å°è¯•è§£æä¸ºé€šçŸ¥
                        else if let Ok(notification) = serde_json::from_str::<JsonRpcNotification>(&line) {
                            if let Some(tx) = &notification_tx {
                                let _ = tx.send(notification);
                            }
                        }
                    }
                    CommandEvent::Stderr(line) => {
                        warn!("Python stderr: {}", line);
                    }
                    CommandEvent::Error(error) => {
                        error!("Sidecar error: {}", error);
                    }
                    CommandEvent::Terminated(payload) => {
                        info!("Sidecar terminated: {:?}", payload);
                        break;
                    }
                    _ => {}
                }
            }
        });

        info!("Python Sidecar started");
        Ok(())
    }

    pub async fn call(
        &self,
        method: &str,
        params: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        let child = self.child.as_ref().ok_or("Sidecar not started")?;

        // ç”Ÿæˆè¯·æ±‚ ID
        let request_id = {
            let mut id = self.request_id.lock().await;
            *id += 1;
            *id
        };

        let request = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: method.to_string(),
            params,
            id: request_id,
        };

        // åˆ›å»ºå“åº”é€šé“
        let (tx, rx) = oneshot::channel();
        {
            let mut pending = self.pending.lock().await;
            pending.insert(request_id, tx);
        }

        // å‘é€è¯·æ±‚
        let request_str = serde_json::to_string(&request)
            .map_err(|e| format!("Failed to serialize request: {}", e))?;

        child.write((request_str + "\n").as_bytes())
            .map_err(|e| format!("Failed to write to sidecar: {}", e))?;

        // ç­‰å¾…å“åº”
        rx.await.map_err(|_| "Response channel closed".to_string())?
    }

    pub async fn stop(&mut self) -> Result<(), String> {
        if let Some(child) = self.child.take() {
            child.kill().map_err(|e| format!("Failed to kill sidecar: {}", e))?;
        }
        info!("Python Sidecar stopped");
        Ok(())
    }
}
```

### 5.2 Tauri å‘½ä»¤

```rust
// src-tauri/src/commands/agent.rs
use tauri::State;
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::sidecar::PythonSidecar;

/// æ‰§è¡Œ Agent Graph
#[tauri::command]
pub async fn execute_agent_graph(
    state: State<'_, Arc<Mutex<PythonSidecar>>>,
    graph_name: String,
    inputs: serde_json::Value,
    user_id: String,
    config: Option<serde_json::Value>,
) -> Result<serde_json::Value, String> {
    let sidecar = state.lock().await;
    sidecar.call("agent.execute_graph", serde_json::json!({
        "graph_name": graph_name,
        "inputs": inputs,
        "user_id": user_id,
        "config": config
    })).await
}

/// åˆ›å»ºæ–‡ç« 
#[tauri::command]
pub async fn create_article(
    state: State<'_, Arc<Mutex<PythonSidecar>>>,
    topic: String,
    style: String,
    platform: String,
) -> Result<serde_json::Value, String> {
    let sidecar = state.lock().await;
    sidecar.call("agent.execute_graph", serde_json::json!({
        "graph_name": "content_creation",
        "inputs": {
            "topic": topic,
            "style": style,
            "platform": platform
        },
        "user_id": "local_user",
        "config": {}
    })).await
}

/// åˆ›å»ºçˆ†æ¬¾å†…å®¹ï¼ˆä½¿ç”¨ BettaFishï¼‰
#[tauri::command]
pub async fn create_viral_content(
    state: State<'_, Arc<Mutex<PythonSidecar>>>,
    niche: String,
    platform: String,
    content_type: String,
) -> Result<serde_json::Value, String> {
    let sidecar = state.lock().await;
    sidecar.call("agent.execute_graph", serde_json::json!({
        "graph_name": "viral_content",
        "inputs": {
            "niche": niche,
            "target_platform": platform,
            "content_type": content_type
        },
        "user_id": "local_user",
        "config": {}
    })).await
}

/// å‘å¸ƒå†…å®¹
#[tauri::command]
pub async fn publish_content(
    state: State<'_, Arc<Mutex<PythonSidecar>>>,
    platform: String,
    content: serde_json::Value,
) -> Result<serde_json::Value, String> {
    let sidecar = state.lock().await;
    sidecar.call(&format!("platform.{}.publish", platform), content).await
}

/// å®šæ—¶å‘å¸ƒ
#[tauri::command]
pub async fn schedule_publish(
    state: State<'_, Arc<Mutex<PythonSidecar>>>,
    task_id: String,
    platform: String,
    content: serde_json::Value,
    schedule_time: String,
) -> Result<serde_json::Value, String> {
    let sidecar = state.lock().await;
    sidecar.call("scheduler.add_publish", serde_json::json!({
        "task_id": task_id,
        "platform": platform,
        "content": content,
        "schedule_time": schedule_time
    })).await
}

/// è·å–çƒ­ç‚¹è¯é¢˜ï¼ˆBettaFishï¼‰
#[tauri::command]
pub async fn get_hot_topics(
    state: State<'_, Arc<Mutex<PythonSidecar>>>,
    platform: String,
    category: Option<String>,
    limit: Option<i32>,
) -> Result<serde_json::Value, String> {
    let sidecar = state.lock().await;
    sidecar.call("bettafish.hot_topic_discovery", serde_json::json!({
        "platform": platform,
        "category": category,
        "time_range": "24h",
        "limit": limit.unwrap_or(20)
    })).await
}
```

### 5.3 å‡­è¯ç®¡ç†

```rust
// src-tauri/src/storage/credential.rs
use keyring::Entry;
use serde::{Deserialize, Serialize};
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};
use base64::{engine::general_purpose::STANDARD as BASE64, Engine};
use rand::RngCore;

const SERVICE_NAME: &str = "ai-creator";

#[derive(Debug, Serialize, Deserialize)]
pub struct PlatformCredential {
    pub platform: String,
    pub account_id: String,
    pub cookies: Vec<CookieData>,
    pub storage_state: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CookieData {
    pub name: String,
    pub value: String,
    pub domain: String,
    pub path: String,
    pub expires: Option<f64>,
    pub http_only: bool,
    pub secure: bool,
}

pub struct CredentialManager {
    encryption_key: [u8; 32],
}

impl CredentialManager {
    pub fn new() -> Result<Self, String> {
        // ä»ç³»ç»Ÿå¯†é’¥ç¯è·å–æˆ–åˆ›å»ºä¸»å¯†é’¥
        let entry = Entry::new(SERVICE_NAME, "master_key")
            .map_err(|e| format!("Failed to access keyring: {}", e))?;

        let key = match entry.get_password() {
            Ok(key_b64) => {
                let key_bytes = BASE64.decode(&key_b64)
                    .map_err(|e| format!("Failed to decode key: {}", e))?;
                let mut key = [0u8; 32];
                key.copy_from_slice(&key_bytes);
                key
            }
            Err(_) => {
                // ç”Ÿæˆæ–°å¯†é’¥
                let mut key = [0u8; 32];
                OsRng.fill_bytes(&mut key);
                let key_b64 = BASE64.encode(&key);
                entry.set_password(&key_b64)
                    .map_err(|e| format!("Failed to store key: {}", e))?;
                key
            }
        };

        Ok(Self { encryption_key: key })
    }

    pub fn encrypt(&self, plaintext: &str) -> Result<String, String> {
        let cipher = Aes256Gcm::new_from_slice(&self.encryption_key)
            .map_err(|e| format!("Failed to create cipher: {}", e))?;

        let mut nonce_bytes = [0u8; 12];
        OsRng.fill_bytes(&mut nonce_bytes);
        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext = cipher.encrypt(nonce, plaintext.as_bytes())
            .map_err(|e| format!("Encryption failed: {}", e))?;

        // æ ¼å¼: base64(nonce || ciphertext)
        let mut combined = nonce_bytes.to_vec();
        combined.extend(ciphertext);
        Ok(BASE64.encode(&combined))
    }

    pub fn decrypt(&self, encrypted: &str) -> Result<String, String> {
        let combined = BASE64.decode(encrypted)
            .map_err(|e| format!("Failed to decode: {}", e))?;

        if combined.len() < 12 {
            return Err("Invalid encrypted data".to_string());
        }

        let (nonce_bytes, ciphertext) = combined.split_at(12);
        let nonce = Nonce::from_slice(nonce_bytes);

        let cipher = Aes256Gcm::new_from_slice(&self.encryption_key)
            .map_err(|e| format!("Failed to create cipher: {}", e))?;

        let plaintext = cipher.decrypt(nonce, ciphertext)
            .map_err(|e| format!("Decryption failed: {}", e))?;

        String::from_utf8(plaintext)
            .map_err(|e| format!("Invalid UTF-8: {}", e))
    }

    pub fn save_credential(&self, credential: &PlatformCredential) -> Result<(), String> {
        let json = serde_json::to_string(credential)
            .map_err(|e| format!("Failed to serialize: {}", e))?;

        let encrypted = self.encrypt(&json)?;

        let key = format!("{}_{}", credential.platform, credential.account_id);
        let entry = Entry::new(SERVICE_NAME, &key)
            .map_err(|e| format!("Failed to access keyring: {}", e))?;

        entry.set_password(&encrypted)
            .map_err(|e| format!("Failed to store credential: {}", e))
    }

    pub fn load_credential(
        &self,
        platform: &str,
        account_id: &str,
    ) -> Result<Option<PlatformCredential>, String> {
        let key = format!("{}_{}", platform, account_id);
        let entry = Entry::new(SERVICE_NAME, &key)
            .map_err(|e| format!("Failed to access keyring: {}", e))?;

        match entry.get_password() {
            Ok(encrypted) => {
                let json = self.decrypt(&encrypted)?;
                let credential = serde_json::from_str(&json)
                    .map_err(|e| format!("Failed to deserialize: {}", e))?;
                Ok(Some(credential))
            }
            Err(_) => Ok(None),
        }
    }

    pub fn delete_credential(&self, platform: &str, account_id: &str) -> Result<(), String> {
        let key = format!("{}_{}", platform, account_id);
        let entry = Entry::new(SERVICE_NAME, &key)
            .map_err(|e| format!("Failed to access keyring: {}", e))?;

        entry.delete_password()
            .map_err(|e| format!("Failed to delete credential: {}", e))
    }
}

// Tauri å‘½ä»¤
#[tauri::command]
pub fn save_platform_credential(
    credential: PlatformCredential,
) -> Result<(), String> {
    let manager = CredentialManager::new()?;
    manager.save_credential(&credential)
}

#[tauri::command]
pub fn load_platform_credential(
    platform: String,
    account_id: String,
) -> Result<Option<PlatformCredential>, String> {
    let manager = CredentialManager::new()?;
    manager.load_credential(&platform, &account_id)
}

#[tauri::command]
pub fn delete_platform_credential(
    platform: String,
    account_id: String,
) -> Result<(), String> {
    let manager = CredentialManager::new()?;
    manager.delete_credential(&platform, &account_id)
}
```

---

## 6. å‰ç«¯é›†æˆ

### 6.1 TypeScript å®¢æˆ·ç«¯

```typescript
// src/lib/sidecar-client.ts
import { invoke } from '@tauri-apps/api/core';
import { listen, UnlistenFn } from '@tauri-apps/api/event';

export interface AgentEvent {
  event_type: string;
  node_name: string;
  data: any;
}

export interface AgentResult<T = any> {
  success: boolean;
  data: T;
  error?: string;
  execution_time_ms: number;
}

export class SidecarClient {
  private eventListeners: Map<string, UnlistenFn> = new Map();

  /**
   * æ‰§è¡Œ Agent Graph
   */
  async executeGraph<T = any>(
    graphName: string,
    inputs: Record<string, any>,
    onEvent?: (event: AgentEvent) => void
  ): Promise<AgentResult<T>> {
    // ç›‘å¬äº‹ä»¶
    if (onEvent) {
      const unlisten = await listen<AgentEvent>('agent-event', (event) => {
        onEvent(event.payload);
      });
      this.eventListeners.set(graphName, unlisten);
    }

    try {
      const startTime = Date.now();
      const result = await invoke<T>('execute_agent_graph', {
        graphName,
        inputs,
        userId: 'local_user',
        config: {},
      });

      return {
        success: true,
        data: result,
        execution_time_ms: Date.now() - startTime,
      };
    } catch (error) {
      return {
        success: false,
        data: null as T,
        error: String(error),
        execution_time_ms: 0,
      };
    } finally {
      // æ¸…ç†äº‹ä»¶ç›‘å¬
      const unlisten = this.eventListeners.get(graphName);
      if (unlisten) {
        unlisten();
        this.eventListeners.delete(graphName);
      }
    }
  }

  /**
   * åˆ›å»ºæ–‡ç« 
   */
  async createArticle(topic: string, style: string, platform: string) {
    return invoke<{ content: string; images: string[] }>('create_article', {
      topic,
      style,
      platform,
    });
  }

  /**
   * åˆ›å»ºçˆ†æ¬¾å†…å®¹
   */
  async createViralContent(niche: string, platform: string, contentType: string) {
    return invoke('create_viral_content', {
      niche,
      platform,
      contentType,
    });
  }

  /**
   * è·å–çƒ­ç‚¹è¯é¢˜
   */
  async getHotTopics(platform: string, category?: string, limit?: number) {
    return invoke('get_hot_topics', {
      platform,
      category,
      limit,
    });
  }

  /**
   * å‘å¸ƒå†…å®¹
   */
  async publishContent(platform: string, content: any) {
    return invoke('publish_content', { platform, content });
  }

  /**
   * å®šæ—¶å‘å¸ƒ
   */
  async schedulePublish(
    platform: string,
    content: any,
    scheduleTime: Date
  ) {
    return invoke('schedule_publish', {
      taskId: crypto.randomUUID(),
      platform,
      content,
      scheduleTime: scheduleTime.toISOString(),
    });
  }
}

export const sidecarClient = new SidecarClient();
```

### 6.2 React Hooks

```typescript
// src/hooks/useAgent.ts
import { useState, useCallback } from 'react';
import { sidecarClient, AgentEvent, AgentResult } from '@/lib/sidecar-client';

export function useAgent<T = any>(graphName: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [data, setData] = useState<T | null>(null);
  const [events, setEvents] = useState<AgentEvent[]>([]);

  const execute = useCallback(async (inputs: Record<string, any>) => {
    setLoading(true);
    setError(null);
    setEvents([]);

    const result = await sidecarClient.executeGraph<T>(
      graphName,
      inputs,
      (event) => {
        setEvents((prev) => [...prev, event]);
      }
    );

    setLoading(false);

    if (result.success) {
      setData(result.data);
    } else {
      setError(result.error || 'Unknown error');
    }

    return result;
  }, [graphName]);

  return { execute, loading, error, data, events };
}

// src/hooks/useHotTopics.ts
import { useState, useCallback } from 'react';
import { sidecarClient } from '@/lib/sidecar-client';

export interface HotTopic {
  topic: string;
  heat_score: number;
  trend: 'rising' | 'stable' | 'declining';
  sentiment: {
    positive: number;
    neutral: number;
    negative: number;
  };
  platforms: string[];
}

export function useHotTopics() {
  const [loading, setLoading] = useState(false);
  const [topics, setTopics] = useState<HotTopic[]>([]);
  const [error, setError] = useState<string | null>(null);

  const fetchTopics = useCallback(async (
    platform: string = 'all',
    category?: string,
    limit: number = 20
  ) => {
    setLoading(true);
    setError(null);

    try {
      const result = await sidecarClient.getHotTopics(platform, category, limit);
      setTopics(result.topics);
    } catch (err) {
      setError(String(err));
    } finally {
      setLoading(false);
    }
  }, []);

  return { fetchTopics, loading, topics, error };
}
```

### 6.3 ä½¿ç”¨ç¤ºä¾‹

```tsx
// src/pages/ContentCreation.tsx
import { useAgent } from '@/hooks/useAgent';
import { useHotTopics } from '@/hooks/useHotTopics';

function ContentCreation() {
  const { execute, loading, data, events } = useAgent('viral_content');
  const { fetchTopics, topics, loading: topicsLoading } = useHotTopics();

  // è·å–çƒ­ç‚¹
  const handleFetchHotTopics = async () => {
    await fetchTopics('xiaohongshu', 'ç¾å¦†', 10);
  };

  // åˆ›å»ºçˆ†æ¬¾å†…å®¹
  const handleCreateContent = async (topic: string) => {
    const result = await execute({
      niche: 'ç¾å¦†',
      target_platform: 'xiaohongshu',
      content_type: 'note',
      selected_topic: topic,
    });

    if (result.success) {
      console.log('åˆ›å»ºæˆåŠŸ:', result.data);
    }
  };

  return (
    <div className="content-creation">
      <section className="hot-topics">
        <h2>çƒ­ç‚¹è¯é¢˜</h2>
        <button onClick={handleFetchHotTopics} disabled={topicsLoading}>
          {topicsLoading ? 'åŠ è½½ä¸­...' : 'è·å–çƒ­ç‚¹'}
        </button>
        <ul>
          {topics.map((topic) => (
            <li key={topic.topic}>
              <span>{topic.topic}</span>
              <span>çƒ­åº¦: {topic.heat_score}</span>
              <button onClick={() => handleCreateContent(topic.topic)}>
                åˆ›ä½œ
              </button>
            </li>
          ))}
        </ul>
      </section>

      <section className="creation-progress">
        <h2>åˆ›ä½œè¿›åº¦</h2>
        {loading && (
          <div className="events">
            {events.map((event, i) => (
              <div key={i} className="event">
                <span className="node">{event.node_name}</span>
                <span className="type">{event.event_type}</span>
              </div>
            ))}
          </div>
        )}
        {data && (
          <div className="result">
            <h3>åˆ›ä½œå®Œæˆ</h3>
            <pre>{JSON.stringify(data, null, 2)}</pre>
          </div>
        )}
      </section>
    </div>
  );
}
```

---

## 7. æœ¬åœ°å­˜å‚¨

### 7.1 SQLite æ•°æ®åº“

æ¡Œé¢ç«¯ä½¿ç”¨ SQLite å­˜å‚¨æœ¬åœ°æ•°æ®ï¼š

```sql
-- è‰ç¨¿è¡¨
CREATE TABLE drafts (
    id TEXT PRIMARY KEY,
    title TEXT,
    content TEXT,
    platform TEXT,
    status TEXT DEFAULT 'draft',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- å‘å¸ƒå†å²
CREATE TABLE publish_history (
    id TEXT PRIMARY KEY,
    draft_id TEXT,
    platform TEXT,
    account_id TEXT,
    post_id TEXT,
    post_url TEXT,
    status TEXT,
    published_at DATETIME,
    FOREIGN KEY (draft_id) REFERENCES drafts(id)
);

-- æ•°æ®é‡‡é›†è®°å½•
CREATE TABLE analytics_records (
    id TEXT PRIMARY KEY,
    platform TEXT,
    post_id TEXT,
    views INTEGER,
    likes INTEGER,
    comments INTEGER,
    shares INTEGER,
    collected_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- å®šæ—¶ä»»åŠ¡
CREATE TABLE scheduled_tasks (
    id TEXT PRIMARY KEY,
    task_type TEXT,
    params TEXT,
    trigger_type TEXT,
    trigger_config TEXT,
    status TEXT DEFAULT 'active',
    next_run DATETIME,
    last_run DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- è´¦å·ä¿¡æ¯ï¼ˆä»…å­˜å‚¨å…ƒæ•°æ®ï¼Œå‡­è¯åœ¨ Keychainï¼‰
CREATE TABLE accounts (
    id TEXT PRIMARY KEY,
    platform TEXT,
    account_name TEXT,
    avatar_url TEXT,
    status TEXT DEFAULT 'active',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_used_at DATETIME
);
```

### 7.2 æ•°æ®åŒæ­¥ï¼ˆå¯é€‰ï¼‰

```typescript
// src/lib/data-sync.ts

/**
 * æ¡Œé¢ç«¯æ•°æ®åŒæ­¥æ˜¯å¯é€‰çš„
 * ç”¨æˆ·å¯ä»¥é€‰æ‹©å°†æ•°æ®åŒæ­¥åˆ°äº‘ç«¯ï¼Œä¹Ÿå¯ä»¥å®Œå…¨æœ¬åœ°ä½¿ç”¨
 */
export class DataSyncManager {
  private syncEnabled: boolean = false;

  async enableSync(userId: string, token: string) {
    this.syncEnabled = true;
    // é…ç½®åŒæ­¥...
  }

  async disableSync() {
    this.syncEnabled = false;
  }

  async syncDrafts() {
    if (!this.syncEnabled) return;
    // åŒæ­¥è‰ç¨¿åˆ°äº‘ç«¯...
  }

  async syncPublishHistory() {
    if (!this.syncEnabled) return;
    // åŒæ­¥å‘å¸ƒå†å²...
  }
}
```

---

## 8. æ‰“åŒ…ä¸åˆ†å‘

### 8.1 æ„å»ºé…ç½®

```json
// src-tauri/tauri.conf.json
{
  "build": {
    "beforeBuildCommand": "pnpm build",
    "beforeDevCommand": "pnpm dev",
    "frontendDist": "../dist",
    "devUrl": "http://localhost:5173"
  },
  "bundle": {
    "active": true,
    "targets": ["msi", "dmg", "deb", "appimage"],
    "identifier": "com.creatorflow.desktop",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "externalBin": ["python-sidecar"],
    "resources": ["graphs/*"]
  },
  "plugins": {
    "updater": {
      "active": true,
      "endpoints": ["https://releases.creatorflow.com/{{target}}/{{arch}}/{{current_version}}"],
      "pubkey": "..."
    }
  }
}
```

### 8.2 Python Sidecar æ‰“åŒ…

**æ‰“åŒ…ç­–ç•¥**: å†…åµŒå®Œæ•´ Python ç¯å¢ƒï¼Œä¸ä¾èµ–ç”¨æˆ·ç³»ç»Ÿ

```yaml
æ‰“åŒ…åŸåˆ™:
  - é›¶ä¾èµ–: ç”¨æˆ·æ— éœ€å®‰è£… Python
  - è·¨å¹³å°: åˆ†åˆ«ä¸º Windows/macOS/Linux æ‰“åŒ…
  - ä½“ç§¯ä¼˜åŒ–: ç²¾ç®€ä¸å¿…è¦çš„æ ‡å‡†åº“
  - å¯åŠ¨ä¼˜åŒ–: é¢„ç¼–è¯‘ .pyc æ–‡ä»¶

é¢„ä¼°ä½“ç§¯:
  - Python è¿è¡Œæ—¶: ~40MB (ç²¾ç®€å)
  - ä¾èµ–åŒ…: ~30-50MB (å« Playwright æµè§ˆå™¨é™¤å¤–)
  - Sidecar ä»£ç : ~5MB
  - æ€»è®¡: ~80-100MB (ä¸å«æµè§ˆå™¨)

æµè§ˆå™¨ç­–ç•¥:
  - Playwright æµè§ˆå™¨å•ç‹¬ä¸‹è½½ï¼ˆé¦–æ¬¡è¿è¡Œæ—¶ï¼‰
  - æˆ–é¢„ç½® Chromium (~150MB)
```

**æ–¹æ¡ˆä¸€: PyInstaller (æ¨è)**

```bash
# ä½¿ç”¨ PyInstaller æ‰“åŒ… Python Sidecar
cd apps/sidecar

# ç”Ÿæˆ spec æ–‡ä»¶å¹¶è‡ªå®šä¹‰
pyinstaller --name python-sidecar \
  --onedir \
  --add-data "../../agent-definitions:agent-definitions" \
  --hidden-import playwright \
  --hidden-import apscheduler \
  --hidden-import anthropic \
  --hidden-import langgraph \
  --collect-all agent_core \
  --exclude-module tkinter \
  --exclude-module test \
  src/sidecar/main.py

# è¾“å‡ºç›®å½•: dist/python-sidecar/
```

**æ–¹æ¡ˆäºŒ: Nuitka (æ›´å¥½æ€§èƒ½)**

```bash
# ä½¿ç”¨ Nuitka ç¼–è¯‘ä¸ºåŸç”Ÿä»£ç 
cd apps/sidecar
nuitka --standalone \
  --onefile \
  --output-filename=python-sidecar \
  --include-package=agent_core \
  --include-package=playwright \
  --include-package=apscheduler \
  --include-package=anthropic \
  --include-data-dir=../../agent-definitions=agent-definitions \
  --remove-output \
  src/sidecar/main.py

# Nuitka ä¼˜åŠ¿: å¯åŠ¨æ›´å¿«ï¼Œä½“ç§¯æ›´å°ï¼Œä»£ç ä¿æŠ¤
```

**æ–¹æ¡ˆä¸‰: PyOxidizer (Rust é›†æˆ)**

```toml
# pyoxidizer.bzl - ä¸ Tauri Rust åç«¯æ›´å¥½é›†æˆ
[[embedded_python_config]]
raw_allocator = "system"

[[packaging_rule]]
type = "stdlib-extensions-policy"
policy = "minimal"

[[packaging_rule]]
type = "pip-install-simple"
package = "agent-core"
```

**å¹³å°ç‰¹å®šæ‰“åŒ…è„šæœ¬**:

```bash
# scripts/build-sidecar.sh

#!/bin/bash
set -e

PLATFORM=$(uname -s | tr '[:upper:]' '[:lower:]')
ARCH=$(uname -m)

case $PLATFORM in
  darwin)
    # macOS: æ”¯æŒ x64 å’Œ arm64
    pyinstaller --target-arch universal2 ...
    ;;
  linux)
    # Linux: AppImage æˆ–ç›´æ¥äºŒè¿›åˆ¶
    pyinstaller --strip ...
    ;;
  mingw*|cygwin*|msys*)
    # Windows: ä½¿ç”¨ MSVC ç¼–è¯‘
    pyinstaller --windowed ...
    ;;
esac

# å¤åˆ¶åˆ° Tauri sidecar ç›®å½•
cp -r dist/python-sidecar/* ../tauri-app/src-tauri/sidecar/
```

### 8.3 å¹³å°ç‰¹å®šé…ç½®

```toml
# src-tauri/Cargo.toml

[target.'cfg(target_os = "macos")'.dependencies]
keyring = { version = "2", features = ["apple-native"] }

[target.'cfg(target_os = "windows")'.dependencies]
keyring = { version = "2", features = ["windows-native"] }

[target.'cfg(target_os = "linux")'.dependencies]
keyring = { version = "2", features = ["linux-native"] }
```

---

## 9. LLM ç®¡ç†æ¨¡å—

### 9.1 æ¨¡å—æ¦‚è¿°

æ¡Œé¢ç«¯ LLM ç®¡ç†æ¨¡å—æä¾›æœ¬åœ°åŒ–çš„å¤§è¯­è¨€æ¨¡å‹ç®¡ç†èƒ½åŠ›ï¼Œæ”¯æŒå¤šä¾›åº”å•†ã€å¤šæ¨¡å‹çš„ç»Ÿä¸€ç®¡ç†å’Œè°ƒç”¨ã€‚

```yaml
æ ¸å¿ƒåŠŸèƒ½:
  - ä¾›åº”å•†ç®¡ç†: é…ç½®å¤šä¸ª LLM ä¾›åº”å•†ï¼ˆOpenAIã€Claudeã€å›½å†…å‚å•†ç­‰ï¼‰
  - æ¨¡å‹é…ç½®: ç®¡ç†å„ä¾›åº”å•†çš„æ¨¡å‹å‚æ•°ã€æˆæœ¬ã€èƒ½åŠ›
  - æ¨¡å‹ç»„: å°†å¤šä¸ªæ¨¡å‹ç»„åˆï¼Œæ”¯æŒæ•…éšœè½¬ç§»å’Œè´Ÿè½½å‡è¡¡
  - é€Ÿç‡é™åˆ¶: é…ç½® Token ç”¨é‡é™åˆ¶ã€è¯·æ±‚é¢‘ç‡é™åˆ¶
  - API Key ç®¡ç†: æœ¬åœ°åŠ å¯†å­˜å‚¨ API Key
  - ç”¨é‡ç»Ÿè®¡: è¿½è¸ª Token æ¶ˆè€—ã€æˆæœ¬ç»Ÿè®¡
  - LLM ç½‘å…³: ç»Ÿä¸€çš„æ¨¡å‹è°ƒç”¨å…¥å£ï¼Œæ”¯æŒç†”æ–­ã€é‡è¯•

è®¾è®¡åŸåˆ™:
  - æœ¬åœ°ä¼˜å…ˆ: æ‰€æœ‰é…ç½®å’Œ API Key æœ¬åœ°åŠ å¯†å­˜å‚¨
  - éšç§ä¿æŠ¤: API Key ä¸ä¸Šä¼ äº‘ç«¯
  - æˆæœ¬å¯æ§: å®æ—¶ç”¨é‡ç»Ÿè®¡å’Œé¢„ç®—å‘Šè­¦
  - é«˜å¯ç”¨: æ¨¡å‹ç»„æ”¯æŒæ•…éšœè½¬ç§»
```

### 9.2 æ•°æ®æ¨¡å‹

```python
# python-sidecar/src/llm/models.py
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum
from datetime import datetime

class ModelType(str, Enum):
    """æ¨¡å‹ç±»å‹"""
    TEXT = "TEXT"           # æ–‡æœ¬ç”Ÿæˆ
    REASONING = "REASONING" # æ¨ç†
    VISION = "VISION"       # è§†è§‰
    IMAGE = "IMAGE"         # å›¾åƒç”Ÿæˆ
    VIDEO = "VIDEO"         # è§†é¢‘ç”Ÿæˆ
    EMBEDDING = "EMBEDDING" # åµŒå…¥
    TTS = "TTS"             # è¯­éŸ³åˆæˆ
    STT = "STT"             # è¯­éŸ³è¯†åˆ«

@dataclass
class LlmProvider:
    """LLM ä¾›åº”å•†"""
    id: str
    name: str
    api_base_url: Optional[str] = None
    api_key_encrypted: Optional[str] = None  # åŠ å¯†å­˜å‚¨
    global_rpm_limit: int = 60
    global_tpm_limit: int = 100000
    enabled: bool = True
    is_domestic: bool = False
    description: Optional[str] = None

@dataclass
class LlmModelConfig:
    """æ¨¡å‹é…ç½®"""
    id: str
    provider_id: str
    model_name: str
    display_name: Optional[str] = None
    model_type: ModelType = ModelType.TEXT
    max_tokens: int = 4096
    max_context_length: int = 8192
    supports_streaming: bool = True
    supports_tools: bool = False
    supports_vision: bool = False
    input_cost_per_1k: float = 0.0
    output_cost_per_1k: float = 0.0
    rpm_limit: Optional[int] = None
    tpm_limit: Optional[int] = None
    priority: int = 0
    enabled: bool = True

@dataclass
class LlmModelGroup:
    """æ¨¡å‹ç»„"""
    id: str
    name: str
    model_type: ModelType
    model_ids: list[str] = field(default_factory=list)
    fallback_enabled: bool = True
    retry_count: int = 3
    timeout_seconds: int = 60
    enabled: bool = True
    description: Optional[str] = None

@dataclass
class LlmRateLimitConfig:
    """é€Ÿç‡é™åˆ¶é…ç½®"""
    id: str
    name: str
    daily_token_limit: int = 100000
    weekly_token_limit: Optional[int] = None
    monthly_token_limit: int = 1000000
    rpm_limit: int = 60
    tpm_limit: int = 100000
    enabled: bool = True
    description: Optional[str] = None

@dataclass
class LlmUsageLog:
    """ç”¨é‡æ—¥å¿—"""
    id: str
    model_name: str
    input_tokens: int
    output_tokens: int
    total_tokens: int
    total_cost: float
    latency_ms: int
    status: str  # success | error
    is_streaming: bool
    created_time: datetime
```

### 9.3 LLM ç½‘å…³

```python
# python-sidecar/src/llm/gateway.py
from typing import AsyncIterator, Optional
from dataclasses import dataclass
import asyncio
import time
from loguru import logger

from .models import LlmProvider, LlmModelConfig, LlmModelGroup
from .rate_limiter import RateLimiter
from .usage_tracker import UsageTracker
from ..storage.credential import CredentialManager

@dataclass
class LlmRequest:
    """LLM è¯·æ±‚"""
    model: str
    messages: list[dict]
    temperature: float = 0.7
    max_tokens: Optional[int] = None
    stream: bool = False
    tools: Optional[list[dict]] = None

@dataclass
class LlmResponse:
    """LLM å“åº”"""
    content: str
    model: str
    input_tokens: int
    output_tokens: int
    total_tokens: int
    latency_ms: int
    cost: float

class LlmGateway:
    """LLM ç»Ÿä¸€ç½‘å…³"""

    def __init__(
        self,
        credential_manager: CredentialManager,
        rate_limiter: RateLimiter,
        usage_tracker: UsageTracker,
    ):
        self.credential_manager = credential_manager
        self.rate_limiter = rate_limiter
        self.usage_tracker = usage_tracker
        self._providers: dict[str, LlmProvider] = {}
        self._models: dict[str, LlmModelConfig] = {}
        self._groups: dict[str, LlmModelGroup] = {}

    def register_provider(self, provider: LlmProvider):
        """æ³¨å†Œä¾›åº”å•†"""
        self._providers[provider.id] = provider

    def register_model(self, model: LlmModelConfig):
        """æ³¨å†Œæ¨¡å‹"""
        self._models[model.id] = model

    def register_group(self, group: LlmModelGroup):
        """æ³¨å†Œæ¨¡å‹ç»„"""
        self._groups[group.id] = group

    async def chat(self, request: LlmRequest) -> LlmResponse:
        """å‘é€èŠå¤©è¯·æ±‚"""
        start_time = time.time()

        # è§£ææ¨¡å‹ï¼ˆå¯èƒ½æ˜¯æ¨¡å‹åæˆ–æ¨¡å‹ç»„åï¼‰
        model_config = self._resolve_model(request.model)
        if not model_config:
            raise ValueError(f"Model not found: {request.model}")

        # æ£€æŸ¥é€Ÿç‡é™åˆ¶
        await self.rate_limiter.check(model_config.id)

        # è·å–ä¾›åº”å•†å’Œ API Key
        provider = self._providers.get(model_config.provider_id)
        if not provider:
            raise ValueError(f"Provider not found: {model_config.provider_id}")

        api_key = self.credential_manager.decrypt(provider.api_key_encrypted)

        # è°ƒç”¨ LLM
        try:
            response = await self._call_llm(
                provider=provider,
                model=model_config,
                request=request,
                api_key=api_key,
            )

            latency_ms = int((time.time() - start_time) * 1000)

            # è®¡ç®—æˆæœ¬
            cost = self._calculate_cost(
                model_config,
                response.input_tokens,
                response.output_tokens,
            )

            # è®°å½•ç”¨é‡
            await self.usage_tracker.log(
                model_name=model_config.model_name,
                input_tokens=response.input_tokens,
                output_tokens=response.output_tokens,
                cost=cost,
                latency_ms=latency_ms,
                status="success",
            )

            return LlmResponse(
                content=response.content,
                model=model_config.model_name,
                input_tokens=response.input_tokens,
                output_tokens=response.output_tokens,
                total_tokens=response.input_tokens + response.output_tokens,
                latency_ms=latency_ms,
                cost=cost,
            )

        except Exception as e:
            latency_ms = int((time.time() - start_time) * 1000)
            await self.usage_tracker.log(
                model_name=model_config.model_name,
                input_tokens=0,
                output_tokens=0,
                cost=0,
                latency_ms=latency_ms,
                status="error",
                error=str(e),
            )
            raise

    async def chat_stream(
        self, request: LlmRequest
    ) -> AsyncIterator[str]:
        """æµå¼èŠå¤©"""
        request.stream = True
        model_config = self._resolve_model(request.model)
        provider = self._providers.get(model_config.provider_id)
        api_key = self.credential_manager.decrypt(provider.api_key_encrypted)

        async for chunk in self._call_llm_stream(
            provider=provider,
            model=model_config,
            request=request,
            api_key=api_key,
        ):
            yield chunk

    def _resolve_model(self, model_name: str) -> Optional[LlmModelConfig]:
        """è§£ææ¨¡å‹åç§°"""
        # å…ˆæŸ¥æ‰¾æ¨¡å‹ç»„
        if model_name in self._groups:
            group = self._groups[model_name]
            if group.enabled and group.model_ids:
                # è¿”å›ä¼˜å…ˆçº§æœ€é«˜çš„å¯ç”¨æ¨¡å‹
                for model_id in group.model_ids:
                    model = self._models.get(model_id)
                    if model and model.enabled:
                        return model

        # ç›´æ¥æŸ¥æ‰¾æ¨¡å‹
        for model in self._models.values():
            if model.model_name == model_name and model.enabled:
                return model

        return None

    def _calculate_cost(
        self,
        model: LlmModelConfig,
        input_tokens: int,
        output_tokens: int,
    ) -> float:
        """è®¡ç®—æˆæœ¬"""
        input_cost = (input_tokens / 1000) * model.input_cost_per_1k
        output_cost = (output_tokens / 1000) * model.output_cost_per_1k
        return input_cost + output_cost

    async def _call_llm(
        self,
        provider: LlmProvider,
        model: LlmModelConfig,
        request: LlmRequest,
        api_key: str,
    ):
        """è°ƒç”¨ LLM APIï¼ˆæ ¹æ®ä¾›åº”å•†é€‰æ‹©ä¸åŒçš„å®¢æˆ·ç«¯ï¼‰"""
        # å®ç°å…·ä½“çš„ API è°ƒç”¨é€»è¾‘
        pass

    async def _call_llm_stream(
        self,
        provider: LlmProvider,
        model: LlmModelConfig,
        request: LlmRequest,
        api_key: str,
    ) -> AsyncIterator[str]:
        """æµå¼è°ƒç”¨ LLM API"""
        # å®ç°å…·ä½“çš„æµå¼ API è°ƒç”¨é€»è¾‘
        pass
```

### 9.4 RPC æ¥å£

```python
# python-sidecar/src/llm/rpc.py
from ..server import server
from .gateway import LlmGateway, LlmRequest
from .models import LlmProvider, LlmModelConfig, LlmModelGroup

# å…¨å±€ç½‘å…³å®ä¾‹
gateway: LlmGateway = None

@server.register("llm.chat")
async def llm_chat(
    model: str,
    messages: list[dict],
    temperature: float = 0.7,
    max_tokens: int | None = None,
    stream: bool = False,
) -> dict:
    """LLM èŠå¤©"""
    request = LlmRequest(
        model=model,
        messages=messages,
        temperature=temperature,
        max_tokens=max_tokens,
        stream=stream,
    )
    response = await gateway.chat(request)
    return {
        "content": response.content,
        "model": response.model,
        "input_tokens": response.input_tokens,
        "output_tokens": response.output_tokens,
        "total_tokens": response.total_tokens,
        "latency_ms": response.latency_ms,
        "cost": response.cost,
    }

@server.register("llm.provider.list")
async def list_providers() -> list[dict]:
    """åˆ—å‡ºæ‰€æœ‰ä¾›åº”å•†"""
    return [
        {
            "id": p.id,
            "name": p.name,
            "api_base_url": p.api_base_url,
            "enabled": p.enabled,
            "is_domestic": p.is_domestic,
            "has_api_key": p.api_key_encrypted is not None,
        }
        for p in gateway._providers.values()
    ]

@server.register("llm.provider.add")
async def add_provider(
    name: str,
    api_base_url: str | None = None,
    api_key: str | None = None,
    is_domestic: bool = False,
) -> dict:
    """æ·»åŠ ä¾›åº”å•†"""
    # å®ç°æ·»åŠ é€»è¾‘
    pass

@server.register("llm.model.list")
async def list_models(provider_id: str | None = None) -> list[dict]:
    """åˆ—å‡ºæ¨¡å‹"""
    models = gateway._models.values()
    if provider_id:
        models = [m for m in models if m.provider_id == provider_id]
    return [
        {
            "id": m.id,
            "provider_id": m.provider_id,
            "model_name": m.model_name,
            "display_name": m.display_name,
            "model_type": m.model_type.value,
            "enabled": m.enabled,
        }
        for m in models
    ]

@server.register("llm.usage.summary")
async def get_usage_summary(days: int = 30) -> dict:
    """è·å–ç”¨é‡ç»Ÿè®¡"""
    return await gateway.usage_tracker.get_summary(days)

@server.register("llm.usage.daily")
async def get_daily_usage(days: int = 30) -> list[dict]:
    """è·å–æ¯æ—¥ç”¨é‡"""
    return await gateway.usage_tracker.get_daily_usage(days)
```

### 9.5 å‰ç«¯é›†æˆ

```typescript
// src/lib/llm-client.ts
import { invoke } from '@tauri-apps/api/core';

export interface LlmChatRequest {
  model: string;
  messages: Array<{ role: string; content: string }>;
  temperature?: number;
  maxTokens?: number;
  stream?: boolean;
}

export interface LlmChatResponse {
  content: string;
  model: string;
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
  latency_ms: number;
  cost: number;
}

export interface LlmProvider {
  id: string;
  name: string;
  api_base_url: string | null;
  enabled: boolean;
  is_domestic: boolean;
  has_api_key: boolean;
}

export interface LlmUsageSummary {
  total_requests: number;
  success_requests: number;
  error_requests: number;
  total_tokens: number;
  total_cost: number;
  avg_latency_ms: number;
}

export class LlmClient {
  /**
   * å‘é€èŠå¤©è¯·æ±‚
   */
  async chat(request: LlmChatRequest): Promise<LlmChatResponse> {
    return invoke('llm_chat', {
      model: request.model,
      messages: request.messages,
      temperature: request.temperature ?? 0.7,
      maxTokens: request.maxTokens,
      stream: request.stream ?? false,
    });
  }

  /**
   * è·å–ä¾›åº”å•†åˆ—è¡¨
   */
  async listProviders(): Promise<LlmProvider[]> {
    return invoke('llm_provider_list');
  }

  /**
   * æ·»åŠ ä¾›åº”å•†
   */
  async addProvider(
    name: string,
    apiBaseUrl?: string,
    apiKey?: string,
    isDomestic?: boolean
  ): Promise<{ id: string }> {
    return invoke('llm_provider_add', {
      name,
      apiBaseUrl,
      apiKey,
      isDomestic,
    });
  }

  /**
   * è·å–ç”¨é‡ç»Ÿè®¡
   */
  async getUsageSummary(days: number = 30): Promise<LlmUsageSummary> {
    return invoke('llm_usage_summary', { days });
  }

  /**
   * è·å–æ¯æ—¥ç”¨é‡
   */
  async getDailyUsage(days: number = 30): Promise<Array<{
    date: string;
    requests: number;
    tokens: number;
    cost: number;
  }>> {
    return invoke('llm_usage_daily', { days });
  }
}

export const llmClient = new LlmClient();
```

---

## ç›¸å…³æ–‡æ¡£

- [ç³»ç»Ÿæ¶æ„](./01-ç³»ç»Ÿæ¶æ„.md)
- [äº‘ç«¯æœåŠ¡è®¾è®¡](./04-äº‘ç«¯æœåŠ¡è®¾è®¡.md)
- [Agent Runtime](./05-Agent-Runtime.md)
- [å¹³å°é€‚é…å™¨](./06-å¹³å°é€‚é…å™¨.md)
- [BettaFish èˆ†æƒ…åˆ†æé›†æˆ](./08-BettaFishèˆ†æƒ…åˆ†æé›†æˆ.md)
