# AI Creator - 自媒体一体化AI客户端技术方案

> 版本: v1.1
> 日期: 2025-12-23
> 状态: 需求讨论阶段

---

## 目录

1. [产品概述](#1-产品概述)
2. [技术架构](#2-技术架构)
3. [端云统一架构](#3-端云统一架构)
4. [Python Sidecar设计](#4-python-sidecar设计)
5. [云端服务设计](#5-云端服务设计)
6. [平台适配器设计](#6-平台适配器设计)
7. [AI Agent工作流](#7-ai-agent工作流)
8. [数据模型设计](#8-数据模型设计)
9. [移动端方案](#9-移动端方案)
10. [商业模式](#10-商业模式)
11. [开发计划](#11-开发计划)
12. [风险与挑战](#12-风险与挑战)

---

## 1. 产品概述

### 1.1 产品愿景

**自媒体创作者的"超级大脑"** - 从灵感到变现的全链路AI助手

### 1.2 核心功能模块

| 模块 | 功能描述 |
|------|----------|
| **创作** | AI文章生成、图片生成、视频脚本、智能排版、自动配图 |
| **管理** | 素材库、想法库、知识库、作品管理 |
| **发布** | 多平台一键发布、定时发布、批量发布 |
| **运营** | 数据采集、数据分析、AI选题建议、趋势追踪 |

### 1.3 目标用户

- 个人自媒体创作者（初级→专业）
- MCN机构/团队
- 企业新媒体运营

### 1.4 核心差异化

- **AI Agent深度集成**: 通过Claude Agent SDK / LangGraph实现智能创作工作流
- **端侧重度运行**: 本地运行Agent，调用云端AI能力
- **浏览器自动化**: Playwright实现多平台自动发布
- **任务自动化**: 定时任务、批量操作全部本地执行

### 1.5 关键决策

| 决策项 | 结论 |
|--------|------|
| 目标市场 | 国内优先 |
| 视频能力 | 初期轻度辅助，后期AI剪辑 |
| 团队规模 | 20人 |
| 端侧AI | 不需要本地模型，调用云端API |
| 发布策略 | 官方API优先 → 浏览器自动化 → 逆向备选 |

---

## 2. 技术架构

### 2.1 技术栈选型

#### 2.1.1 客户端框架对比

| 方案 | Python集成 | 原生能力 | 跨平台 | 开发效率 | 包体积 |
|------|-----------|---------|--------|---------|--------|
| **Tauri 2.0 + Sidecar** ✅ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 桌面+移动 | ⭐⭐⭐ | 10-30MB |
| Electron + Python | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 桌面 | ⭐⭐⭐⭐ | 150MB+ |
| PyQt/PySide6 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 桌面 | ⭐⭐⭐ | 80MB+ |
| Flutter + Python服务 | ⭐⭐⭐ | ⭐⭐⭐⭐ | 全平台 | ⭐⭐⭐⭐ | 20MB+ |

**最终选择**: **Tauri 2.0 + Python Sidecar**

**选择理由**:
1. 原生能力强：Rust后端直接调用系统API
2. Python Sidecar：官方支持外部进程管理
3. 体积小：比Electron小10倍
4. Tauri 2.0支持移动端
5. 安全性：比Electron更安全的IPC模型

#### 2.1.2 后端技术栈

```yaml
API层:
  - Go: 高并发服务（发布调度、数据采集）
  - Node.js: BFF层（GraphQL聚合、实时通信）
  - Python: AI服务（LLM编排、图像/视频处理）

存储层:
  - PostgreSQL: 核心业务数据
  - MongoDB: 内容/素材文档
  - Redis: 缓存、队列、会话
  - MinIO/S3: 媒体文件存储
  - Meilisearch: 全文搜索

消息队列:
  - NATS/RabbitMQ: 任务调度、事件驱动

AI基础设施:
  - vLLM/Ollama: LLM推理（云端）
  - ComfyUI API: 图像生成
  - FFmpeg + AI: 视频处理
```

### 2.2 系统架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          客户端应用 (Tauri 2.0)                      │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                     前端 UI (React/Vue)                         │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │ │
│  │  │ 创作工作台│ │ 素材管理 │ │ 发布中心 │ │ 数据看板 │          │ │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘          │ │
│  └────────────────────────────┬───────────────────────────────────┘ │
│                               │ IPC (Tauri Commands)                │
│  ┌────────────────────────────┴───────────────────────────────────┐ │
│  │                     Rust Core (Tauri后端)                       │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │ │
│  │  │ 文件系统 │ │ 数据存储 │ │ 系统托盘 │ │ 进程管理 │          │ │
│  │  │ 操作     │ │ SQLite   │ │ 通知     │ │ Sidecar  │          │ │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘          │ │
│  └────────────────────────────┬───────────────────────────────────┘ │
│                               │ Sidecar IPC (JSON-RPC/gRPC)         │
│  ┌────────────────────────────┴───────────────────────────────────┐ │
│  │                  Python Runtime (Sidecar)                       │ │
│  │  ┌──────────────────────────────────────────────────────────┐  │ │
│  │  │                   AI Agent Engine                         │  │ │
│  │  │  ┌────────────┐ ┌────────────┐ ┌────────────┐            │  │ │
│  │  │  │Claude Agent│ │ LangGraph  │ │ 工作流引擎 │            │  │ │
│  │  │  │    SDK     │ │  Agents    │ │ (Temporal) │            │  │ │
│  │  │  └────────────┘ └────────────┘ └────────────┘            │  │ │
│  │  └──────────────────────────────────────────────────────────┘  │ │
│  │  ┌──────────────────────────────────────────────────────────┐  │ │
│  │  │                  自动化引擎                               │  │ │
│  │  │  ┌────────────┐ ┌────────────┐ ┌────────────┐            │  │ │
│  │  │  │ Playwright │ │ 定时任务   │ │ 平台适配器 │            │  │ │
│  │  │  │ 浏览器自动化│ │ APScheduler│ │ Adapters   │            │  │ │
│  │  │  └────────────┘ └────────────┘ └────────────┘            │  │ │
│  │  └──────────────────────────────────────────────────────────┘  │ │
│  │  ┌──────────────────────────────────────────────────────────┐  │ │
│  │  │                  内容处理引擎                             │  │ │
│  │  │  ┌────────────┐ ┌────────────┐ ┌────────────┐            │  │ │
│  │  │  │ 视频处理   │ │ 图片处理   │ │ 文档处理   │            │  │ │
│  │  │  │ MoviePy    │ │ Pillow     │ │ Markdown   │            │  │ │
│  │  │  └────────────┘ └────────────┘ └────────────┘            │  │ │
│  │  └──────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────┬──────────────────────────────────┘
                                   │ HTTPS API
┌──────────────────────────────────┴──────────────────────────────────┐
│                           云端服务                                   │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐               │
│  │ AI网关   │ │ 用户服务 │ │ 同步服务 │ │ 计费服务 │               │
│  │LLM/图像  │ │ 订阅管理 │ │ 数据同步 │ │ 算力计量 │               │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘               │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.3 进程通信架构

```
┌─────────────┐      IPC       ┌─────────────┐    JSON-RPC    ┌─────────────┐
│   WebView   │ ◄────────────► │  Rust Core  │ ◄────────────► │   Python    │
│  (前端UI)   │  Tauri Commands│  (主进程)    │   over stdio   │  (Sidecar)  │
└─────────────┘                └─────────────┘                └─────────────┘
                                     │
                                     │ 系统调用
                                     ▼
                              ┌─────────────┐
                              │   OS API    │
                              │ 文件/网络/  │
                              │ 通知/托盘   │
                              └─────────────┘
```

---

## 3. 端云统一架构

### 3.1 架构设计理念

**核心目标**: 实现端侧与云端能力的完全一致性，用户可以选择在本地执行任务（隐私优先），也可以在云端执行（便捷优先）。

**设计原则**:
1. **能力对等**: 云端与本地提供完全相同的功能接口
2. **凭证安全**: 端到端加密，云端无法解密用户凭证
3. **代码复用**: Agent核心逻辑共享，减少维护成本
4. **智能路由**: 根据设备能力自动选择最优执行环境

### 3.2 端云统一架构图

```text
┌──────────────────────────────────────────────────────────────────────────────────────────┐
│                                    客户端层                                               │
├──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                          │
│  ┌──────────────────────────────┐       ┌──────────────────────────────┐                │
│  │     桌面端 (Tauri 2.0)        │       │       移动端 (Tauri Mobile)   │                │
│  │  ┌────────────────────────┐  │       │  ┌────────────────────────┐  │                │
│  │  │     前端 UI (React)     │  │       │  │     前端 UI (React)     │  │                │
│  │  └───────────┬────────────┘  │       │  └───────────┬────────────┘  │                │
│  │              │ IPC            │       │              │ IPC            │                │
│  │  ┌───────────┴────────────┐  │       │  ┌───────────┴────────────┐  │                │
│  │  │      Rust Core         │  │       │  │      Rust Core         │  │                │
│  │  │  ┌──────┐ ┌──────────┐ │  │       │  │  ┌──────┐             │  │                │
│  │  │  │本地DB│ │Sidecar管理│ │  │       │  │  │本地DB│             │  │                │
│  │  │  └──────┘ └─────┬────┘ │  │       │  │  └──────┘             │  │                │
│  │  └─────────────────┼──────┘  │       │  └───────────────────────┘  │                │
│  │                    │         │       │                              │                │
│  │  ┌─────────────────┴──────┐  │       │         无Python环境          │                │
│  │  │   Python Sidecar       │  │       │         直接调用云端          │                │
│  │  │  ┌──────┐ ┌──────────┐ │  │       │                              │                │
│  │  │  │Agent │ │Playwright│ │  │       │                              │                │
│  │  │  │Engine│ │ Browser  │ │  │       │                              │                │
│  │  │  └──────┘ └──────────┘ │  │       │                              │                │
│  │  └────────────────────────┘  │       │                              │                │
│  └──────────────┬───────────────┘       └──────────────┬───────────────┘                │
│                 │                                       │                                │
│                 │ 可选：本地执行 或 云端执行              │ 仅云端执行                      │
│                 │                                       │                                │
└─────────────────┼───────────────────────────────────────┼────────────────────────────────┘
                  │                                       │
                  └───────────────────┬───────────────────┘
                                      │ HTTPS + E2E加密
                                      ▼
┌──────────────────────────────────────────────────────────────────────────────────────────┐
│                              云端服务 (fastapi_best_architecture)                          │
├──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              API Gateway (FastAPI)                                   │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐                  │ │
│  │  │ 认证鉴权 │ │ 限流熔断 │ │ 请求路由 │ │ 日志追踪 │ │ API版本 │                  │ │
│  │  │  JWT     │ │ Sentinel │ │ Router   │ │ Trace ID │ │ v1/v2... │                  │ │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘                  │ │
│  └─────────────────────────────────┬───────────────────────────────────────────────────┘ │
│                                    │                                                     │
│  ┌─────────────────────────────────┼───────────────────────────────────────────────────┐ │
│  │                          核心业务服务                                                 │ │
│  │                                 │                                                     │ │
│  │  ┌──────────────┐  ┌───────────┴──────────┐  ┌──────────────┐  ┌──────────────┐    │ │
│  │  │   用户服务    │  │     Agent服务        │  │   发布服务    │  │   同步服务    │    │ │
│  │  │  ┌────────┐  │  │  ┌────────────────┐  │  │  ┌────────┐  │  │  ┌────────┐  │    │ │
│  │  │  │ 认证   │  │  │  │  Agent Core    │  │  │  │ 任务调度│  │  │  │ 凭证同步│  │    │ │
│  │  │  │ 订阅   │  │  │  │  (共享代码)    │  │  │  │ 状态管理│  │  │  │ 配置同步│  │    │ │
│  │  │  │ 权限   │  │  │  └────────────────┘  │  │  │ 结果回调│  │  │  │ 数据同步│  │    │ │
│  │  │  └────────┘  │  │  ┌────────────────┐  │  │  └────────┘  │  │  └────────┘  │    │ │
│  │  └──────────────┘  │  │ 工作流引擎     │  │  └──────────────┘  └──────────────┘    │ │
│  │                    │  │ (LangGraph)    │  │                                        │ │
│  │                    │  └────────────────┘  │                                        │ │
│  │                    └──────────────────────┘                                        │ │
│  └────────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           浏览器自动化服务集群                                        │ │
│  │                                                                                     │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐   │ │
│  │  │                        浏览器池管理器 (Browser Pool Manager)                  │   │ │
│  │  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │   │ │
│  │  │  │ 实例调度     │  │ 健康检查     │  │ 负载均衡     │  │ 自动扩缩容   │    │   │ │
│  │  │  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │   │ │
│  │  └─────────────────────────────────┬───────────────────────────────────────────┘   │ │
│  │                                    │                                               │ │
│  │  ┌──────────────┬──────────────┬───┴───────┬──────────────┬──────────────┐        │ │
│  │  │ Worker Pod 1 │ Worker Pod 2 │ Worker 3  │ Worker Pod 4 │ Worker Pod N │        │ │
│  │  │ ┌──────────┐ │ ┌──────────┐ │┌────────┐ │ ┌──────────┐ │ ┌──────────┐ │        │ │
│  │  │ │Playwright│ │ │Playwright│ ││Playwr..│ │ │Playwright│ │ │Playwright│ │        │ │
│  │  │ │ Browser  │ │ │ Browser  │ ││Browser │ │ │ Browser  │ │ │ Browser  │ │        │ │
│  │  │ │ Instance │ │ │ Instance │ ││Instance│ │ │ Instance │ │ │ Instance │ │        │ │
│  │  │ └──────────┘ │ └──────────┘ │└────────┘ │ └──────────┘ │ └──────────┘ │        │ │
│  │  │  Chrome/FF   │  Chrome/FF   │ Chrome/FF │  Chrome/FF   │  Chrome/FF   │        │ │
│  │  └──────────────┴──────────────┴───────────┴──────────────┴──────────────┘        │ │
│  └─────────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              基础设施层                                              │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐    │ │
│  │  │PostgreSQL│ │  Redis   │ │  MinIO   │ │ Celery   │ │RabbitMQ  │ │Meilisearch│   │ │
│  │  │  主数据  │ │ 缓存/队列│ │ 媒体存储 │ │ 任务队列 │ │ 消息队列 │ │ 全文搜索 │    │ │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘    │ │
│  └─────────────────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Agent Runtime 抽象层

为实现端云代码复用，设计统一的 Agent Runtime 抽象层。

#### 3.3.1 核心接口定义

```python
# agent-core/src/interfaces.py
from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, Optional
from dataclasses import dataclass

class RuntimeType(Enum):
    """运行时类型"""
    LOCAL = "local"       # 本地 Python Sidecar
    CLOUD = "cloud"       # 云端服务
    HYBRID = "hybrid"     # 混合模式

@dataclass
class AgentRequest:
    """Agent请求"""
    method: str                    # agent.create_article, platform.xiaohongshu.publish
    params: dict                   # 请求参数
    user_id: str                   # 用户ID
    prefer_runtime: RuntimeType = RuntimeType.LOCAL  # 首选运行时
    timeout: int = 300             # 超时时间(秒)

@dataclass
class AgentResponse:
    """Agent响应"""
    success: bool
    data: Any
    error: Optional[str] = None
    runtime_used: RuntimeType = RuntimeType.LOCAL
    execution_time: float = 0.0

class StorageInterface(ABC):
    """存储接口"""

    @abstractmethod
    async def get(self, key: str) -> Optional[bytes]:
        """获取数据"""
        pass

    @abstractmethod
    async def set(self, key: str, value: bytes, ttl: Optional[int] = None):
        """设置数据"""
        pass

    @abstractmethod
    async def delete(self, key: str):
        """删除数据"""
        pass

class SecretsInterface(ABC):
    """凭证管理接口"""

    @abstractmethod
    async def get_credentials(self, platform: str, account_id: str) -> dict:
        """获取平台凭证（自动解密）"""
        pass

    @abstractmethod
    async def store_credentials(self, platform: str, account_id: str, credentials: dict):
        """存储平台凭证（自动加密）"""
        pass

    @abstractmethod
    async def get_api_key(self, service: str) -> str:
        """获取API密钥"""
        pass

class BrowserInterface(ABC):
    """浏览器接口"""

    @abstractmethod
    async def create_context(self, platform: str, account_id: str) -> "BrowserContext":
        """创建已认证的浏览器上下文"""
        pass

    @abstractmethod
    async def execute_task(self, context: "BrowserContext", task: dict) -> dict:
        """执行浏览器任务"""
        pass

    @abstractmethod
    async def close_context(self, context: "BrowserContext"):
        """关闭浏览器上下文"""
        pass

class RuntimeInterface(ABC):
    """运行时接口 - Agent执行的统一入口"""

    runtime_type: RuntimeType
    storage: StorageInterface
    secrets: SecretsInterface
    browser: BrowserInterface

    @abstractmethod
    async def execute_agent(self, request: AgentRequest) -> AgentResponse:
        """执行Agent"""
        pass

    @abstractmethod
    async def get_status(self) -> dict:
        """获取运行时状态"""
        pass
```

#### 3.3.2 Agent注册表

```python
# agent-core/src/registry.py
from typing import Callable, Dict, Type
from .interfaces import RuntimeInterface, AgentRequest, AgentResponse

class AgentRegistry:
    """Agent注册表 - 统一管理所有Agent"""

    _agents: Dict[str, Callable] = {}
    _workflows: Dict[str, Type] = {}

    @classmethod
    def register_agent(cls, method: str):
        """装饰器：注册Agent方法"""
        def decorator(func: Callable):
            cls._agents[method] = func
            return func
        return decorator

    @classmethod
    def register_workflow(cls, name: str):
        """装饰器：注册工作流"""
        def decorator(workflow_class: Type):
            cls._workflows[name] = workflow_class
            return workflow_class
        return decorator

    @classmethod
    async def execute(cls, runtime: RuntimeInterface, request: AgentRequest) -> AgentResponse:
        """执行Agent方法"""
        if request.method not in cls._agents:
            return AgentResponse(
                success=False,
                data=None,
                error=f"Unknown method: {request.method}"
            )

        agent_func = cls._agents[request.method]

        try:
            import time
            start = time.time()

            # 注入运行时依赖
            result = await agent_func(
                runtime=runtime,
                **request.params
            )

            return AgentResponse(
                success=True,
                data=result,
                runtime_used=runtime.runtime_type,
                execution_time=time.time() - start
            )
        except Exception as e:
            return AgentResponse(
                success=False,
                data=None,
                error=str(e),
                runtime_used=runtime.runtime_type
            )
```

#### 3.3.3 共享Agent实现示例

```python
# agent-core/src/agents/content_agent.py
from ..registry import AgentRegistry
from ..interfaces import RuntimeInterface

@AgentRegistry.register_agent("agent.create_article")
async def create_article(
    runtime: RuntimeInterface,
    topic: str,
    style: str,
    platform: str,
    **kwargs
) -> dict:
    """创建文章 - 端云共享实现"""

    # 获取API密钥（本地从配置读取，云端从云端配置读取）
    api_key = await runtime.secrets.get_api_key("anthropic")

    # 使用相同的Agent逻辑
    from anthropic import Anthropic
    client = Anthropic(api_key=api_key)

    # ... 创作逻辑 ...

    return {"content": "...", "success": True}

@AgentRegistry.register_agent("platform.publish")
async def publish_content(
    runtime: RuntimeInterface,
    platform: str,
    account_id: str,
    content: dict,
    **kwargs
) -> dict:
    """发布内容 - 端云共享实现"""

    # 获取平台凭证（本地从本地存储，云端从云端同步数据）
    credentials = await runtime.secrets.get_credentials(platform, account_id)

    # 创建浏览器上下文（本地用本地浏览器，云端用云端浏览器池）
    context = await runtime.browser.create_context(platform, account_id)

    try:
        # 执行发布任务
        result = await runtime.browser.execute_task(context, {
            "action": "publish",
            "platform": platform,
            "content": content
        })
        return result
    finally:
        await runtime.browser.close_context(context)
```

### 3.4 凭证加密同步机制

#### 3.4.1 加密架构

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                          凭证加密同步流程                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  桌面端登录                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. 用户在桌面端打开平台登录页面                                        │   │
│  │ 2. 用户手动完成登录（扫码/密码）                                       │   │
│  │ 3. 客户端捕获凭证：Cookies + LocalStorage + SessionStorage + 指纹      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      ▼                                      │
│  本地加密                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 4. 使用用户主密钥（User Master Key）进行AES-256-GCM加密               │   │
│  │ 5. 主密钥由用户密码派生（PBKDF2 + Salt）                              │   │
│  │ 6. 加密数据 = AES-GCM(凭证JSON, 主密钥, 随机IV)                       │   │
│  │ 7. 本地存储加密后的凭证                                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      ▼                                      │
│  云端同步（可选）                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 8. 用户选择开启云端同步                                                │   │
│  │ 9. 使用独立的同步密钥（Sync Key）再次加密                              │   │
│  │ 10. 同步密钥 = KDF(用户密码 + 设备ID + 时间戳)                         │   │
│  │ 11. 双重加密数据上传云端                                               │   │
│  │ 12. 云端只存储密文，无法解密                                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      ▼                                      │
│  移动端/云端使用                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 13. 移动端请求发布时，云端获取加密凭证                                  │   │
│  │ 14. 客户端提供同步密钥（不传输用户密码）                                │   │
│  │ 15. 云端解密获得可用凭证                                               │   │
│  │ 16. 凭证仅在内存中存在，用完即销毁                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3.4.2 凭证加密实现

```python
# agent-core/src/crypto/credential_crypto.py
import os
import json
import base64
import hashlib
from typing import Tuple
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from dataclasses import dataclass

@dataclass
class EncryptedCredential:
    """加密后的凭证"""
    ciphertext: bytes       # 加密数据
    iv: bytes               # 初始化向量
    salt: bytes             # 密钥派生盐值
    version: int = 1        # 加密版本

    def to_dict(self) -> dict:
        return {
            "ciphertext": base64.b64encode(self.ciphertext).decode(),
            "iv": base64.b64encode(self.iv).decode(),
            "salt": base64.b64encode(self.salt).decode(),
            "version": self.version
        }

    @classmethod
    def from_dict(cls, data: dict) -> "EncryptedCredential":
        return cls(
            ciphertext=base64.b64decode(data["ciphertext"]),
            iv=base64.b64decode(data["iv"]),
            salt=base64.b64decode(data["salt"]),
            version=data.get("version", 1)
        )

class CredentialCrypto:
    """凭证加密管理器"""

    KEY_LENGTH = 32  # AES-256
    IV_LENGTH = 12   # GCM推荐IV长度
    SALT_LENGTH = 32
    ITERATIONS = 600000  # PBKDF2迭代次数（OWASP推荐）

    @classmethod
    def derive_key(cls, password: str, salt: bytes) -> bytes:
        """从密码派生加密密钥"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=cls.KEY_LENGTH,
            salt=salt,
            iterations=cls.ITERATIONS,
        )
        return kdf.derive(password.encode())

    @classmethod
    def encrypt(cls, data: dict, password: str) -> EncryptedCredential:
        """加密凭证数据"""
        # 生成随机盐值和IV
        salt = os.urandom(cls.SALT_LENGTH)
        iv = os.urandom(cls.IV_LENGTH)

        # 派生密钥
        key = cls.derive_key(password, salt)

        # AES-GCM加密
        aesgcm = AESGCM(key)
        plaintext = json.dumps(data).encode()
        ciphertext = aesgcm.encrypt(iv, plaintext, None)

        return EncryptedCredential(
            ciphertext=ciphertext,
            iv=iv,
            salt=salt
        )

    @classmethod
    def decrypt(cls, encrypted: EncryptedCredential, password: str) -> dict:
        """解密凭证数据"""
        # 派生密钥
        key = cls.derive_key(password, encrypted.salt)

        # AES-GCM解密
        aesgcm = AESGCM(key)
        plaintext = aesgcm.decrypt(encrypted.iv, encrypted.ciphertext, None)

        return json.loads(plaintext.decode())

    @classmethod
    def derive_sync_key(cls, password: str, device_id: str, timestamp: int) -> str:
        """派生同步密钥（用于云端同步时的二次加密）"""
        # 组合多个因素
        combined = f"{password}:{device_id}:{timestamp}"

        # 使用SHA-256生成同步密钥
        sync_key = hashlib.sha256(combined.encode()).hexdigest()

        return sync_key

    @classmethod
    def encrypt_for_sync(
        cls,
        local_encrypted: EncryptedCredential,
        sync_key: str
    ) -> EncryptedCredential:
        """为云端同步进行二次加密"""
        # 将本地加密数据作为明文
        data = local_encrypted.to_dict()

        # 使用同步密钥再次加密
        salt = os.urandom(cls.SALT_LENGTH)
        iv = os.urandom(cls.IV_LENGTH)
        key = cls.derive_key(sync_key, salt)

        aesgcm = AESGCM(key)
        plaintext = json.dumps(data).encode()
        ciphertext = aesgcm.encrypt(iv, plaintext, None)

        return EncryptedCredential(
            ciphertext=ciphertext,
            iv=iv,
            salt=salt,
            version=2  # 双重加密版本
        )

    @classmethod
    def decrypt_from_sync(
        cls,
        sync_encrypted: EncryptedCredential,
        sync_key: str,
        user_password: str
    ) -> dict:
        """解密从云端同步的凭证"""
        # 第一层解密（同步密钥）
        key = cls.derive_key(sync_key, sync_encrypted.salt)
        aesgcm = AESGCM(key)
        plaintext = aesgcm.decrypt(sync_encrypted.iv, sync_encrypted.ciphertext, None)

        # 获取本地加密数据
        local_encrypted = EncryptedCredential.from_dict(json.loads(plaintext.decode()))

        # 第二层解密（用户密码）
        return cls.decrypt(local_encrypted, user_password)
```

#### 3.4.3 凭证同步服务

```python
# cloud-service/src/services/credential_sync_service.py
from datetime import datetime
from typing import Optional
from sqlmodel import Session
from ..models import EncryptedCredentialRecord
from ..schemas import CredentialSyncRequest, CredentialSyncResponse

class CredentialSyncService:
    """凭证同步服务 - 云端只存储双重加密数据"""

    def __init__(self, db: Session):
        self.db = db

    async def upload_credential(
        self,
        user_id: str,
        platform: str,
        account_id: str,
        encrypted_data: dict,  # 双重加密后的数据
        device_id: str
    ) -> CredentialSyncResponse:
        """上传加密凭证到云端"""

        # 验证数据格式
        if "ciphertext" not in encrypted_data:
            raise ValueError("Invalid encrypted data format")

        # 检查是否已存在
        existing = self.db.query(EncryptedCredentialRecord).filter(
            EncryptedCredentialRecord.user_id == user_id,
            EncryptedCredentialRecord.platform == platform,
            EncryptedCredentialRecord.account_id == account_id
        ).first()

        if existing:
            # 更新现有记录
            existing.encrypted_data = encrypted_data
            existing.last_updated_device = device_id
            existing.updated_at = datetime.utcnow()
        else:
            # 创建新记录
            record = EncryptedCredentialRecord(
                user_id=user_id,
                platform=platform,
                account_id=account_id,
                encrypted_data=encrypted_data,
                created_device=device_id,
                last_updated_device=device_id
            )
            self.db.add(record)

        self.db.commit()

        return CredentialSyncResponse(
            success=True,
            message="Credential synced successfully",
            synced_at=datetime.utcnow().isoformat()
        )

    async def download_credential(
        self,
        user_id: str,
        platform: str,
        account_id: str
    ) -> Optional[dict]:
        """下载加密凭证（仍然是加密状态）"""

        record = self.db.query(EncryptedCredentialRecord).filter(
            EncryptedCredentialRecord.user_id == user_id,
            EncryptedCredentialRecord.platform == platform,
            EncryptedCredentialRecord.account_id == account_id
        ).first()

        if not record:
            return None

        return record.encrypted_data

    async def list_synced_accounts(self, user_id: str) -> list[dict]:
        """列出用户已同步的账号"""

        records = self.db.query(EncryptedCredentialRecord).filter(
            EncryptedCredentialRecord.user_id == user_id
        ).all()

        return [
            {
                "platform": r.platform,
                "account_id": r.account_id,
                "synced_at": r.updated_at.isoformat(),
                "device": r.last_updated_device
            }
            for r in records
        ]
```

### 3.5 API Key 统一管理

#### 3.5.1 配置管理架构

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                        API Key 统一管理架构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  云端配置中心                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     API Key 配置存储                                  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │ 系统级 API Keys (管理员配置)                                     │  │   │
│  │  │  - Claude API Key (用于云端Agent)                               │  │   │
│  │  │  - OpenAI API Key (备选)                                        │  │   │
│  │  │  - ComfyUI API (图像生成)                                       │  │   │
│  │  │  - 其他第三方服务 Keys                                           │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │ 用户级 API Keys (用户自定义)                                     │  │   │
│  │  │  - 用户自己的 Claude API Key (可选，用于节省算力)                │  │   │
│  │  │  - 用户自己的 OpenAI Key                                        │  │   │
│  │  │  - 其他用户自定义 Keys                                           │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      │ 加密下发                              │
│                                      ▼                                      │
│  桌面端配置同步                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. 启动时从云端拉取配置                                               │   │
│  │ 2. 配置使用用户密钥加密传输                                           │   │
│  │ 3. 本地缓存配置（加密存储）                                           │   │
│  │ 4. 定期同步更新                                                       │   │
│  │ 5. 离线时使用本地缓存                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  优先级规则                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 用户自定义 Key > 订阅计划分配 Key > 系统默认 Key                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3.5.2 配置服务实现

```python
# cloud-service/src/services/config_service.py
from typing import Optional, Dict
from datetime import datetime, timedelta
from sqlmodel import Session
from ..models import SystemConfig, UserConfig
from ..crypto import ConfigCrypto

class ConfigService:
    """配置管理服务"""

    # 配置缓存TTL
    CACHE_TTL = timedelta(hours=1)

    def __init__(self, db: Session, redis_client):
        self.db = db
        self.redis = redis_client

    async def get_api_keys(
        self,
        user_id: str,
        service: str,
        subscription_tier: str
    ) -> Dict[str, str]:
        """获取API密钥配置"""

        # 1. 检查用户自定义Key
        user_key = await self._get_user_api_key(user_id, service)
        if user_key:
            return {
                "api_key": user_key,
                "source": "user_custom",
                "rate_limit": None  # 用户自己的Key不限速
            }

        # 2. 根据订阅等级获取系统Key
        system_key = await self._get_system_api_key(service, subscription_tier)
        if system_key:
            rate_limit = self._get_rate_limit(subscription_tier, service)
            return {
                "api_key": system_key,
                "source": "system",
                "rate_limit": rate_limit
            }

        raise ValueError(f"No API key available for service: {service}")

    async def _get_user_api_key(self, user_id: str, service: str) -> Optional[str]:
        """获取用户自定义API Key"""
        config = self.db.query(UserConfig).filter(
            UserConfig.user_id == user_id,
            UserConfig.config_key == f"api_key.{service}"
        ).first()

        if config:
            return ConfigCrypto.decrypt(config.encrypted_value)
        return None

    async def _get_system_api_key(self, service: str, tier: str) -> Optional[str]:
        """获取系统API Key（根据订阅等级负载均衡）"""
        # 获取该等级可用的Key池
        keys = self.db.query(SystemConfig).filter(
            SystemConfig.config_key == f"api_key.{service}",
            SystemConfig.tier_access.contains([tier])
        ).all()

        if not keys:
            return None

        # 负载均衡：选择使用次数最少的Key
        selected = min(keys, key=lambda k: k.usage_count)
        selected.usage_count += 1
        self.db.commit()

        return ConfigCrypto.decrypt(selected.encrypted_value)

    def _get_rate_limit(self, tier: str, service: str) -> dict:
        """获取速率限制配置"""
        limits = {
            "free": {"requests_per_minute": 5, "tokens_per_day": 10000},
            "creator": {"requests_per_minute": 20, "tokens_per_day": 50000},
            "pro": {"requests_per_minute": 60, "tokens_per_day": 300000},
            "team": {"requests_per_minute": 120, "tokens_per_day": 1000000}
        }
        return limits.get(tier, limits["free"])

    async def sync_config_to_client(self, user_id: str, device_id: str) -> dict:
        """同步配置到客户端"""

        # 获取用户配置
        user_configs = self.db.query(UserConfig).filter(
            UserConfig.user_id == user_id
        ).all()

        # 获取用户可用的系统配置
        user = await self._get_user(user_id)
        system_configs = self._get_accessible_system_configs(user.subscription_tier)

        # 组合配置
        config_bundle = {
            "user_configs": {c.config_key: c.encrypted_value for c in user_configs},
            "system_configs": system_configs,
            "sync_time": datetime.utcnow().isoformat(),
            "ttl": int(self.CACHE_TTL.total_seconds())
        }

        return config_bundle
```

### 3.6 执行环境选择策略

```python
# agent-core/src/runtime_selector.py
from typing import Optional
from .interfaces import RuntimeType, AgentRequest

class RuntimeSelector:
    """运行时选择器 - 智能选择最优执行环境"""

    # 需要本地执行的操作（隐私敏感）
    LOCAL_PREFERRED = [
        "platform.*.login",      # 登录操作
        "credential.*",          # 凭证操作
    ]

    # 适合云端执行的操作
    CLOUD_PREFERRED = [
        "agent.create_article",  # AI创作
        "agent.analyze_*",       # AI分析
        "content.process_video", # 视频处理（需要GPU）
    ]

    @classmethod
    def select_runtime(
        cls,
        request: AgentRequest,
        local_available: bool,
        cloud_available: bool,
        device_type: str  # desktop, mobile
    ) -> RuntimeType:
        """选择执行运行时"""

        # 1. 检查用户偏好
        if request.prefer_runtime == RuntimeType.LOCAL and local_available:
            return RuntimeType.LOCAL
        if request.prefer_runtime == RuntimeType.CLOUD and cloud_available:
            return RuntimeType.CLOUD

        # 2. 移动端强制使用云端
        if device_type == "mobile":
            if not cloud_available:
                raise RuntimeError("Cloud service unavailable for mobile")
            return RuntimeType.CLOUD

        # 3. 根据操作类型选择
        method = request.method

        # 隐私敏感操作优先本地
        for pattern in cls.LOCAL_PREFERRED:
            if cls._match_pattern(method, pattern):
                if local_available:
                    return RuntimeType.LOCAL
                # 本地不可用但允许云端（需用户确认）
                if cloud_available:
                    return RuntimeType.CLOUD

        # 计算密集型操作优先云端
        for pattern in cls.CLOUD_PREFERRED:
            if cls._match_pattern(method, pattern):
                if cloud_available:
                    return RuntimeType.CLOUD
                if local_available:
                    return RuntimeType.LOCAL

        # 4. 默认策略：本地优先
        if local_available:
            return RuntimeType.LOCAL
        if cloud_available:
            return RuntimeType.CLOUD

        raise RuntimeError("No available runtime")

    @staticmethod
    def _match_pattern(method: str, pattern: str) -> bool:
        """匹配方法名和模式"""
        import fnmatch
        return fnmatch.fnmatch(method, pattern)
```

---

## 4. Python Sidecar设计

### 4.1 目录结构

```
python-sidecar/
├── pyproject.toml                # 依赖管理 (uv/poetry)
├── src/
│   ├── __init__.py
│   ├── main.py                   # 入口点
│   ├── server.py                 # JSON-RPC服务器
│   │
│   ├── agents/                   # AI Agent模块
│   │   ├── __init__.py
│   │   ├── claude_agent.py       # Claude Agent SDK集成
│   │   ├── langgraph_agent.py    # LangGraph集成
│   │   ├── workflows/            # 工作流定义
│   │   │   ├── content_creation.py
│   │   │   ├── auto_publish.py
│   │   │   └── data_analysis.py
│   │   └── tools/                # Agent工具
│   │       ├── web_search.py
│   │       ├── content_gen.py
│   │       └── image_gen.py
│   │
│   ├── automation/               # 自动化模块
│   │   ├── __init__.py
│   │   ├── browser/              # 浏览器自动化
│   │   │   ├── manager.py        # 浏览器实例管理
│   │   │   └── platforms/        # 平台适配器
│   │   │       ├── base.py
│   │   │       ├── xiaohongshu.py
│   │   │       ├── douyin.py
│   │   │       ├── weibo.py
│   │   │       └── ...
│   │   ├── scheduler.py          # 定时任务
│   │   └── task_queue.py         # 任务队列
│   │
│   ├── content/                  # 内容处理
│   │   ├── video/                # 视频处理
│   │   ├── image/                # 图片处理
│   │   └── document/             # 文档处理
│   │
│   └── utils/
│       ├── config.py
│       ├── logger.py
│       └── crypto.py             # 凭证加密
│
└── tests/
```

### 3.2 JSON-RPC服务器实现

```python
# python-sidecar/src/server.py
import asyncio
import json
import sys
from typing import Any
from loguru import logger

class JsonRpcServer:
    """JSON-RPC服务器，通过stdio与Tauri通信"""

    def __init__(self):
        self.handlers: dict[str, callable] = {}
        self._running = False

    def register(self, method: str):
        """装饰器：注册RPC方法"""
        def decorator(func):
            self.handlers[method] = func
            return func
        return decorator

    async def handle_request(self, request: dict) -> dict:
        method = request.get("method")
        params = request.get("params", {})
        request_id = request.get("id")

        if method not in self.handlers:
            return {
                "jsonrpc": "2.0",
                "error": {"code": -32601, "message": f"Method not found: {method}"},
                "id": request_id
            }

        try:
            result = await self.handlers[method](**params)
            return {"jsonrpc": "2.0", "result": result, "id": request_id}
        except Exception as e:
            logger.exception(f"Error handling {method}")
            return {
                "jsonrpc": "2.0",
                "error": {"code": -32000, "message": str(e)},
                "id": request_id
            }

    async def run(self):
        """主循环：从stdin读取，写入stdout"""
        self._running = True
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await asyncio.get_event_loop().connect_read_pipe(lambda: protocol, sys.stdin)

        writer_transport, writer_protocol = await asyncio.get_event_loop().connect_write_pipe(
            asyncio.streams.FlowControlMixin, sys.stdout
        )
        writer = asyncio.StreamWriter(writer_transport, writer_protocol, reader, asyncio.get_event_loop())

        while self._running:
            try:
                line = await reader.readline()
                if not line:
                    break

                request = json.loads(line.decode())
                response = await self.handle_request(request)

                writer.write((json.dumps(response) + "\n").encode())
                await writer.drain()
            except Exception as e:
                logger.exception("Error in main loop")

# 全局服务器实例
server = JsonRpcServer()
```

### 3.3 Claude Agent集成

```python
# python-sidecar/src/agents/claude_agent.py
from anthropic import Anthropic
from ..server import server

class ContentCreationAgent:
    """内容创作AI Agent"""

    def __init__(self, api_key: str):
        self.client = Anthropic(api_key=api_key)
        self.tools = self._setup_tools()

    def _setup_tools(self) -> list:
        return [
            {
                "name": "search_trends",
                "description": "搜索当前热点话题和趋势",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "topic": {"type": "string", "description": "搜索主题"},
                        "platform": {"type": "string", "description": "目标平台"}
                    },
                    "required": ["topic"]
                }
            },
            {
                "name": "generate_outline",
                "description": "生成文章大纲",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "topic": {"type": "string"},
                        "style": {"type": "string"},
                        "sections": {"type": "integer", "default": 5}
                    },
                    "required": ["topic"]
                }
            },
            {
                "name": "generate_image_prompt",
                "description": "生成配图提示词",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "context": {"type": "string"},
                        "style": {"type": "string"}
                    },
                    "required": ["context"]
                }
            },
        ]

    async def create_article(
        self,
        topic: str,
        style: str,
        platform: str,
        keywords: list[str] | None = None
    ) -> dict:
        """创建文章的完整流程"""

        system_prompt = f"""你是一个专业的自媒体内容创作者。
        目标平台: {platform}
        写作风格: {style}
        请根据用户的主题创作高质量内容。"""

        messages = [{"role": "user", "content": f"请为我创作一篇关于「{topic}」的文章"}]

        # Agent循环
        while True:
            response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=4096,
                system=system_prompt,
                tools=self.tools,
                messages=messages
            )

            if response.stop_reason == "end_turn":
                return self._extract_result(response)

            if response.stop_reason == "tool_use":
                tool_results = await self._execute_tools(response.content)
                messages.append({"role": "assistant", "content": response.content})
                messages.append({"role": "user", "content": tool_results})

    def _extract_result(self, response) -> dict:
        """提取最终结果"""
        for block in response.content:
            if hasattr(block, 'text'):
                return {"content": block.text, "success": True}
        return {"content": "", "success": False}

    async def _execute_tools(self, content) -> list:
        """执行工具调用"""
        results = []
        for block in content:
            if block.type == "tool_use":
                result = await self._call_tool(block.name, block.input)
                results.append({
                    "type": "tool_result",
                    "tool_use_id": block.id,
                    "content": json.dumps(result)
                })
        return results

    async def _call_tool(self, name: str, params: dict) -> dict:
        """调用具体工具"""
        if name == "search_trends":
            return await self._search_trends(**params)
        elif name == "generate_outline":
            return await self._generate_outline(**params)
        elif name == "generate_image_prompt":
            return await self._generate_image_prompt(**params)
        return {"error": f"Unknown tool: {name}"}

@server.register("agent.create_article")
async def create_article(topic: str, style: str, platform: str, **kwargs):
    """RPC接口：创建文章"""
    from ..utils.config import get_api_key
    agent = ContentCreationAgent(api_key=get_api_key())
    return await agent.create_article(topic, style, platform, **kwargs)
```

### 3.4 定时任务调度

```python
# python-sidecar/src/automation/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from datetime import datetime
from ..server import server

scheduler = AsyncIOScheduler()

class TaskScheduler:
    """定时任务管理器"""

    def __init__(self):
        self.scheduler = scheduler

    async def add_publish_task(
        self,
        task_id: str,
        platform: str,
        content: dict,
        schedule_time: datetime
    ):
        """添加定时发布任务"""
        self.scheduler.add_job(
            self._execute_publish,
            trigger='date',
            run_date=schedule_time,
            id=task_id,
            kwargs={
                'platform': platform,
                'content': content
            }
        )

    async def add_analytics_task(
        self,
        task_id: str,
        platform: str,
        post_id: str,
        cron: str  # 如 "0 9 * * *" 每天9点
    ):
        """添加定时数据采集任务"""
        self.scheduler.add_job(
            self._execute_analytics,
            trigger=CronTrigger.from_crontab(cron),
            id=task_id,
            kwargs={
                'platform': platform,
                'post_id': post_id
            }
        )

    async def remove_task(self, task_id: str):
        """移除任务"""
        self.scheduler.remove_job(task_id)

    async def list_tasks(self) -> list:
        """列出所有任务"""
        jobs = self.scheduler.get_jobs()
        return [
            {
                "id": job.id,
                "next_run": str(job.next_run_time),
                "trigger": str(job.trigger)
            }
            for job in jobs
        ]

    async def _execute_publish(self, platform: str, content: dict):
        """执行发布"""
        from .browser.platforms import get_adapter
        adapter = get_adapter(platform)
        result = await adapter.publish(**content)
        await self._notify_completion('publish', result)

    async def _execute_analytics(self, platform: str, post_id: str):
        """执行数据采集"""
        from .browser.platforms import get_adapter
        adapter = get_adapter(platform)
        data = await adapter.fetch_analytics(post_id)
        await self._notify_completion('analytics', data)

    async def _notify_completion(self, task_type: str, result: dict):
        """通知任务完成（通过事件发送给Tauri）"""
        # TODO: 实现事件通知机制
        pass

@server.register("scheduler.add_publish")
async def add_publish_task(task_id: str, platform: str, content: dict, schedule_time: str):
    ts = TaskScheduler()
    await ts.add_publish_task(task_id, platform, content, datetime.fromisoformat(schedule_time))
    return {"success": True, "task_id": task_id}

@server.register("scheduler.add_analytics")
async def add_analytics_task(task_id: str, platform: str, post_id: str, cron: str):
    ts = TaskScheduler()
    await ts.add_analytics_task(task_id, platform, post_id, cron)
    return {"success": True, "task_id": task_id}

@server.register("scheduler.remove")
async def remove_task(task_id: str):
    ts = TaskScheduler()
    await ts.remove_task(task_id)
    return {"success": True}

@server.register("scheduler.list")
async def list_tasks():
    ts = TaskScheduler()
    return await ts.list_tasks()
```

### 3.5 Tauri Rust端 Sidecar管理

```rust
// src-tauri/src/sidecar/manager.rs
use tauri::api::process::{Command, CommandEvent};
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcRequest {
    jsonrpc: String,
    method: String,
    params: serde_json::Value,
    id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcResponse {
    jsonrpc: String,
    result: Option<serde_json::Value>,
    error: Option<JsonRpcError>,
    id: u64,
}

#[derive(Debug, Serialize, Deserialize)]
struct JsonRpcError {
    code: i32,
    message: String,
}

pub struct PythonSidecar {
    child: Option<tauri::api::process::CommandChild>,
    request_id: u64,
    pending: HashMap<u64, tokio::sync::oneshot::Sender<JsonRpcResponse>>,
}

impl PythonSidecar {
    pub fn new() -> Self {
        Self {
            child: None,
            request_id: 0,
            pending: HashMap::new(),
        }
    }

    pub async fn start(&mut self) -> Result<(), String> {
        let (mut rx, child) = Command::new_sidecar("python-sidecar")
            .expect("Failed to create sidecar command")
            .spawn()
            .expect("Failed to spawn sidecar");

        self.child = Some(child);

        // 处理sidecar输出
        tokio::spawn(async move {
            while let Some(event) = rx.recv().await {
                match event {
                    CommandEvent::Stdout(line) => {
                        if let Ok(response) = serde_json::from_str::<JsonRpcResponse>(&line) {
                            // 发送给等待的请求
                        }
                    }
                    CommandEvent::Stderr(line) => {
                        eprintln!("Python stderr: {}", line);
                    }
                    _ => {}
                }
            }
        });

        Ok(())
    }

    pub async fn call(
        &mut self,
        method: &str,
        params: serde_json::Value
    ) -> Result<serde_json::Value, String> {
        self.request_id += 1;
        let request = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: method.to_string(),
            params,
            id: self.request_id,
        };

        let (tx, rx) = tokio::sync::oneshot::channel();
        self.pending.insert(self.request_id, tx);

        // 发送请求到sidecar
        if let Some(child) = &self.child {
            child.write((serde_json::to_string(&request).unwrap() + "\n").as_bytes())
                .map_err(|e| e.to_string())?;
        }

        // 等待响应
        let response = rx.await.map_err(|e| e.to_string())?;

        response.result.ok_or_else(|| {
            response.error.map(|e| e.message).unwrap_or("Unknown error".to_string())
        })
    }

    pub async fn stop(&mut self) -> Result<(), String> {
        if let Some(child) = self.child.take() {
            child.kill().map_err(|e| e.to_string())?;
        }
        Ok(())
    }
}

// Tauri命令
#[tauri::command]
async fn create_article(
    state: tauri::State<'_, Arc<Mutex<PythonSidecar>>>,
    topic: String,
    style: String,
    platform: String,
) -> Result<serde_json::Value, String> {
    let mut sidecar = state.lock().await;
    sidecar.call("agent.create_article", serde_json::json!({
        "topic": topic,
        "style": style,
        "platform": platform
    })).await
}

#[tauri::command]
async fn publish_content(
    state: tauri::State<'_, Arc<Mutex<PythonSidecar>>>,
    platform: String,
    content: serde_json::Value,
) -> Result<serde_json::Value, String> {
    let mut sidecar = state.lock().await;
    let method = format!("platform.{}.publish", platform);
    sidecar.call(&method, content).await
}

#[tauri::command]
async fn schedule_publish(
    state: tauri::State<'_, Arc<Mutex<PythonSidecar>>>,
    task_id: String,
    platform: String,
    content: serde_json::Value,
    schedule_time: String,
) -> Result<serde_json::Value, String> {
    let mut sidecar = state.lock().await;
    sidecar.call("scheduler.add_publish", serde_json::json!({
        "task_id": task_id,
        "platform": platform,
        "content": content,
        "schedule_time": schedule_time
    })).await
}
```

---

## 4. 平台适配器设计

### 4.1 国内平台支持矩阵

| 平台 | 官方API | 浏览器自动化 | 优先级 | 难度 | 备注 |
|------|---------|-------------|--------|------|------|
| **微信公众号** | ✅ 有 | 备选 | P0 | ⭐⭐ | 官方API较完善 |
| **小红书** | ❌ 无 | ✅ 主要 | P0 | ⭐⭐⭐ | 需要浏览器自动化 |
| **抖音** | ✅ 有(限制) | ✅ 补充 | P0 | ⭐⭐⭐ | 部分功能需自动化 |
| **微博** | ✅ 有 | 备选 | P1 | ⭐⭐ | API较稳定 |
| **B站** | ✅ 有 | 备选 | P1 | ⭐⭐ | 视频平台重点 |
| **知乎** | ❌ 无 | ✅ 主要 | P1 | ⭐⭐⭐ | 需要浏览器自动化 |
| **头条号** | ✅ 有 | 备选 | P1 | ⭐⭐ | 与抖音同属字节 |
| **快手** | ✅ 有(限制) | ✅ 补充 | P2 | ⭐⭐⭐ | 短视频重点 |
| **百家号** | ✅ 有 | 备选 | P2 | ⭐⭐ | 百度生态 |

### 4.2 平台适配器基类

```python
# python-sidecar/src/automation/browser/platforms/base.py
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional
from pathlib import Path
import json

class AuthMethod(Enum):
    QRCODE = "qrcode"       # 扫码登录
    PASSWORD = "password"   # 账号密码
    COOKIE = "cookie"       # Cookie导入
    OAUTH = "oauth"         # OAuth授权

@dataclass
class AuthStatus:
    success: bool
    message: str
    expires_at: Optional[str] = None

@dataclass
class PublishResult:
    success: bool
    post_id: Optional[str] = None
    post_url: Optional[str] = None
    error: Optional[str] = None

@dataclass
class ContentSpec:
    """平台内容规格"""
    max_title_length: int
    max_content_length: int
    max_images: int
    max_video_duration: int  # 秒
    supported_image_formats: list[str]
    supported_video_formats: list[str]
    max_tags: int

class PlatformAdapter(ABC):
    """平台适配器基类"""

    name: str
    base_url: str
    auth_methods: list[AuthMethod]
    content_spec: ContentSpec

    def __init__(self, account_id: str):
        self.account_id = account_id
        self.cookies_path = Path(f"~/.ai-creator/cookies/{self.name}/{account_id}.json").expanduser()

    @abstractmethod
    async def login(self, method: AuthMethod, credentials: dict) -> AuthStatus:
        """登录平台"""
        pass

    @abstractmethod
    async def check_session(self) -> bool:
        """检查登录状态"""
        pass

    @abstractmethod
    async def publish_article(
        self,
        title: str,
        content: str,
        images: list[str],
        **kwargs
    ) -> PublishResult:
        """发布图文"""
        pass

    @abstractmethod
    async def publish_video(
        self,
        video_path: str,
        title: str,
        description: str,
        **kwargs
    ) -> PublishResult:
        """发布视频"""
        pass

    @abstractmethod
    async def fetch_analytics(self, post_id: str) -> dict:
        """获取数据"""
        pass

    @abstractmethod
    async def fetch_comments(self, post_id: str, limit: int = 50) -> list[dict]:
        """获取评论"""
        pass

    async def save_cookies(self, cookies: list[dict]):
        """保存Cookies（加密）"""
        from ...utils.crypto import encrypt_data
        self.cookies_path.parent.mkdir(parents=True, exist_ok=True)
        encrypted = encrypt_data(json.dumps(cookies))
        self.cookies_path.write_bytes(encrypted)

    async def load_cookies(self) -> list[dict]:
        """加载Cookies（解密）"""
        from ...utils.crypto import decrypt_data
        if not self.cookies_path.exists():
            raise ValueError("未登录，请先登录")
        encrypted = self.cookies_path.read_bytes()
        return json.loads(decrypt_data(encrypted))

    def validate_content(self, title: str, content: str, images: list[str]) -> list[str]:
        """验证内容是否符合平台规格"""
        errors = []
        spec = self.content_spec

        if len(title) > spec.max_title_length:
            errors.append(f"标题超长：{len(title)}/{spec.max_title_length}")

        if len(content) > spec.max_content_length:
            errors.append(f"内容超长：{len(content)}/{spec.max_content_length}")

        if len(images) > spec.max_images:
            errors.append(f"图片过多：{len(images)}/{spec.max_images}")

        return errors
```

### 4.3 小红书适配器实现

```python
# python-sidecar/src/automation/browser/platforms/xiaohongshu.py
from playwright.async_api import async_playwright, Page, Browser
from .base import PlatformAdapter, PublishResult, AuthStatus, AuthMethod, ContentSpec
from ...server import server

class XiaohongshuAdapter(PlatformAdapter):
    """小红书平台适配器"""

    name = "xiaohongshu"
    base_url = "https://creator.xiaohongshu.com"
    auth_methods = [AuthMethod.QRCODE, AuthMethod.COOKIE]
    content_spec = ContentSpec(
        max_title_length=20,
        max_content_length=1000,
        max_images=18,
        max_video_duration=900,  # 15分钟
        supported_image_formats=["jpg", "jpeg", "png", "webp"],
        supported_video_formats=["mp4", "mov"],
        max_tags=5
    )

    async def login(self, method: AuthMethod, credentials: dict = None) -> AuthStatus:
        """登录小红书创作者中心"""
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=False)
            page = await browser.new_page()

            await page.goto(f"{self.base_url}/login")

            if method == AuthMethod.QRCODE:
                # 等待用户扫码
                await page.wait_for_url("**/home**", timeout=120000)
            elif method == AuthMethod.COOKIE:
                # 直接设置Cookie
                await page.context.add_cookies(credentials.get("cookies", []))
                await page.goto(f"{self.base_url}/home")

            # 验证登录成功
            try:
                await page.wait_for_selector('.user-info', timeout=5000)
                cookies = await page.context.cookies()
                await self.save_cookies(cookies)
                await browser.close()
                return AuthStatus(success=True, message="登录成功")
            except:
                await browser.close()
                return AuthStatus(success=False, message="登录失败")

    async def check_session(self) -> bool:
        """检查登录状态"""
        try:
            cookies = await self.load_cookies()
            async with async_playwright() as p:
                browser = await p.chromium.launch(headless=True)
                context = await browser.new_context()
                await context.add_cookies(cookies)
                page = await context.new_page()

                await page.goto(f"{self.base_url}/home")

                # 检查是否跳转到登录页
                if "login" in page.url:
                    await browser.close()
                    return False

                await browser.close()
                return True
        except:
            return False

    async def publish_article(
        self,
        title: str,
        content: str,
        images: list[str],
        tags: list[str] = None,
        **kwargs
    ) -> PublishResult:
        """发布小红书笔记"""

        # 验证内容
        errors = self.validate_content(title, content, images)
        if errors:
            return PublishResult(success=False, error="; ".join(errors))

        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context()

            # 恢复登录态
            cookies = await self.load_cookies()
            await context.add_cookies(cookies)

            page = await context.new_page()
            await page.goto(f"{self.base_url}/publish/publish")

            try:
                # 等待页面加载
                await page.wait_for_selector('.upload-input', timeout=10000)

                # 上传图片
                file_input = page.locator('input[type="file"]').first
                await file_input.set_input_files(images)

                # 等待上传完成
                await page.wait_for_selector('.upload-item.success', timeout=60000)
                await page.wait_for_timeout(2000)  # 额外等待

                # 填写标题
                title_input = page.locator('[placeholder*="标题"]')
                await title_input.fill(title)

                # 填写正文
                content_input = page.locator('[placeholder*="正文"]')
                await content_input.fill(content)

                # 添加标签
                if tags:
                    for tag in tags[:5]:
                        await page.click('.add-tag-btn')
                        await page.fill('.tag-input', f"#{tag}")
                        await page.press('.tag-input', 'Enter')
                        await page.wait_for_timeout(500)

                # 点击发布
                await page.click('button:has-text("发布")')

                # 等待发布成功
                await page.wait_for_url("**/success**", timeout=30000)

                # 提取作品链接
                post_url = await self._extract_post_url(page)
                post_id = self._extract_post_id(post_url)

                await browser.close()

                return PublishResult(
                    success=True,
                    post_id=post_id,
                    post_url=post_url
                )

            except Exception as e:
                await browser.close()
                return PublishResult(success=False, error=str(e))

    async def publish_video(
        self,
        video_path: str,
        title: str,
        description: str,
        cover_path: str = None,
        tags: list[str] = None,
        **kwargs
    ) -> PublishResult:
        """发布视频笔记"""
        # 类似图文发布，但上传视频
        # TODO: 实现视频发布逻辑
        pass

    async def fetch_analytics(self, post_id: str) -> dict:
        """获取笔记数据"""
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context()
            await context.add_cookies(await self.load_cookies())

            page = await context.new_page()
            await page.goto(f"{self.base_url}/data/note/{post_id}")

            await page.wait_for_selector('.data-card', timeout=10000)

            data = {
                "views": await self._get_metric(page, "阅读"),
                "likes": await self._get_metric(page, "点赞"),
                "collects": await self._get_metric(page, "收藏"),
                "comments": await self._get_metric(page, "评论"),
                "shares": await self._get_metric(page, "分享"),
            }

            await browser.close()
            return data

    async def fetch_comments(self, post_id: str, limit: int = 50) -> list[dict]:
        """获取评论列表"""
        # TODO: 实现评论获取
        pass

    async def _extract_post_url(self, page: Page) -> str:
        """提取发布成功后的作品链接"""
        link_element = page.locator('.post-link')
        return await link_element.get_attribute('href')

    def _extract_post_id(self, url: str) -> str:
        """从URL提取作品ID"""
        # https://www.xiaohongshu.com/explore/xxxxx
        import re
        match = re.search(r'/explore/(\w+)', url)
        return match.group(1) if match else ""

    async def _get_metric(self, page: Page, metric_name: str) -> int:
        """获取指定指标的数值"""
        try:
            selector = f'.data-item:has-text("{metric_name}") .value'
            element = page.locator(selector)
            text = await element.text_content()
            return self._parse_number(text)
        except:
            return 0

    def _parse_number(self, text: str) -> int:
        """解析数字（支持万、亿单位）"""
        text = text.strip()
        if '万' in text:
            return int(float(text.replace('万', '')) * 10000)
        elif '亿' in text:
            return int(float(text.replace('亿', '')) * 100000000)
        else:
            return int(text.replace(',', ''))

# RPC接口注册
@server.register("platform.xiaohongshu.login")
async def login(account_id: str, method: str = "qrcode", credentials: dict = None):
    adapter = XiaohongshuAdapter(account_id)
    return await adapter.login(AuthMethod(method), credentials)

@server.register("platform.xiaohongshu.check_session")
async def check_session(account_id: str):
    adapter = XiaohongshuAdapter(account_id)
    return {"valid": await adapter.check_session()}

@server.register("platform.xiaohongshu.publish")
async def publish(account_id: str, title: str, content: str, images: list[str], tags: list[str] = None):
    adapter = XiaohongshuAdapter(account_id)
    result = await adapter.publish_article(title, content, images, tags)
    return result.__dict__

@server.register("platform.xiaohongshu.analytics")
async def analytics(account_id: str, post_id: str):
    adapter = XiaohongshuAdapter(account_id)
    return await adapter.fetch_analytics(post_id)
```

---

## 5. AI Agent工作流

### 5.1 内容创作工作流（LangGraph）

```python
# python-sidecar/src/agents/workflows/content_creation.py
from langgraph.graph import StateGraph, END
from typing import TypedDict, Annotated
from operator import add

class ContentState(TypedDict):
    """内容创作状态"""
    # 输入
    topic: str
    platform: str
    style: str

    # 中间结果
    trends: list[dict]
    outline: dict
    draft: str
    review_passed: bool
    review_feedback: str

    # 最终输出
    final_content: str
    final_images: list[str]
    seo_tags: list[str]

    # 消息历史
    messages: Annotated[list, add]

def create_content_workflow():
    """创建内容创作工作流"""

    workflow = StateGraph(ContentState)

    # 添加节点
    workflow.add_node("research", research_node)      # 热点研究
    workflow.add_node("outline", outline_node)        # 生成大纲
    workflow.add_node("draft", draft_node)            # 撰写初稿
    workflow.add_node("review", review_node)          # AI审核
    workflow.add_node("polish", polish_node)          # 润色优化
    workflow.add_node("image_gen", image_gen_node)    # 配图生成
    workflow.add_node("seo", seo_node)                # SEO优化

    # 设置入口
    workflow.set_entry_point("research")

    # 添加边
    workflow.add_edge("research", "outline")
    workflow.add_edge("outline", "draft")
    workflow.add_edge("draft", "review")

    # 条件边：审核通过则润色，否则重写
    workflow.add_conditional_edges(
        "review",
        lambda state: "polish" if state.get("review_passed") else "draft",
        {"polish": "polish", "draft": "draft"}
    )

    workflow.add_edge("polish", "image_gen")
    workflow.add_edge("image_gen", "seo")
    workflow.add_edge("seo", END)

    return workflow.compile()

async def research_node(state: ContentState) -> dict:
    """热点研究节点"""
    from ..tools import search_trends, analyze_competitors

    # 搜索相关热点
    trends = await search_trends(state["topic"], state["platform"])

    # 分析竞品内容
    competitors = await analyze_competitors(state["topic"], state["platform"])

    return {
        "trends": trends,
        "messages": [{"role": "system", "content": f"已完成热点研究，发现{len(trends)}个相关趋势"}]
    }

async def outline_node(state: ContentState) -> dict:
    """大纲生成节点"""
    from anthropic import Anthropic

    client = Anthropic()

    prompt = f"""基于以下信息，为「{state['topic']}」生成文章大纲：

热点趋势：{state['trends']}
目标平台：{state['platform']}
写作风格：{state['style']}

请生成一个结构清晰、有吸引力的大纲，包含：
1. 吸引人的开头
2. 3-5个核心观点
3. 有力的结尾

以JSON格式输出。"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=2000,
        messages=[{"role": "user", "content": prompt}]
    )

    outline = parse_json_response(response.content[0].text)

    return {
        "outline": outline,
        "messages": [{"role": "assistant", "content": "大纲生成完成"}]
    }

async def draft_node(state: ContentState) -> dict:
    """撰写初稿节点"""
    from anthropic import Anthropic

    client = Anthropic()

    # 如果有审核反馈，加入提示
    feedback_prompt = ""
    if state.get("review_feedback"):
        feedback_prompt = f"\n\n请注意改进以下问题：{state['review_feedback']}"

    prompt = f"""根据以下大纲撰写完整文章：

大纲：{state['outline']}
平台：{state['platform']}
风格：{state['style']}
{feedback_prompt}

要求：
1. 语言生动，符合{state['platform']}平台用户阅读习惯
2. 适当使用emoji增加可读性
3. 段落清晰，便于阅读"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=4000,
        messages=[{"role": "user", "content": prompt}]
    )

    return {
        "draft": response.content[0].text,
        "messages": [{"role": "assistant", "content": "初稿撰写完成"}]
    }

async def review_node(state: ContentState) -> dict:
    """AI审核节点"""
    from anthropic import Anthropic

    client = Anthropic()

    prompt = f"""请审核以下{state['platform']}平台的内容：

{state['draft']}

审核标准：
1. 内容质量：是否有价值、有深度
2. 平台适配：是否符合{state['platform']}的内容规范
3. 可读性：段落是否清晰，是否易于阅读
4. 敏感词检测：是否包含可能被屏蔽的词汇

请以JSON格式输出：
{{
    "passed": true/false,
    "score": 1-10,
    "feedback": "具体改进建议"
}}"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=1000,
        messages=[{"role": "user", "content": prompt}]
    )

    result = parse_json_response(response.content[0].text)

    return {
        "review_passed": result.get("passed", False) or result.get("score", 0) >= 7,
        "review_feedback": result.get("feedback", ""),
        "messages": [{"role": "assistant", "content": f"审核完成，得分：{result.get('score')}"}]
    }

async def polish_node(state: ContentState) -> dict:
    """润色优化节点"""
    from anthropic import Anthropic

    client = Anthropic()

    prompt = f"""请对以下内容进行最终润色：

{state['draft']}

润色要求：
1. 优化语言表达，使其更加流畅
2. 检查并修正语法错误
3. 增强开头的吸引力
4. 强化结尾的号召性"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=4000,
        messages=[{"role": "user", "content": prompt}]
    )

    return {
        "final_content": response.content[0].text,
        "messages": [{"role": "assistant", "content": "内容润色完成"}]
    }

async def image_gen_node(state: ContentState) -> dict:
    """配图生成节点"""
    from ..tools import generate_image_prompts, generate_images

    # 生成配图提示词
    prompts = await generate_image_prompts(state["final_content"], state["platform"])

    # 生成图片
    images = await generate_images(prompts)

    return {
        "final_images": images,
        "messages": [{"role": "assistant", "content": f"已生成{len(images)}张配图"}]
    }

async def seo_node(state: ContentState) -> dict:
    """SEO优化节点"""
    from anthropic import Anthropic

    client = Anthropic()

    prompt = f"""请为以下内容生成SEO标签：

{state['final_content']}

目标平台：{state['platform']}

请生成5-10个热门标签，以JSON数组格式输出。"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=500,
        messages=[{"role": "user", "content": prompt}]
    )

    tags = parse_json_response(response.content[0].text)

    return {
        "seo_tags": tags if isinstance(tags, list) else [],
        "messages": [{"role": "assistant", "content": "SEO标签生成完成"}]
    }

def parse_json_response(text: str):
    """解析JSON响应"""
    import json
    import re

    # 尝试提取JSON块
    json_match = re.search(r'```json\s*(.*?)\s*```', text, re.DOTALL)
    if json_match:
        text = json_match.group(1)

    # 尝试直接解析
    try:
        return json.loads(text)
    except:
        # 尝试找到JSON部分
        start = text.find('{')
        end = text.rfind('}') + 1
        if start != -1 and end > start:
            try:
                return json.loads(text[start:end])
            except:
                pass

        # 尝试数组
        start = text.find('[')
        end = text.rfind(']') + 1
        if start != -1 and end > start:
            try:
                return json.loads(text[start:end])
            except:
                pass

    return {}
```

### 5.2 Agent工具集

```python
# python-sidecar/src/agents/tools/__init__.py
from typing import Annotated

async def search_trends(
    topic: Annotated[str, "搜索主题"],
    platform: Annotated[str, "目标平台"]
) -> list[dict]:
    """搜索指定平台的热点话题和趋势"""
    # TODO: 接入搜索API（SerpAPI、百度指数等）
    return [
        {"title": f"{topic}相关热点1", "heat": 10000},
        {"title": f"{topic}相关热点2", "heat": 8000},
    ]

async def analyze_competitors(
    topic: Annotated[str, "内容主题"],
    platform: Annotated[str, "平台名称"],
    limit: Annotated[int, "返回数量"] = 10
) -> list[dict]:
    """分析竞品内容"""
    # TODO: 实现竞品分析
    return []

async def generate_image_prompts(
    content: Annotated[str, "文章内容"],
    platform: Annotated[str, "目标平台"]
) -> list[str]:
    """生成配图提示词"""
    from anthropic import Anthropic

    client = Anthropic()

    prompt = f"""根据以下内容，生成3个配图的详细描述提示词：

{content[:1000]}

要求：
1. 图片要与内容主题相关
2. 风格要符合{platform}平台的审美
3. 描述要具体，包含场景、色调、风格等

以JSON数组格式输出。"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=1000,
        messages=[{"role": "user", "content": prompt}]
    )

    # 解析响应
    import json
    try:
        return json.loads(response.content[0].text)
    except:
        return []

async def generate_images(prompts: list[str]) -> list[str]:
    """生成图片，返回图片路径列表"""
    # TODO: 接入Stable Diffusion API或其他图像生成服务
    return []

async def analyze_content_quality(
    content: Annotated[str, "待分析的内容"],
    platform: Annotated[str, "目标平台"]
) -> dict:
    """分析内容质量"""
    from anthropic import Anthropic

    client = Anthropic()

    prompt = f"""分析以下{platform}平台内容的质量：

{content}

请从以下维度评分（1-10）：
1. 原创性
2. 可读性
3. 价值性
4. 平台适配度
5. 病毒传播潜力

以JSON格式输出评分和改进建议。"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=1000,
        messages=[{"role": "user", "content": prompt}]
    )

    import json
    try:
        return json.loads(response.content[0].text)
    except:
        return {"error": "解析失败"}
```

---

## 6. 数据模型设计

### 6.1 核心实体定义

```python
# python-sidecar/src/models/entities.py
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from typing import Optional
from enum import Enum

class ContentType(str, Enum):
    ARTICLE = "article"
    VIDEO = "video"
    IMAGE = "image"

class PublishStatus(str, Enum):
    DRAFT = "draft"
    SCHEDULED = "scheduled"
    PUBLISHING = "publishing"
    PUBLISHED = "published"
    FAILED = "failed"

# ==================== 用户相关 ====================

class User(SQLModel, table=True):
    """用户"""
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(unique=True, index=True)
    nickname: str
    avatar_url: Optional[str]
    subscription_tier: str = "free"  # free, creator, pro, team
    token_balance: int = 0
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class PlatformAccount(SQLModel, table=True):
    """平台账号"""
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)
    platform: str  # xiaohongshu, douyin, weibo...
    account_name: str
    account_id: str  # 平台用户ID
    avatar_url: Optional[str]
    is_active: bool = True
    last_login: Optional[datetime]
    cookies_updated_at: Optional[datetime]
    created_at: datetime = Field(default_factory=datetime.utcnow)

# ==================== 内容相关 ====================

class Content(SQLModel, table=True):
    """内容作品"""
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)

    title: str
    content_type: ContentType
    body: str  # Markdown或JSON
    cover_image: Optional[str]

    status: PublishStatus = PublishStatus.DRAFT

    # AI创作元数据
    ai_generated: bool = False
    generation_prompt: Optional[str]
    generation_model: Optional[str]
    generation_workflow: Optional[str]  # 使用的工作流

    # 统计
    word_count: int = 0

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class ContentVersion(SQLModel, table=True):
    """内容版本历史"""
    id: Optional[int] = Field(default=None, primary_key=True)
    content_id: int = Field(foreign_key="content.id", index=True)
    version: int
    body: str
    change_summary: Optional[str]
    created_at: datetime = Field(default_factory=datetime.utcnow)

# ==================== 发布相关 ====================

class Publication(SQLModel, table=True):
    """发布记录"""
    id: Optional[int] = Field(default=None, primary_key=True)
    content_id: int = Field(foreign_key="content.id", index=True)
    platform_account_id: int = Field(foreign_key="platformaccount.id", index=True)

    platform_post_id: Optional[str]  # 平台返回的作品ID
    platform_post_url: Optional[str]

    status: PublishStatus
    scheduled_at: Optional[datetime]
    published_at: Optional[datetime]
    error_message: Optional[str]

    # 发布配置
    publish_config: str = "{}"  # JSON: 标签、话题、@用户等

    created_at: datetime = Field(default_factory=datetime.utcnow)

class Analytics(SQLModel, table=True):
    """运营数据"""
    id: Optional[int] = Field(default=None, primary_key=True)
    publication_id: int = Field(foreign_key="publication.id", index=True)

    views: int = 0
    likes: int = 0
    comments: int = 0
    shares: int = 0
    collects: int = 0  # 收藏
    followers_gained: int = 0

    # 扩展指标（JSON）
    extra_metrics: str = "{}"

    recorded_at: datetime = Field(default_factory=datetime.utcnow)

# ==================== 素材相关 ====================

class Material(SQLModel, table=True):
    """素材"""
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)

    name: str
    type: str  # image, video, audio, document
    file_path: str
    file_size: int
    mime_type: str

    # 元数据
    width: Optional[int]
    height: Optional[int]
    duration: Optional[float]  # 视频/音频时长（秒）

    # AI标签
    tags: str = "[]"  # JSON数组
    ai_description: Optional[str]

    # 来源
    source: Optional[str]  # 上传、AI生成、网络采集
    source_url: Optional[str]

    created_at: datetime = Field(default_factory=datetime.utcnow)

# ==================== 知识库相关 ====================

class Idea(SQLModel, table=True):
    """想法/灵感"""
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)

    title: str
    content: str
    source: Optional[str]  # 灵感来源

    # 关联
    tags: str = "[]"
    related_materials: str = "[]"  # Material IDs

    # 状态
    is_used: bool = False
    used_in_content_id: Optional[int]

    # 优先级
    priority: int = 0  # 0=普通, 1=重要, 2=紧急

    created_at: datetime = Field(default_factory=datetime.utcnow)

class KnowledgeBase(SQLModel, table=True):
    """知识库条目"""
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)

    title: str
    content: str
    category: str  # 分类

    # 向量嵌入（用于RAG）
    embedding: Optional[str]  # JSON数组或向量数据库ID

    # 来源
    source_type: str  # manual, import, web
    source_url: Optional[str]

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

# ==================== 任务相关 ====================

class ScheduledTask(SQLModel, table=True):
    """定时任务"""
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)

    task_type: str  # publish, analytics, backup
    task_config: str  # JSON配置

    # 调度
    cron_expression: Optional[str]  # cron表达式
    next_run_at: Optional[datetime]
    last_run_at: Optional[datetime]

    # 状态
    is_active: bool = True
    last_status: Optional[str]
    last_error: Optional[str]

    created_at: datetime = Field(default_factory=datetime.utcnow)
```

### 6.2 数据库初始化

```python
# python-sidecar/src/models/database.py
from sqlmodel import SQLModel, create_engine, Session
from pathlib import Path

DATABASE_PATH = Path("~/.ai-creator/data/ai_creator.db").expanduser()

def get_engine():
    DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    return create_engine(f"sqlite:///{DATABASE_PATH}")

def init_db():
    """初始化数据库"""
    engine = get_engine()
    SQLModel.metadata.create_all(engine)

def get_session():
    """获取数据库会话"""
    engine = get_engine()
    return Session(engine)
```

---

## 7. 移动端方案

### 7.1 功能分层策略

```yaml
桌面端 (Full Feature):
  - AI Agent完整功能
  - 浏览器自动化发布
  - 定时任务调度
  - 视频剪辑处理
  - 完整Python环境
  - 批量操作
  - 数据分析完整功能

移动端 (Lite Feature):
  - 内容浏览和编辑
  - 素材采集（拍照、录音、截图）
  - 想法快速记录
  - 数据查看（简化版）
  - 远程触发桌面端任务
  - 简单发布（调用云端API）
  - 消息通知接收
```

### 7.2 技术方案

| 方案 | 可行性 | 复杂度 | 说明 |
|------|--------|--------|------|
| **Tauri 2.0 Mobile** ✅ | ⭐⭐⭐⭐ | 中 | 推荐，代码复用度高 |
| React Native | ⭐⭐⭐ | 高 | 需要单独开发 |
| Flutter | ⭐⭐⭐⭐ | 中 | 备选方案 |

### 7.3 云端协同

```
┌─────────────────┐         ┌─────────────────┐
│    桌面端        │         │    移动端        │
│  (Full Feature) │         │ (Lite Feature)  │
└────────┬────────┘         └────────┬────────┘
         │                           │
         │         云端服务           │
         │  ┌─────────────────────┐  │
         └──┤   数据同步服务       ├──┘
            │   - 内容同步         │
            │   - 素材同步         │
            │   - 任务状态同步     │
            │   - 账号信息同步     │
            └─────────────────────┘
```

---

## 8. 商业模式

### 8.1 订阅层级

| 层级 | 价格(月) | AI算力 | 平台数 | 账号数 | 特权 |
|------|----------|--------|--------|--------|------|
| **免费版** | ¥0 | 基础体验(1万tokens) | 2 | 2 | 有水印 |
| **创作者版** | ¥29 | 5万tokens | 5 | 5 | 无水印、优先支持 |
| **专业版** | ¥99 | 30万tokens | 不限 | 20 | 优先队列、高级分析 |
| **团队版** | ¥299 | 100万tokens | 不限 | 不限 | 协作功能、API访问 |

### 8.2 算力消耗计价

```yaml
文字生成:
  基础模型 (Claude Haiku): 1 token/字
  高级模型 (Claude Sonnet): 3 token/字
  旗舰模型 (Claude Opus): 10 token/字

图片生成:
  SD基础 (512x512): 500 tokens/张
  SD高清 (1024x1024): 1500 tokens/张
  MJ风格: 3000 tokens/张

视频处理:
  字幕生成: 100 tokens/分钟
  AI剪辑: 2000 tokens/分钟
  视频生成: 5000 tokens/分钟

数据分析:
  单篇分析: 50 tokens
  批量分析: 30 tokens/篇
  AI选题建议: 200 tokens/次
```

### 8.3 功能矩阵

| 功能 | 免费版 | 创作者版 | 专业版 | 团队版 |
|------|--------|---------|--------|--------|
| AI文章生成 | 3篇/天 | 30篇/天 | 不限 | 不限 |
| AI配图 | 5张/天 | 50张/天 | 不限 | 不限 |
| 平台发布 | 手动 | 自动 | 自动+定时 | 全部 |
| 数据分析 | 基础 | 标准 | 高级 | 高级+API |
| 素材存储 | 1GB | 10GB | 50GB | 200GB |
| 历史版本 | 7天 | 30天 | 90天 | 永久 |

---

## 9. 开发计划

### 9.1 Phase 1: 基础框架 (Month 1-2)

**Week 1-2: 项目初始化**
- [ ] Tauri项目搭建
- [ ] React前端框架
- [ ] Python Sidecar架构
- [ ] JSON-RPC通信实现

**Week 3-4: 用户系统**
- [ ] 本地用户管理
- [ ] 云端账号同步
- [ ] SQLite数据库设计
- [ ] 基础CRUD操作

**Week 5-6: 账号管理**
- [ ] 平台账号管理UI
- [ ] Cookie/凭证加密存储
- [ ] 首个平台适配器（微信公众号）

**Week 7-8: AI基础**
- [ ] Claude Agent SDK集成
- [ ] 基础内容创作工作流
- [ ] 文章生成MVP

### 9.2 Phase 2: 核心功能 (Month 3-4)

**Week 9-10: 平台扩展**
- [ ] 小红书适配器
- [ ] 抖音适配器
- [ ] 发布任务队列

**Week 11-12: 素材管理**
- [ ] 素材库管理
- [ ] 图片上传和处理
- [ ] AI配图建议

**Week 13-14: 自动化**
- [ ] 定时发布功能
- [ ] APScheduler集成
- [ ] 后台任务管理

**Week 15-16: 数据分析**
- [ ] 运营数据采集
- [ ] 数据看板UI
- [ ] 基础分析功能

### 9.3 Phase 3: 增强功能 (Month 5-6)

**Week 17-20: 功能完善**
- [ ] 更多平台适配（微博、B站、知乎）
- [ ] LangGraph复杂工作流
- [ ] AI选题建议功能

**Week 21-24: 扩展开发**
- [ ] 视频处理基础（字幕、封面）
- [ ] 知识库RAG
- [ ] 移动端精简版
- [ ] 订阅和计费系统

### 9.4 团队分工建议

```
前端团队 (5人):
  - Tauri UI开发 x2
  - React组件开发 x2
  - 移动端适配 x1

后端团队 (6人):
  - Python Sidecar x2
  - 平台适配器 x2
  - 云端服务 x2

AI团队 (4人):
  - Agent开发 x2
  - 工作流设计 x1
  - 模型调优 x1

平台团队 (3人):
  - 平台研究 x1
  - 适配器开发 x2

基础设施 (2人):
  - DevOps x1
  - 测试 x1
```

---

## 10. 风险与挑战

### 10.1 账号绑定与自动发布方案

#### 10.1.1 实现流程

```text
┌─────────────────────────────────────────────────────────────────────┐
│                        账号绑定流程                                  │
│                                                                     │
│  ┌─────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────┐ │
│  │ 用户点击 │ ──▶│ 打开内嵌浏览器│ ──▶│ 用户手动登录 │ ──▶│ 保存凭证 │ │
│  │ 绑定账号 │    │ (Playwright) │    │ (扫码/密码)  │    │ 加密存储 │ │
│  └─────────┘    └─────────────┘    └─────────────┘    └─────────┘ │
│                                                                     │
│  保存内容:                                                          │
│  - Cookies (全部)                                                   │
│  - LocalStorage                                                     │
│  - SessionStorage                                                   │
│  - 设备指纹 (UA, 屏幕, 时区等)                                       │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        发布流程                                      │
│                                                                     │
│  ┌─────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────┐ │
│  │ 发布任务 │ ──▶│ 创建虚拟浏览器│ ──▶│ 恢复登录态  │ ──▶│ AI操作  │ │
│  │         │    │ (相同指纹)   │    │ (注入凭证)  │    │ 自动发布 │ │
│  └─────────┘    └─────────────┘    └─────────────┘    └─────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.1.2 浏览器指纹管理

```python
# python-sidecar/src/automation/browser/fingerprint.py
from dataclasses import dataclass, asdict
from typing import Optional
import json
import hashlib

@dataclass
class BrowserFingerprint:
    """浏览器指纹"""
    user_agent: str
    viewport_width: int
    viewport_height: int
    screen_width: int
    screen_height: int
    device_pixel_ratio: float
    timezone: str
    language: str
    platform: str
    webgl_vendor: str
    webgl_renderer: str

    # 可选的高级指纹
    fonts: Optional[list[str]] = None
    plugins: Optional[list[str]] = None
    canvas_hash: Optional[str] = None
    audio_hash: Optional[str] = None

    def to_dict(self) -> dict:
        return asdict(self)

    def fingerprint_hash(self) -> str:
        """生成指纹哈希，用于一致性检测"""
        data = json.dumps(self.to_dict(), sort_keys=True)
        return hashlib.sha256(data.encode()).hexdigest()[:16]

# 预设指纹模板（模拟真实设备）
FINGERPRINT_TEMPLATES = {
    "windows_chrome": BrowserFingerprint(
        user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        viewport_width=1920,
        viewport_height=1080,
        screen_width=1920,
        screen_height=1080,
        device_pixel_ratio=1.0,
        timezone="Asia/Shanghai",
        language="zh-CN",
        platform="Win32",
        webgl_vendor="Google Inc. (NVIDIA)",
        webgl_renderer="ANGLE (NVIDIA, NVIDIA GeForce RTX 3060 Direct3D11 vs_5_0 ps_5_0)"
    ),
    "mac_chrome": BrowserFingerprint(
        user_agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        viewport_width=1440,
        viewport_height=900,
        screen_width=2560,
        screen_height=1600,
        device_pixel_ratio=2.0,
        timezone="Asia/Shanghai",
        language="zh-CN",
        platform="MacIntel",
        webgl_vendor="Google Inc. (Apple)",
        webgl_renderer="ANGLE (Apple, Apple M1 Pro, OpenGL 4.1)"
    ),
}
```

#### 10.1.3 会话管理器

```python
# python-sidecar/src/automation/browser/session_manager.py
from playwright.async_api import async_playwright, Browser, BrowserContext
from pathlib import Path
from datetime import datetime
from typing import Optional
import json

from .fingerprint import BrowserFingerprint, FINGERPRINT_TEMPLATES
from ...utils.crypto import encrypt_data, decrypt_data

class SessionData:
    """会话数据"""
    def __init__(
        self,
        cookies: list[dict],
        local_storage: dict,
        session_storage: dict,
        fingerprint: BrowserFingerprint,
        created_at: str,
        platform: str,
        account_id: str
    ):
        self.cookies = cookies
        self.local_storage = local_storage
        self.session_storage = session_storage
        self.fingerprint = fingerprint
        self.created_at = created_at
        self.platform = platform
        self.account_id = account_id

class SessionManager:
    """会话管理器 - 负责账号绑定和会话恢复"""

    def __init__(self, data_dir: str = "~/.ai-creator/sessions"):
        self.data_dir = Path(data_dir).expanduser()
        self.data_dir.mkdir(parents=True, exist_ok=True)

    def _get_session_path(self, platform: str, account_id: str) -> Path:
        return self.data_dir / platform / f"{account_id}.enc"

    async def bind_account(
        self,
        platform: str,
        account_id: str,
        login_url: str,
        fingerprint_template: str = "windows_chrome"
    ) -> dict:
        """
        绑定账号流程：
        1. 打开浏览器让用户登录
        2. 登录成功后保存所有凭证
        """
        fingerprint = FINGERPRINT_TEMPLATES[fingerprint_template]

        async with async_playwright() as p:
            # 创建带指纹的浏览器
            browser = await p.chromium.launch(
                headless=False,  # 显示界面让用户操作
                args=[
                    '--disable-blink-features=AutomationControlled',
                    f'--window-size={fingerprint.viewport_width},{fingerprint.viewport_height}'
                ]
            )

            context = await browser.new_context(
                viewport={
                    'width': fingerprint.viewport_width,
                    'height': fingerprint.viewport_height
                },
                user_agent=fingerprint.user_agent,
                locale=fingerprint.language,
                timezone_id=fingerprint.timezone,
                device_scale_factor=fingerprint.device_pixel_ratio,
            )

            # 注入反检测脚本
            await context.add_init_script(self._get_stealth_script(fingerprint))

            page = await context.new_page()
            await page.goto(login_url)

            # 等待用户登录完成
            print(f"请在浏览器中登录 {platform}，登录成功后会自动保存...")

            try:
                await self._wait_for_login(page, platform)

                # 提取所有凭证
                cookies = await context.cookies()
                local_storage = await page.evaluate("() => Object.assign({}, localStorage)")
                session_storage = await page.evaluate("() => Object.assign({}, sessionStorage)")

                # 保存会话
                session = SessionData(
                    cookies=cookies,
                    local_storage=local_storage,
                    session_storage=session_storage,
                    fingerprint=fingerprint,
                    created_at=datetime.utcnow().isoformat(),
                    platform=platform,
                    account_id=account_id
                )

                await self._save_session(session)
                await browser.close()

                return {
                    "success": True,
                    "message": "账号绑定成功",
                    "account_id": account_id,
                    "fingerprint_hash": fingerprint.fingerprint_hash()
                }

            except Exception as e:
                await browser.close()
                return {"success": False, "message": f"绑定失败: {str(e)}"}

    async def create_authenticated_context(
        self,
        platform: str,
        account_id: str,
        headless: bool = True
    ) -> tuple[Browser, BrowserContext, any]:
        """创建已认证的浏览器上下文，用于自动发布"""
        session = await self._load_session(platform, account_id)
        if not session:
            raise ValueError(f"未找到账号 {account_id} 的会话数据，请先绑定账号")

        fingerprint = session.fingerprint

        p = await async_playwright().start()
        browser = await p.chromium.launch(
            headless=headless,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--no-sandbox',
                '--disable-dev-shm-usage',
            ]
        )

        context = await browser.new_context(
            viewport={
                'width': fingerprint.viewport_width,
                'height': fingerprint.viewport_height
            },
            user_agent=fingerprint.user_agent,
            locale=fingerprint.language,
            timezone_id=fingerprint.timezone,
            device_scale_factor=fingerprint.device_pixel_ratio,
        )

        # 注入反检测脚本
        await context.add_init_script(self._get_stealth_script(fingerprint))

        # 恢复Cookies
        await context.add_cookies(session.cookies)

        page = await context.new_page()

        # 恢复Storage
        if session.local_storage:
            await page.evaluate("""
                (data) => {
                    for (const [key, value] of Object.entries(data)) {
                        localStorage.setItem(key, value);
                    }
                }
            """, session.local_storage)

        return browser, context, page

    async def _wait_for_login(self, page, platform: str):
        """等待登录成功"""
        login_success_indicators = {
            "xiaohongshu": {"url_pattern": "**/home**", "timeout": 180000},
            "douyin": {"url_pattern": "**/creator**", "timeout": 180000},
            "weibo": {"url_pattern": "**/home**", "timeout": 180000},
        }

        indicator = login_success_indicators.get(platform, {
            "url_pattern": "**/home**",
            "timeout": 180000
        })

        await page.wait_for_url(indicator["url_pattern"], timeout=indicator["timeout"])

    def _get_stealth_script(self, fingerprint: BrowserFingerprint) -> str:
        """生成反检测脚本"""
        return f"""
        // 隐藏webdriver标志
        Object.defineProperty(navigator, 'webdriver', {{
            get: () => undefined
        }});

        // 修改navigator.plugins
        Object.defineProperty(navigator, 'plugins', {{
            get: () => [
                {{ name: 'Chrome PDF Plugin' }},
                {{ name: 'Chrome PDF Viewer' }},
                {{ name: 'Native Client' }}
            ]
        }});

        // 修改navigator.languages
        Object.defineProperty(navigator, 'languages', {{
            get: () => ['{fingerprint.language}', 'en-US', 'en']
        }});

        // 修改navigator.platform
        Object.defineProperty(navigator, 'platform', {{
            get: () => '{fingerprint.platform}'
        }});

        // 修改屏幕信息
        Object.defineProperty(screen, 'width', {{ get: () => {fingerprint.screen_width} }});
        Object.defineProperty(screen, 'height', {{ get: () => {fingerprint.screen_height} }});

        // WebGL指纹
        const getParameter = WebGLRenderingContext.prototype.getParameter;
        WebGLRenderingContext.prototype.getParameter = function(parameter) {{
            if (parameter === 37445) return '{fingerprint.webgl_vendor}';
            if (parameter === 37446) return '{fingerprint.webgl_renderer}';
            return getParameter.call(this, parameter);
        }};

        // 隐藏自动化特征
        delete window.cdc_adoQpoasnfa76pfcZLmcfl_Array;
        delete window.cdc_adoQpoasnfa76pfcZLmcfl_Promise;

        // Chrome特有属性
        window.chrome = {{
            runtime: {{}},
            loadTimes: function() {{}},
            csi: function() {{}},
            app: {{}}
        }};
        """

    async def _save_session(self, session: SessionData):
        """加密保存会话"""
        path = self._get_session_path(session.platform, session.account_id)
        path.parent.mkdir(parents=True, exist_ok=True)

        data = {
            "cookies": session.cookies,
            "local_storage": session.local_storage,
            "session_storage": session.session_storage,
            "fingerprint": session.fingerprint.to_dict(),
            "created_at": session.created_at,
            "platform": session.platform,
            "account_id": session.account_id
        }

        encrypted = encrypt_data(json.dumps(data))
        path.write_bytes(encrypted)

    async def _load_session(self, platform: str, account_id: str) -> Optional[SessionData]:
        """加载会话"""
        path = self._get_session_path(platform, account_id)
        if not path.exists():
            return None

        encrypted = path.read_bytes()
        data = json.loads(decrypt_data(encrypted))

        return SessionData(
            cookies=data["cookies"],
            local_storage=data["local_storage"],
            session_storage=data["session_storage"],
            fingerprint=BrowserFingerprint(**data["fingerprint"]),
            created_at=data["created_at"],
            platform=data["platform"],
            account_id=data["account_id"]
        )
```

#### 10.1.4 AI浏览器操作器

```python
# python-sidecar/src/automation/browser/ai_operator.py
"""AI操作器 - 使用Claude控制浏览器"""
from anthropic import Anthropic
from playwright.async_api import Page
import base64

class AIBrowserOperator:
    """AI驱动的浏览器操作器"""

    def __init__(self, api_key: str):
        self.client = Anthropic(api_key=api_key)

    async def execute_task(
        self,
        page: Page,
        task_description: str,
        context: dict = None
    ) -> dict:
        """使用AI执行浏览器任务"""

        tools = [
            {
                "name": "click",
                "description": "点击页面上的元素",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "selector": {"type": "string", "description": "CSS选择器或文本"},
                        "method": {"type": "string", "enum": ["css", "text", "role"]}
                    },
                    "required": ["selector"]
                }
            },
            {
                "name": "type_text",
                "description": "在输入框中输入文本",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "selector": {"type": "string"},
                        "text": {"type": "string"},
                        "clear_first": {"type": "boolean", "default": True}
                    },
                    "required": ["selector", "text"]
                }
            },
            {
                "name": "upload_file",
                "description": "上传文件",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "selector": {"type": "string"},
                        "file_paths": {"type": "array", "items": {"type": "string"}}
                    },
                    "required": ["selector", "file_paths"]
                }
            },
            {
                "name": "screenshot",
                "description": "截取当前页面截图",
                "input_schema": {"type": "object", "properties": {}}
            },
            {
                "name": "wait",
                "description": "等待元素或时间",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "seconds": {"type": "number"},
                        "selector": {"type": "string"}
                    }
                }
            },
            {
                "name": "task_complete",
                "description": "标记任务完成",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "success": {"type": "boolean"},
                        "message": {"type": "string"},
                        "result": {"type": "object"}
                    },
                    "required": ["success", "message"]
                }
            }
        ]

        # 初始截图
        screenshot = await self._take_screenshot(page)

        system_prompt = """你是一个专业的浏览器自动化操作助手。
操作原则：
1. 每次操作前先截图查看当前页面状态
2. 使用精确的选择器定位元素
3. 操作后等待页面响应
4. 完成任务后调用task_complete"""

        messages = [
            {
                "role": "user",
                "content": [
                    {"type": "image", "source": {"type": "base64", "media_type": "image/png", "data": screenshot}},
                    {"type": "text", "text": f"任务：{task_description}\n\n上下文：{context}"}
                ]
            }
        ]

        max_iterations = 20
        for _ in range(max_iterations):
            response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=4096,
                system=system_prompt,
                tools=tools,
                messages=messages
            )

            # 处理工具调用
            for block in response.content:
                if block.type == "tool_use":
                    result = await self._execute_tool(page, block.name, block.input)
                    if block.name == "task_complete":
                        return result

            messages.append({"role": "assistant", "content": response.content})

        return {"success": False, "message": "超过最大迭代次数"}

    async def _execute_tool(self, page: Page, name: str, params: dict):
        """执行工具"""
        try:
            if name == "click":
                method = params.get("method", "css")
                if method == "text":
                    await page.get_by_text(params["selector"]).click()
                else:
                    await page.click(params["selector"])
                return "点击成功"

            elif name == "type_text":
                if params.get("clear_first", True):
                    await page.fill(params["selector"], params["text"])
                else:
                    await page.type(params["selector"], params["text"])
                return "输入成功"

            elif name == "upload_file":
                await page.set_input_files(params["selector"], params["file_paths"])
                return "上传成功"

            elif name == "screenshot":
                return await self._take_screenshot(page)

            elif name == "wait":
                if params.get("selector"):
                    await page.wait_for_selector(params["selector"])
                elif params.get("seconds"):
                    await page.wait_for_timeout(params["seconds"] * 1000)
                return "等待完成"

            elif name == "task_complete":
                return params

        except Exception as e:
            return f"操作失败: {str(e)}"

    async def _take_screenshot(self, page: Page) -> str:
        """截图并返回base64"""
        screenshot_bytes = await page.screenshot(type="png")
        return base64.b64encode(screenshot_bytes).decode()
```

### 10.2 平台风控风险详解

#### 10.2.1 风险类型矩阵

| 风险类型 | 严重程度 | 触发条件 | 后果 | 恢复难度 |
|----------|----------|----------|------|----------|
| **账号封禁** | 🔴 致命 | 被检测到自动化行为 | 账号永久封禁 | 不可恢复 |
| **临时限流** | 🟡 中等 | 发布频率过高 | 24-72小时限制 | 自动恢复 |
| **验证码拦截** | 🟡 中等 | 行为异常触发 | 需人工介入 | 立即恢复 |
| **设备锁定** | 🟠 较高 | 设备指纹异常 | 需重新验证设备 | 数小时 |
| **内容审核** | 🟡 中等 | 敏感词/违规内容 | 内容被删除 | 修改后重发 |
| **IP封禁** | 🟠 较高 | 同IP大量异常请求 | IP被拉黑 | 更换IP |

#### 10.2.2 各平台风控特点

| 平台 | 风控强度 | 主要检测手段 | 封禁概率 | 备注 |
|------|----------|--------------|----------|------|
| **小红书** | 🔴 高 | 设备指纹+行为分析+内容审核 | 高 | 对自动化敏感 |
| **抖音** | 🔴 高 | 设备指纹+视频指纹+行为分析 | 高 | 字节风控强 |
| **微信公众号** | 🟡 中 | IP+频率+内容 | 中 | 有官方API |
| **微博** | 🟡 中 | 频率+内容+设备 | 中 | 相对宽松 |
| **B站** | 🟡 中 | 视频指纹+行为 | 中 | 视频审核严 |
| **知乎** | 🟠 中高 | 内容质量+行为 | 中高 | 内容审核严 |

### 10.3 技术风险详解

```yaml
Cookie失效:
  频率: 高 (1-7天)
  影响: 需要重新登录
  缓解措施:
    - 定期检测会话有效性（每6小时）
    - 自动提醒用户重新绑定
    - 模拟正常访问刷新Cookie

指纹检测升级:
  频率: 中 (平台定期更新)
  影响: 自动化被识别
  缓解措施:
    - 持续更新反检测脚本
    - 使用真实浏览器内核
    - 保持指纹一致性
    - 监控检测库更新

页面结构变化:
  频率: 中高 (平台频繁改版)
  影响: 选择器失效
  缓解措施:
    - AI操作自适应页面变化
    - 多种选择器备选策略
    - 快速响应更新机制

IP风控:
  频率: 中
  影响: 触发验证或封禁
  缓解措施:
    - 使用用户本地IP（端侧运行）
    - 避免频繁切换IP
    - 控制请求频率
```

### 10.4 法律合规风险

| 风险 | 说明 | 严重程度 | 建议措施 |
|------|------|----------|----------|
| **违反平台TOS** | 大多数平台禁止自动化操作 | 🟡 中 | 用户协议明确声明风险 |
| **数据安全责任** | 存储用户凭证的安全责任 | 🔴 高 | 端到端加密、本地存储 |
| **隐私保护** | 设备指纹涉及隐私 | 🟡 中 | 明确告知、获取同意 |
| **不正当竞争** | 可能被认定为不正当竞争 | 🟠 中高 | 法律咨询、合规审查 |

### 10.5 风险缓解措施实现

#### 10.5.1 真人行为模拟

```python
# python-sidecar/src/automation/browser/human_behavior.py
import random
import asyncio
from playwright.async_api import Page

class HumanBehaviorSimulator:
    """模拟真人行为，降低被检测风险"""

    @staticmethod
    async def human_type(page: Page, selector: str, text: str):
        """模拟人类打字速度"""
        element = page.locator(selector)
        await element.click()

        for char in text:
            # 随机打字速度：50-150ms
            await element.type(char, delay=random.randint(50, 150))
            # 10%概率暂停思考
            if random.random() < 0.1:
                await asyncio.sleep(random.uniform(0.3, 0.8))

    @staticmethod
    async def human_click(page: Page, selector: str):
        """模拟人类点击（带随机偏移）"""
        element = page.locator(selector)
        box = await element.bounding_box()

        if box:
            # 在元素范围内随机点击位置
            x = box['x'] + random.uniform(box['width'] * 0.2, box['width'] * 0.8)
            y = box['y'] + random.uniform(box['height'] * 0.2, box['height'] * 0.8)

            # 随机延迟后点击
            await asyncio.sleep(random.uniform(0.1, 0.3))
            await page.mouse.click(x, y)

    @staticmethod
    async def random_mouse_movement(page: Page):
        """随机鼠标移动，模拟浏览行为"""
        for _ in range(random.randint(2, 5)):
            x = random.randint(100, 1000)
            y = random.randint(100, 700)
            await page.mouse.move(x, y, steps=random.randint(5, 15))
            await asyncio.sleep(random.uniform(0.1, 0.3))

    @staticmethod
    async def random_scroll(page: Page):
        """随机滚动页面"""
        scroll_amount = random.randint(100, 400)
        await page.mouse.wheel(0, scroll_amount)
        await asyncio.sleep(random.uniform(0.5, 1.5))

    @staticmethod
    async def simulate_reading(page: Page, content_length: int):
        """模拟阅读行为"""
        # 根据内容长度计算阅读时间
        reading_time = max(2, content_length / 500)  # 假设500字/秒
        reading_time = min(reading_time, 30)  # 最多30秒

        # 分段滚动阅读
        scroll_times = random.randint(2, 5)
        for _ in range(scroll_times):
            await HumanBehaviorSimulator.random_scroll(page)
            await asyncio.sleep(reading_time / scroll_times)
```

#### 10.5.2 会话健康检查

```python
# python-sidecar/src/automation/browser/session_health.py
from datetime import datetime, timedelta
from typing import Optional

class SessionHealthChecker:
    """会话健康检查"""

    # 平台会话检查配置
    PLATFORM_CONFIG = {
        "xiaohongshu": {
            "check_url": "https://creator.xiaohongshu.com/home",
            "login_indicator": "login",
            "valid_indicator": ".user-info",
            "max_age_hours": 24
        },
        "douyin": {
            "check_url": "https://creator.douyin.com/creator-micro/home",
            "login_indicator": "login",
            "valid_indicator": ".user-avatar",
            "max_age_hours": 48
        },
        "weibo": {
            "check_url": "https://weibo.com/home",
            "login_indicator": "login",
            "valid_indicator": ".user-name",
            "max_age_hours": 72
        }
    }

    async def check_session_valid(
        self,
        platform: str,
        account_id: str
    ) -> dict:
        """检查会话是否有效"""
        from .session_manager import SessionManager

        session_manager = SessionManager()
        config = self.PLATFORM_CONFIG.get(platform, {})

        try:
            browser, context, page = await session_manager.create_authenticated_context(
                platform, account_id, headless=True
            )

            await page.goto(config.get("check_url", ""))

            # 检查是否被重定向到登录页
            current_url = page.url
            if config.get("login_indicator", "login") in current_url.lower():
                await browser.close()
                return {
                    "valid": False,
                    "reason": "session_expired",
                    "message": "会话已过期，请重新绑定账号"
                }

            # 检查有效性指示器
            try:
                await page.wait_for_selector(
                    config.get("valid_indicator", ".user"),
                    timeout=5000
                )
            except:
                await browser.close()
                return {
                    "valid": False,
                    "reason": "session_invalid",
                    "message": "会话无效"
                }

            await browser.close()
            return {"valid": True, "message": "会话有效"}

        except Exception as e:
            return {
                "valid": False,
                "reason": "check_failed",
                "message": str(e)
            }

    async def should_refresh_session(
        self,
        platform: str,
        session_created_at: str
    ) -> bool:
        """判断是否需要刷新会话"""
        config = self.PLATFORM_CONFIG.get(platform, {})
        max_age = config.get("max_age_hours", 24)

        created = datetime.fromisoformat(session_created_at)
        age = datetime.utcnow() - created

        return age > timedelta(hours=max_age)
```

#### 10.5.3 发布频率控制

```python
# python-sidecar/src/automation/rate_limiter.py
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Tuple

class RateLimiter:
    """发布频率控制 - 避免触发平台风控"""

    # 平台安全发布频率限制（保守策略：低于实际限制的50%）
    SAFE_LIMITS = {
        "xiaohongshu": {
            "daily": 5,           # 每天最多5篇
            "hourly": 2,          # 每小时最多2篇
            "min_interval": 1800, # 最小间隔30分钟
        },
        "douyin": {
            "daily": 3,
            "hourly": 1,
            "min_interval": 3600,  # 最小间隔1小时
        },
        "weibo": {
            "daily": 10,
            "hourly": 3,
            "min_interval": 600,   # 最小间隔10分钟
        },
        "bilibili": {
            "daily": 3,
            "hourly": 1,
            "min_interval": 3600,
        },
        "zhihu": {
            "daily": 5,
            "hourly": 2,
            "min_interval": 1200,  # 最小间隔20分钟
        },
    }

    def __init__(self):
        # 记录发布历史 {platform:account_id: [timestamps]}
        self.publish_history = defaultdict(list)

    def can_publish(self, platform: str, account_id: str) -> Tuple[bool, str]:
        """检查是否可以发布"""
        limits = self.SAFE_LIMITS.get(platform, {
            "daily": 5,
            "hourly": 2,
            "min_interval": 1800
        })

        now = datetime.utcnow()
        key = f"{platform}:{account_id}"

        # 清理24小时前的记录
        self.publish_history[key] = [
            t for t in self.publish_history[key]
            if now - t < timedelta(hours=24)
        ]

        history = self.publish_history[key]

        # 检查日限制
        if len(history) >= limits["daily"]:
            return False, f"已达到每日发布上限 ({limits['daily']}篇)"

        # 检查小时限制
        hour_ago = now - timedelta(hours=1)
        recent_hour = [t for t in history if t > hour_ago]
        if len(recent_hour) >= limits["hourly"]:
            return False, f"已达到每小时发布上限 ({limits['hourly']}篇)"

        # 检查最小间隔
        if history:
            last_publish = max(history)
            seconds_since_last = (now - last_publish).total_seconds()
            if seconds_since_last < limits["min_interval"]:
                wait_time = limits["min_interval"] - seconds_since_last
                return False, f"请等待 {int(wait_time/60)} 分钟后再发布"

        return True, "可以发布"

    def record_publish(self, platform: str, account_id: str):
        """记录发布操作"""
        key = f"{platform}:{account_id}"
        self.publish_history[key].append(datetime.utcnow())

    def get_next_available_time(self, platform: str, account_id: str) -> datetime:
        """获取下次可发布时间"""
        can_pub, msg = self.can_publish(platform, account_id)
        if can_pub:
            return datetime.utcnow()

        limits = self.SAFE_LIMITS.get(platform, {"min_interval": 1800})
        key = f"{platform}:{account_id}"
        history = self.publish_history.get(key, [])

        if history:
            last_publish = max(history)
            return last_publish + timedelta(seconds=limits["min_interval"])

        return datetime.utcnow()
```

### 10.6 风险等级总结

| 方面 | 风险等级 | 可控性 | 建议 |
|------|----------|--------|------|
| **技术实现** | 🟢 低 | 高 | 完全可行，技术成熟 |
| **账号安全** | 🟡 中 | 高 | 本地加密存储，不上传云端 |
| **平台风控** | 🟠 中高 | 中 | 模拟真人行为+频率控制 |
| **法律合规** | 🟡 中 | 高 | 用户协议声明+优先官方API |
| **长期维护** | 🟠 中高 | 中 | 需持续更新适配 |

### 10.7 核心建议

1. **用户知情同意**
   - 明确告知用户使用自动化发布的风险
   - 在用户协议中声明责任边界

2. **本地优先原则**
   - 所有凭证只存本地，不上传云端
   - 端到端加密存储敏感信息

3. **保守发布策略**
   - 发布频率控制在平台限制的50%以下
   - 增加随机延迟和真人行为模拟

4. **官方API优先**
   - 有官方API的平台优先使用API
   - 浏览器自动化作为备选方案

5. **快速响应机制**
   - 建立平台变化的监控机制
   - 保持适配器的快速更新能力

6. **分级风控策略**
   - 新账号使用更保守的策略
   - 根据账号等级调整发布频率

### 10.8 其他技术风险

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Python Sidecar打包复杂 | 高 | 使用PyInstaller/Nuitka，充分测试 |
| Playwright稳定性 | 中 | 完善重试机制，多浏览器备选 |
| 跨平台兼容性 | 中 | CI/CD多平台测试 |

### 10.9 待验证技术点

1. **Python Sidecar打包分发**
   - Windows/macOS/Linux的Python环境打包
   - 依赖管理和体积优化

2. **Playwright跨平台稳定性**
   - 各平台浏览器自动化的稳定性
   - Headless模式下的兼容性

3. **各平台登录态维护**
   - Cookie有效期和刷新机制
   - 风控应对策略

4. **AI操作器准确性**
   - Claude视觉识别页面元素的准确率
   - 复杂页面的操作成功率

---

## 附录

### A. 相关链接

- [Tauri 2.0 文档](https://v2.tauri.app/)
- [Claude Agent SDK](https://docs.anthropic.com/claude/docs/agent-sdk)
- [LangGraph 文档](https://langchain-ai.github.io/langgraph/)
- [Playwright 文档](https://playwright.dev/python/)

### B. 参考竞品

- 蚁小二
- 融媒宝
- 易撰
- 5118

### C. 术语表

| 术语 | 说明 |
|------|------|
| Sidecar | Tauri中的外部进程，这里指Python运行时 |
| JSON-RPC | 轻量级远程过程调用协议 |
| Agent | AI代理，能够自主执行任务的AI系统 |
| RAG | 检索增强生成，结合知识库的AI生成技术 |

---

*文档最后更新: 2025-12-23*
