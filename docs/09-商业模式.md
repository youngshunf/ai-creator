# AI Creator - 商业模式

> 订阅制SaaS商业化设计

## 1. 商业模式概述

### 1.1 核心定位

**自媒体创作者的AI生产力工具** - 通过AI技术提升内容创作效率

### 1.2 收入模式

```yaml
主要收入:
  - 订阅收入: 月/年订阅费 (核心收入，占比70%+)
  - 增值服务: 额外配额、高级功能

辅助收入:
  - API服务: 面向MCN/企业的API调用
  - 定制服务: 企业定制化需求

成本结构:
  - AI API成本: Claude API调用费用 (主要成本)
  - 基础设施: 服务器、存储、带宽
  - 人力成本: 研发、运营、客服
```

---

## 2. 订阅层级设计

### 2.1 层级概览

| 层级 | 月费 | 年费 | 目标用户 |
|------|------|------|----------|
| **Free** | ¥0 | ¥0 | 体验用户、轻度用户 |
| **Basic** | ¥49 | ¥468 (8折) | 个人创作者入门 |
| **Pro** | ¥149 | ¥1,428 (8折) | 专业创作者 |
| **Enterprise** | 定制 | 定制 | MCN/企业团队 |

### 2.2 功能对比

```yaml
Free (免费版):
  AI创作:
    - 每日创作次数: 5次
    - 单次最大字数: 1000字
    - 可用模型: Claude Haiku (基础模型)
  发布:
    - 每日发布次数: 3次
    - 支持平台: 2个
    - 定时发布: ❌
  数据:
    - 数据保留: 7天
    - 数据分析: 基础报表
  存储:
    - 素材存储: 100MB
  其他:
    - 云端同步: ❌
    - 移动端: ❌
    - 技术支持: 社区

Basic (基础版 - ¥49/月):
  AI创作:
    - 每日创作次数: 30次
    - 单次最大字数: 3000字
    - 可用模型: Claude Sonnet
    - AI配图: 10张/天
  发布:
    - 每日发布次数: 20次
    - 支持平台: 5个
    - 定时发布: ✅
    - 批量发布: ❌
  数据:
    - 数据保留: 30天
    - 数据分析: 标准报表
    - 数据导出: ✅
  存储:
    - 素材存储: 2GB
  其他:
    - 云端同步: ✅
    - 移动端: ✅
    - 技术支持: 邮件 (48h响应)
    - 平台账号: 5个

Pro (专业版 - ¥149/月):
  AI创作:
    - 每日创作次数: 100次
    - 单次最大字数: 10000字
    - 可用模型: Claude Sonnet + Opus
    - AI配图: 50张/天
    - 视频脚本: ✅
  发布:
    - 每日发布次数: 100次
    - 支持平台: 全部
    - 定时发布: ✅
    - 批量发布: ✅
    - 智能排期: ✅
  数据:
    - 数据保留: 365天
    - 数据分析: 高级分析
    - 竞品分析: ✅
    - AI选题: ✅
    - 数据导出: ✅
  存储:
    - 素材存储: 20GB
  其他:
    - 云端同步: ✅
    - 移动端: ✅
    - 技术支持: 优先支持 (24h响应)
    - 平台账号: 20个
    - API访问: ✅

Enterprise (企业版 - 定制):
  AI创作:
    - 创作次数: 不限
    - 字数限制: 不限
    - 可用模型: 全部 + 私有部署
    - AI配图: 不限
    - 自定义工作流: ✅
  发布:
    - 发布次数: 不限
    - 支持平台: 全部 + 定制
    - 团队协作: ✅
    - 审批流程: ✅
  数据:
    - 数据保留: 永久
    - 专属数据分析师: ✅
    - BI集成: ✅
  存储:
    - 素材存储: 不限
    - 私有部署: 可选
  其他:
    - 专属客户经理: ✅
    - SLA保障: 99.9%
    - 培训服务: ✅
    - 定制开发: ✅
    - 平台账号: 不限
```

---

## 3. 配额系统

### 3.1 配额设计

```python
# backend/app/models/quota.py
from dataclasses import dataclass
from enum import Enum

class QuotaType(str, Enum):
    """配额类型"""
    AI_CREATION = "ai_creation"      # AI创作次数
    AI_TOKENS = "ai_tokens"          # AI Token消耗
    PUBLISH = "publish"              # 发布次数
    IMAGE_GEN = "image_gen"          # 图片生成
    STORAGE = "storage"              # 存储空间
    PLATFORM_ACCOUNTS = "accounts"   # 平台账号数

@dataclass
class QuotaConfig:
    """配额配置"""
    tier: str
    quotas: dict[QuotaType, int]

# 配额配置表
QUOTA_CONFIGS = {
    "free": QuotaConfig(
        tier="free",
        quotas={
            QuotaType.AI_CREATION: 5,         # 次/天
            QuotaType.AI_TOKENS: 50000,       # tokens/天
            QuotaType.PUBLISH: 3,             # 次/天
            QuotaType.IMAGE_GEN: 0,           # 次/天
            QuotaType.STORAGE: 100,           # MB
            QuotaType.PLATFORM_ACCOUNTS: 2,   # 个
        }
    ),
    "basic": QuotaConfig(
        tier="basic",
        quotas={
            QuotaType.AI_CREATION: 30,
            QuotaType.AI_TOKENS: 500000,
            QuotaType.PUBLISH: 20,
            QuotaType.IMAGE_GEN: 10,
            QuotaType.STORAGE: 2048,
            QuotaType.PLATFORM_ACCOUNTS: 5,
        }
    ),
    "pro": QuotaConfig(
        tier="pro",
        quotas={
            QuotaType.AI_CREATION: 100,
            QuotaType.AI_TOKENS: 2000000,
            QuotaType.PUBLISH: 100,
            QuotaType.IMAGE_GEN: 50,
            QuotaType.STORAGE: 20480,
            QuotaType.PLATFORM_ACCOUNTS: 20,
        }
    ),
    "enterprise": QuotaConfig(
        tier="enterprise",
        quotas={
            QuotaType.AI_CREATION: -1,        # -1 表示不限
            QuotaType.AI_TOKENS: -1,
            QuotaType.PUBLISH: -1,
            QuotaType.IMAGE_GEN: -1,
            QuotaType.STORAGE: -1,
            QuotaType.PLATFORM_ACCOUNTS: -1,
        }
    ),
}
```

### 3.2 配额服务

```python
# backend/app/services/quota_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime, date
from ..models.user import User
from ..models.quota import QuotaUsage, QuotaType

class QuotaService:
    """配额管理服务"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def check_quota(
        self,
        user_id: str,
        quota_type: QuotaType,
        amount: int = 1
    ) -> bool:
        """检查配额是否足够"""
        user = await self.db.get(User, user_id)
        config = QUOTA_CONFIGS[user.subscription_tier]

        limit = config.quotas[quota_type]
        if limit == -1:  # 不限
            return True

        # 获取今日使用量
        today_usage = await self._get_today_usage(user_id, quota_type)

        return today_usage + amount <= limit

    async def consume_quota(
        self,
        user_id: str,
        quota_type: QuotaType,
        amount: int = 1,
        metadata: dict = None
    ) -> bool:
        """消费配额"""
        if not await self.check_quota(user_id, quota_type, amount):
            return False

        # 记录使用
        usage = QuotaUsage(
            user_id=user_id,
            quota_type=quota_type,
            amount=amount,
            date=date.today(),
            metadata=metadata or {}
        )
        self.db.add(usage)
        await self.db.commit()

        return True

    async def get_quota_status(self, user_id: str) -> dict:
        """获取用户配额状态"""
        user = await self.db.get(User, user_id)
        config = QUOTA_CONFIGS[user.subscription_tier]

        status = {}
        for quota_type, limit in config.quotas.items():
            used = await self._get_today_usage(user_id, quota_type)
            status[quota_type.value] = {
                "limit": limit,
                "used": used,
                "remaining": limit - used if limit != -1 else -1,
                "unlimited": limit == -1
            }

        return status

    async def _get_today_usage(
        self,
        user_id: str,
        quota_type: QuotaType
    ) -> int:
        """获取今日使用量"""
        result = await self.db.execute(
            select(func.sum(QuotaUsage.amount))
            .where(
                QuotaUsage.user_id == user_id,
                QuotaUsage.quota_type == quota_type,
                QuotaUsage.date == date.today()
            )
        )
        return result.scalar() or 0
```

---

## 4. 支付系统

### 4.1 支付渠道

```yaml
国内支付:
  - 支付宝: 扫码支付、手机网站支付
  - 微信支付: Native支付、H5支付
  - 银联云闪付: 可选

企业支付:
  - 对公转账
  - 发票开具

支付流程:
  1. 选择套餐 → 生成订单
  2. 选择支付方式 → 跳转支付
  3. 支付成功 → 回调更新
  4. 发送确认 → 开通服务
```

### 4.2 订单模型

```python
# backend/app/models/order.py
from sqlalchemy import Column, String, Integer, Numeric, ForeignKey, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID
from .base import BaseModel
from enum import Enum
from decimal import Decimal

class OrderStatus(str, Enum):
    """订单状态"""
    PENDING = "pending"       # 待支付
    PAID = "paid"             # 已支付
    CANCELLED = "cancelled"   # 已取消
    REFUNDED = "refunded"     # 已退款
    EXPIRED = "expired"       # 已过期

class PaymentMethod(str, Enum):
    """支付方式"""
    ALIPAY = "alipay"
    WECHAT = "wechat"
    UNIONPAY = "unionpay"
    TRANSFER = "transfer"     # 对公转账

class Order(BaseModel):
    """订单表"""
    __tablename__ = "orders"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 订单信息
    order_no = Column(String(64), unique=True, nullable=False, index=True)
    status = Column(SQLEnum(OrderStatus), default=OrderStatus.PENDING)

    # 商品信息
    product_type = Column(String(50), nullable=False)  # subscription, addon
    product_id = Column(String(50), nullable=False)    # basic_monthly, pro_yearly
    product_name = Column(String(255), nullable=False)

    # 金额
    original_price = Column(Numeric(10, 2), nullable=False)  # 原价
    discount_amount = Column(Numeric(10, 2), default=0)      # 优惠金额
    final_price = Column(Numeric(10, 2), nullable=False)     # 实付金额

    # 优惠券
    coupon_id = Column(UUID(as_uuid=True), nullable=True)
    coupon_code = Column(String(50), nullable=True)

    # 支付
    payment_method = Column(SQLEnum(PaymentMethod), nullable=True)
    paid_at = Column(DateTime, nullable=True)
    transaction_id = Column(String(255), nullable=True)  # 第三方交易号

    # 订阅信息
    subscription_months = Column(Integer, nullable=True)  # 订阅月数
    subscription_start = Column(DateTime, nullable=True)
    subscription_end = Column(DateTime, nullable=True)

    # 发票
    invoice_requested = Column(Boolean, default=False)
    invoice_info = Column(JSON, nullable=True)


class Subscription(BaseModel):
    """订阅记录表"""
    __tablename__ = "subscriptions"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    order_id = Column(UUID(as_uuid=True), ForeignKey("orders.id"), nullable=False)

    # 订阅信息
    tier = Column(String(50), nullable=False)  # basic, pro, enterprise
    status = Column(String(50), nullable=False)  # active, expired, cancelled

    # 时间
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime, nullable=False)

    # 自动续费
    auto_renew = Column(Boolean, default=False)
    next_billing_date = Column(DateTime, nullable=True)
```

### 4.3 支付服务

```python
# backend/app/services/payment_service.py
from decimal import Decimal
from datetime import datetime, timedelta
from ..models.order import Order, OrderStatus, Subscription

class PaymentService:
    """支付服务"""

    # 产品价格配置
    PRODUCTS = {
        "basic_monthly": {
            "name": "Basic月度订阅",
            "tier": "basic",
            "price": Decimal("49.00"),
            "months": 1,
        },
        "basic_yearly": {
            "name": "Basic年度订阅",
            "tier": "basic",
            "price": Decimal("468.00"),
            "months": 12,
        },
        "pro_monthly": {
            "name": "Pro月度订阅",
            "tier": "pro",
            "price": Decimal("149.00"),
            "months": 1,
        },
        "pro_yearly": {
            "name": "Pro年度订阅",
            "tier": "pro",
            "price": Decimal("1428.00"),
            "months": 12,
        },
    }

    async def create_order(
        self,
        user_id: str,
        product_id: str,
        coupon_code: str = None,
    ) -> Order:
        """创建订单"""
        product = self.PRODUCTS[product_id]

        # 计算价格
        original_price = product["price"]
        discount_amount = Decimal("0")

        if coupon_code:
            discount_amount = await self._calculate_discount(
                coupon_code, original_price
            )

        final_price = original_price - discount_amount

        # 生成订单号
        order_no = self._generate_order_no()

        order = Order(
            user_id=user_id,
            order_no=order_no,
            product_type="subscription",
            product_id=product_id,
            product_name=product["name"],
            original_price=original_price,
            discount_amount=discount_amount,
            final_price=final_price,
            coupon_code=coupon_code,
            subscription_months=product["months"],
        )

        self.db.add(order)
        await self.db.commit()

        return order

    async def handle_payment_callback(
        self,
        order_no: str,
        transaction_id: str,
        payment_method: str,
    ) -> bool:
        """处理支付回调"""
        order = await self._get_order_by_no(order_no)

        if order.status != OrderStatus.PENDING:
            return False

        # 更新订单状态
        order.status = OrderStatus.PAID
        order.paid_at = datetime.utcnow()
        order.transaction_id = transaction_id
        order.payment_method = payment_method

        # 计算订阅时间
        product = self.PRODUCTS[order.product_id]
        start_date = datetime.utcnow()
        end_date = start_date + timedelta(days=30 * product["months"])

        order.subscription_start = start_date
        order.subscription_end = end_date

        # 创建订阅记录
        subscription = Subscription(
            user_id=order.user_id,
            order_id=order.id,
            tier=product["tier"],
            status="active",
            start_date=start_date,
            end_date=end_date,
        )
        self.db.add(subscription)

        # 更新用户订阅状态
        user = await self.db.get(User, order.user_id)
        user.subscription_tier = product["tier"]
        user.subscription_expires_at = end_date

        await self.db.commit()

        # 发送通知
        await self._send_payment_notification(order, subscription)

        return True

    def _generate_order_no(self) -> str:
        """生成订单号"""
        import time
        import random
        timestamp = int(time.time() * 1000)
        random_suffix = random.randint(1000, 9999)
        return f"ORD{timestamp}{random_suffix}"
```

---

## 5. 增值服务

### 5.1 配额加油包

```yaml
加油包产品:
  ai_pack_small:
    名称: AI创作包(小)
    内容: 50次AI创作
    价格: ¥19
    有效期: 30天

  ai_pack_large:
    名称: AI创作包(大)
    内容: 200次AI创作
    价格: ¥59
    有效期: 30天

  image_pack:
    名称: AI配图包
    内容: 100张AI配图
    价格: ¥29
    有效期: 30天

  storage_pack:
    名称: 存储扩容包
    内容: 10GB存储空间
    价格: ¥19/月
    类型: 月付
```

### 5.2 企业API服务

```yaml
API定价:
  调用费用:
    - AI创作: ¥0.1/次 (含1000 tokens)
    - 超额Token: ¥0.02/1K tokens
    - 图片生成: ¥0.3/张
    - 发布: ¥0.05/次

  月度套餐:
    starter:
      价格: ¥499/月
      包含: 5000次AI调用
      超额: 标准价格

    growth:
      价格: ¥1999/月
      包含: 25000次AI调用
      超额: 8折

    scale:
      价格: ¥4999/月
      包含: 100000次AI调用
      超额: 6折
```

---

## 6. 优惠策略

### 6.1 优惠券系统

```python
# backend/app/models/coupon.py
from sqlalchemy import Column, String, Integer, Numeric, DateTime, Boolean
from sqlalchemy.dialects.postgresql import UUID
from .base import BaseModel
from enum import Enum

class DiscountType(str, Enum):
    """折扣类型"""
    PERCENTAGE = "percentage"  # 百分比折扣
    FIXED = "fixed"            # 固定金额

class Coupon(BaseModel):
    """优惠券表"""
    __tablename__ = "coupons"

    # 基本信息
    code = Column(String(50), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)

    # 折扣
    discount_type = Column(SQLEnum(DiscountType), nullable=False)
    discount_value = Column(Numeric(10, 2), nullable=False)  # 折扣值
    min_amount = Column(Numeric(10, 2), default=0)           # 最低消费

    # 适用范围
    applicable_products = Column(ARRAY(String), default=[])   # 空表示全部适用
    applicable_tiers = Column(ARRAY(String), default=[])      # 适用用户层级

    # 使用限制
    total_limit = Column(Integer, nullable=True)              # 总发放数量
    per_user_limit = Column(Integer, default=1)               # 每用户限用次数
    used_count = Column(Integer, default=0)                   # 已使用次数

    # 有效期
    valid_from = Column(DateTime, nullable=False)
    valid_until = Column(DateTime, nullable=False)

    # 状态
    is_active = Column(Boolean, default=True)
```

### 6.2 促销活动

```yaml
常规促销:
  新用户专享:
    - 首月5折
    - 首年7折
    - 7天Pro试用

  节日促销:
    - 双11: 年付6折
    - 618: 年付7折
    - 春节: 赠送1个月

  推荐奖励:
    推荐人: 获得30天Pro
    被推荐人: 首月7折

会员日:
  每月8号:
    - Pro用户: 双倍配额
    - 所有用户: 限时优惠
```

---

## 7. 运营指标

### 7.1 核心指标

```yaml
用户指标:
  DAU: 日活跃用户
  MAU: 月活跃用户
  新增用户: 每日/每周/每月
  留存率: 次日/7日/30日

收入指标:
  MRR: 月度经常性收入
  ARR: 年度经常性收入
  ARPU: 每用户平均收入
  LTV: 用户生命周期价值

转化指标:
  注册转化率: 访客 → 注册
  付费转化率: 注册 → 付费
  升级率: Basic → Pro
  续费率: 到期续费比例

使用指标:
  功能使用率: 各功能使用比例
  AI调用量: 日均AI调用次数
  发布量: 日均发布次数
  配额使用率: 配额消耗比例
```

### 7.2 监控告警

```python
# backend/app/services/metrics_service.py

class MetricsService:
    """运营指标服务"""

    async def calculate_mrr(self) -> Decimal:
        """计算MRR"""
        result = await self.db.execute(
            select(func.sum(Order.final_price / Order.subscription_months))
            .join(Subscription)
            .where(Subscription.status == "active")
        )
        return result.scalar() or Decimal("0")

    async def calculate_churn_rate(self, month: date) -> float:
        """计算月度流失率"""
        # 月初活跃付费用户
        start_count = await self._get_active_subscribers_count(
            month.replace(day=1)
        )

        # 月末流失用户
        churned = await self._get_churned_count(month)

        return churned / start_count if start_count > 0 else 0

    async def get_conversion_funnel(self, date_range: tuple) -> dict:
        """获取转化漏斗"""
        start, end = date_range

        visitors = await self._get_visitors_count(start, end)
        registrations = await self._get_registrations_count(start, end)
        activations = await self._get_activations_count(start, end)
        payments = await self._get_payments_count(start, end)

        return {
            "visitors": visitors,
            "registrations": registrations,
            "registration_rate": registrations / visitors if visitors > 0 else 0,
            "activations": activations,
            "activation_rate": activations / registrations if registrations > 0 else 0,
            "payments": payments,
            "payment_rate": payments / activations if activations > 0 else 0,
        }
```

---

## 8. 成本控制

### 8.1 AI成本优化

```yaml
成本控制策略:
  模型选择:
    - Free用户: 仅Haiku模型
    - Basic用户: Sonnet模型
    - Pro用户: Sonnet + Opus可选

  缓存策略:
    - 相似请求缓存
    - 热门模板预生成
    - 结果复用

  配额限制:
    - 每日Token上限
    - 单次请求上限
    - 频率限制

  监控告警:
    - 异常用量告警
    - 成本超标告警
    - 滥用检测
```

### 8.2 成本模型

```python
# backend/app/services/cost_service.py

class CostService:
    """成本计算服务"""

    # Claude API价格 (每1K tokens)
    PRICES = {
        "claude-3-5-haiku-20241022": {
            "input": 0.001,
            "output": 0.005,
        },
        "claude-sonnet-4-20250514": {
            "input": 0.003,
            "output": 0.015,
        },
        "claude-opus-4-20250514": {
            "input": 0.015,
            "output": 0.075,
        },
    }

    async def calculate_request_cost(
        self,
        model: str,
        input_tokens: int,
        output_tokens: int
    ) -> Decimal:
        """计算单次请求成本"""
        prices = self.PRICES[model]
        input_cost = Decimal(str(input_tokens / 1000 * prices["input"]))
        output_cost = Decimal(str(output_tokens / 1000 * prices["output"]))
        return input_cost + output_cost

    async def get_user_cost_summary(
        self,
        user_id: str,
        month: date
    ) -> dict:
        """获取用户月度成本统计"""
        # 统计各模型使用量和成本
        pass

    async def check_cost_limit(self, user_id: str) -> bool:
        """检查是否超出成本限制"""
        user = await self.db.get(User, user_id)
        tier_limits = {
            "free": Decimal("1.00"),      # $1/天
            "basic": Decimal("5.00"),     # $5/天
            "pro": Decimal("20.00"),      # $20/天
            "enterprise": Decimal("-1"),  # 不限
        }

        limit = tier_limits[user.subscription_tier]
        if limit == Decimal("-1"):
            return True

        today_cost = await self._get_today_cost(user_id)
        return today_cost < limit
```

---

## 相关文档

- [系统架构](./01-系统架构.md)
- [数据模型](./08-数据模型.md)
- [约束细则](./10-约束细则.md)
