# 创流 (CreatorFlow) - 补充需求规格文档

> 补充需求说明书 | 版本: v1.0 | 更新: 2025-12-26

---

## 1. 文档概述

### 1.1 文档目的

本文档是对 `13-需求规格.md` 的补充，针对架构评估中发现的需求缺口进行细化和完善。

### 1.2 补充范围

| 序号 | 补充领域 | 原文档状态 | 补充内容 |
|------|---------|-----------|---------|
| 1 | 视频生成工作流 | 提及 ComfyUI，无详细设计 | 完整工作流设计 |
| 2 | 团队协作数据模型 | 需求存在，数据模型缺失 | Team/Permission 模型 |
| 3 | 内容版本历史 | 模型存在，UI 设计缺失 | 版本对比与回滚 UI |
| 4 | 批量发布限流策略 | 未定义 | 各平台限流规则 |
| 5 | 视频编辑工具设计 | 未定义 | 视频编辑器架构 |

---

## 2. 视频生成工作流详细设计

### 2.1 视频生成架构

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                           视频生成工作流架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         用户输入层                                    │   │
│  │  · 文案/脚本      · 图片素材      · 音频素材      · 风格设置           │   │
│  └────────────────────────────┬────────────────────────────────────────┘   │
│                               │                                             │
│                               ▼                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      视频生成 Agent (LangGraph)                       │   │
│  │                                                                       │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │ 脚本分析    │→│ 分镜规划    │→│ 资源匹配    │→│ 生成调度    │ │   │
│  │  │ Node       │  │ Node       │  │ Node       │  │ Node       │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  └────────────────────────────┬────────────────────────────────────────┘   │
│                               │                                             │
│          ┌────────────────────┼────────────────────┐                       │
│          ▼                    ▼                    ▼                       │
│  ┌───────────────┐    ┌───────────────┐    ┌───────────────┐              │
│  │  ComfyUI      │    │  TTS 服务     │    │  BGM 服务     │              │
│  │  (画面生成)   │    │  (配音生成)   │    │  (背景音乐)   │              │
│  │               │    │               │    │               │              │
│  │ · SD/SDXL    │    │ · Azure TTS   │    │ · 版权音乐库  │              │
│  │ · AnimateDiff│    │ · 阿里云 TTS  │    │ · AI 音乐生成 │              │
│  │ · SVD        │    │ · Fish Audio  │    │               │              │
│  └───────┬───────┘    └───────┬───────┘    └───────┬───────┘              │
│          │                    │                    │                       │
│          └────────────────────┼────────────────────┘                       │
│                               ▼                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      视频合成引擎 (FFmpeg)                            │   │
│  │                                                                       │   │
│  │  · 画面拼接      · 音视频同步      · 转场特效      · 字幕叠加         │   │
│  └────────────────────────────┬────────────────────────────────────────┘   │
│                               │                                             │
│                               ▼                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         输出层                                        │   │
│  │  · 多分辨率导出 (1080p/720p/竖屏)    · 各平台格式适配                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 ComfyUI 集成设计

#### 2.2.1 ComfyUI 工作流模板

```yaml
# 视频生成工作流模板配置
video_workflows:
  # 图文转视频
  image_to_video:
    name: "图文转视频"
    description: "将静态图片转换为动态视频"
    workflow_id: "img2vid_svd"
    inputs:
      - name: image
        type: image
        required: true
      - name: motion_bucket_id
        type: integer
        default: 127
        range: [1, 255]
      - name: fps
        type: integer
        default: 8
        options: [6, 8, 12, 24]
      - name: frames
        type: integer
        default: 25
    output:
      type: video
      format: mp4

  # AI 画面生成
  text_to_video:
    name: "文字生成视频"
    description: "根据文字描述生成视频画面"
    workflow_id: "txt2vid_animatediff"
    inputs:
      - name: prompt
        type: string
        required: true
      - name: negative_prompt
        type: string
        default: "blur, low quality, distorted"
      - name: style
        type: enum
        options: [realistic, anime, cartoon, cinematic]
      - name: duration_seconds
        type: integer
        default: 4
        range: [2, 10]
    output:
      type: video
      format: mp4

  # 数字人视频
  digital_human:
    name: "数字人视频"
    description: "生成数字人口播视频"
    workflow_id: "digital_human_sadtalker"
    inputs:
      - name: avatar_image
        type: image
        required: true
      - name: audio
        type: audio
        required: true
      - name: expression
        type: enum
        options: [neutral, happy, serious]
    output:
      type: video
      format: mp4
```

#### 2.2.2 ComfyUI 客户端实现

```python
# backend/app/services/comfyui_client.py

from typing import Any
import httpx
import asyncio
from uuid import uuid4

class ComfyUIClient:
    """ComfyUI API 客户端"""

    def __init__(self, base_url: str = "http://localhost:8188"):
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=300.0)
        self.client_id = str(uuid4())

    async def queue_prompt(self, workflow: dict) -> str:
        """提交工作流到队列"""
        response = await self.client.post(
            f"{self.base_url}/prompt",
            json={
                "prompt": workflow,
                "client_id": self.client_id
            }
        )
        return response.json()["prompt_id"]

    async def get_history(self, prompt_id: str) -> dict:
        """获取执行历史"""
        response = await self.client.get(
            f"{self.base_url}/history/{prompt_id}"
        )
        return response.json()

    async def wait_for_completion(
        self,
        prompt_id: str,
        timeout: int = 300,
        poll_interval: float = 1.0
    ) -> dict:
        """等待工作流完成"""
        elapsed = 0
        while elapsed < timeout:
            history = await self.get_history(prompt_id)
            if prompt_id in history:
                return history[prompt_id]
            await asyncio.sleep(poll_interval)
            elapsed += poll_interval
        raise TimeoutError(f"Workflow {prompt_id} timed out")

    async def upload_image(self, image_data: bytes, filename: str) -> str:
        """上传图片到 ComfyUI"""
        files = {"image": (filename, image_data, "image/png")}
        response = await self.client.post(
            f"{self.base_url}/upload/image",
            files=files
        )
        return response.json()["name"]

    async def get_output_video(self, filename: str) -> bytes:
        """获取生成的视频文件"""
        response = await self.client.get(
            f"{self.base_url}/view",
            params={"filename": filename, "type": "output"}
        )
        return response.content


class VideoGenerationService:
    """视频生成服务"""

    def __init__(self):
        self.comfyui = ComfyUIClient()
        self.workflow_templates = self._load_workflow_templates()

    def _load_workflow_templates(self) -> dict:
        """加载工作流模板"""
        import yaml
        with open("workflows/video_workflows.yaml") as f:
            return yaml.safe_load(f)

    async def generate_video_from_images(
        self,
        images: list[bytes],
        audio_url: str | None = None,
        style: str = "cinematic",
        fps: int = 24
    ) -> str:
        """从图片生成视频"""

        # 1. 上传图片
        uploaded_images = []
        for i, img_data in enumerate(images):
            name = await self.comfyui.upload_image(img_data, f"frame_{i}.png")
            uploaded_images.append(name)

        # 2. 构建工作流
        workflow = self._build_img2vid_workflow(
            images=uploaded_images,
            style=style,
            fps=fps
        )

        # 3. 执行工作流
        prompt_id = await self.comfyui.queue_prompt(workflow)
        result = await self.comfyui.wait_for_completion(prompt_id)

        # 4. 获取输出视频
        output_filename = self._extract_output_filename(result)
        video_data = await self.comfyui.get_output_video(output_filename)

        # 5. 上传到存储服务
        video_url = await self._upload_to_storage(video_data)

        return video_url

    async def generate_digital_human_video(
        self,
        avatar_image: bytes,
        audio_data: bytes,
        expression: str = "neutral"
    ) -> str:
        """生成数字人视频"""

        # 1. 上传素材
        avatar_name = await self.comfyui.upload_image(avatar_image, "avatar.png")
        # 音频需要单独处理上传

        # 2. 构建工作流
        workflow = self._build_digital_human_workflow(
            avatar=avatar_name,
            expression=expression
        )

        # 3. 执行并返回
        prompt_id = await self.comfyui.queue_prompt(workflow)
        result = await self.comfyui.wait_for_completion(prompt_id, timeout=600)

        output_filename = self._extract_output_filename(result)
        video_data = await self.comfyui.get_output_video(output_filename)

        return await self._upload_to_storage(video_data)
```

### 2.3 TTS 配音服务设计

```python
# backend/app/services/tts_service.py

from abc import ABC, abstractmethod
from typing import Literal
from pydantic import BaseModel

class TTSRequest(BaseModel):
    """TTS 请求参数"""
    text: str
    voice_id: str
    speed: float = 1.0
    pitch: float = 1.0
    format: Literal["mp3", "wav"] = "mp3"


class TTSProvider(ABC):
    """TTS 服务提供商基类"""

    @abstractmethod
    async def synthesize(self, request: TTSRequest) -> bytes:
        """合成语音"""
        pass

    @abstractmethod
    async def list_voices(self) -> list[dict]:
        """获取可用音色列表"""
        pass


class AzureTTSProvider(TTSProvider):
    """Azure TTS 实现"""

    def __init__(self, subscription_key: str, region: str):
        self.subscription_key = subscription_key
        self.region = region

    async def synthesize(self, request: TTSRequest) -> bytes:
        import azure.cognitiveservices.speech as speechsdk

        speech_config = speechsdk.SpeechConfig(
            subscription=self.subscription_key,
            region=self.region
        )
        speech_config.speech_synthesis_voice_name = request.voice_id

        synthesizer = speechsdk.SpeechSynthesizer(
            speech_config=speech_config,
            audio_config=None
        )

        ssml = f"""
        <speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="zh-CN">
            <voice name="{request.voice_id}">
                <prosody rate="{request.speed}" pitch="{request.pitch}">
                    {request.text}
                </prosody>
            </voice>
        </speak>
        """

        result = synthesizer.speak_ssml_async(ssml).get()
        return result.audio_data

    async def list_voices(self) -> list[dict]:
        return [
            {"id": "zh-CN-XiaoxiaoNeural", "name": "晓晓", "gender": "female", "style": "活泼"},
            {"id": "zh-CN-YunxiNeural", "name": "云希", "gender": "male", "style": "阳光"},
            {"id": "zh-CN-YunyangNeural", "name": "云扬", "gender": "male", "style": "专业"},
            {"id": "zh-CN-XiaoyiNeural", "name": "晓伊", "gender": "female", "style": "温柔"},
        ]


class AliyunTTSProvider(TTSProvider):
    """阿里云 TTS 实现"""

    async def synthesize(self, request: TTSRequest) -> bytes:
        # 阿里云 TTS 实现
        pass

    async def list_voices(self) -> list[dict]:
        return [
            {"id": "zhitian_emo", "name": "知甜", "gender": "female", "style": "情感"},
            {"id": "zhiyan_emo", "name": "知燕", "gender": "female", "style": "温柔"},
            {"id": "zhida_emo", "name": "知达", "gender": "male", "style": "磁性"},
        ]


class TTSService:
    """TTS 服务统一接口"""

    def __init__(self):
        self.providers: dict[str, TTSProvider] = {}
        self._init_providers()

    def _init_providers(self):
        """初始化各 TTS 提供商"""
        from app.core.config import settings

        if settings.AZURE_TTS_KEY:
            self.providers["azure"] = AzureTTSProvider(
                settings.AZURE_TTS_KEY,
                settings.AZURE_TTS_REGION
            )

        if settings.ALIYUN_TTS_KEY:
            self.providers["aliyun"] = AliyunTTSProvider()

    async def synthesize(
        self,
        text: str,
        voice_id: str,
        provider: str = "azure",
        **kwargs
    ) -> bytes:
        """合成语音"""
        if provider not in self.providers:
            raise ValueError(f"Unknown TTS provider: {provider}")

        request = TTSRequest(text=text, voice_id=voice_id, **kwargs)
        return await self.providers[provider].synthesize(request)

    async def list_all_voices(self) -> dict[str, list[dict]]:
        """获取所有提供商的音色列表"""
        result = {}
        for name, provider in self.providers.items():
            result[name] = await provider.list_voices()
        return result
```

### 2.4 视频生成需求表

| 需求ID | 需求描述 | 优先级 | 验收标准 |
|--------|---------|--------|---------|
| F-VID-001 | 图文转视频 | P0 | 支持将图片序列生成为视频，自动添加转场 |
| F-VID-002 | AI 画面生成 | P1 | 根据文字描述生成视频画面 |
| F-VID-003 | 数字人视频 | P1 | 上传头像 + 音频生成口播视频 |
| F-VID-004 | TTS 配音 | P0 | 支持多音色、多语言配音 |
| F-VID-005 | 字幕生成 | P0 | 自动生成时间轴字幕 (SRT/ASS) |
| F-VID-006 | BGM 匹配 | P1 | 智能推荐背景音乐 |
| F-VID-007 | 视频模板 | P0 | 预设模板一键生成 |
| F-VID-008 | 多分辨率导出 | P0 | 支持 1080p/720p/竖屏等多种规格 |
| F-VID-009 | 视频预览 | P0 | 生成前预览效果 |
| F-VID-010 | 生成进度追踪 | P0 | 实时显示生成进度 |

---

## 3. 团队协作数据模型补充

### 3.1 团队相关数据模型

```python
# backend/app/models/team.py

from sqlalchemy import Column, String, ForeignKey, Boolean, Integer, Enum as SQLEnum, Text
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from .base import BaseModel, SoftDeleteMixin
from enum import Enum

class TeamRole(str, Enum):
    """团队角色"""
    OWNER = "owner"           # 所有者 - 全部权限
    ADMIN = "admin"           # 管理员 - 除删除团队外全部权限
    EDITOR = "editor"         # 编辑 - 内容创建、编辑、发布
    VIEWER = "viewer"         # 查看者 - 只读权限


class Team(BaseModel, SoftDeleteMixin):
    """团队表"""
    __tablename__ = "teams"

    # 基本信息
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=True)
    logo_url = Column(String(500), nullable=True)

    # 所有者
    owner_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 配置
    settings = Column(JSON, default=dict)
    # 示例: {"require_approval": true, "default_role": "editor", "brand_guidelines": "..."}

    # 配额
    max_members = Column(Integer, default=10)
    max_accounts = Column(Integer, default=20)

    # 关联
    owner = relationship("User", foreign_keys=[owner_id])
    members = relationship("TeamMember", back_populates="team")
    shared_accounts = relationship("TeamAccount", back_populates="team")
    shared_contents = relationship("TeamContent", back_populates="team")


class TeamMember(BaseModel):
    """团队成员表"""
    __tablename__ = "team_members"

    team_id = Column(UUID(as_uuid=True), ForeignKey("teams.id"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 角色
    role = Column(SQLEnum(TeamRole), default=TeamRole.EDITOR, nullable=False)

    # 状态
    is_active = Column(Boolean, default=True)
    invited_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    joined_at = Column(DateTime, nullable=True)

    # 关联
    team = relationship("Team", back_populates="members")
    user = relationship("User", foreign_keys=[user_id])
    inviter = relationship("User", foreign_keys=[invited_by])

    __table_args__ = (
        UniqueConstraint('team_id', 'user_id', name='uix_team_member'),
    )


class TeamAccount(BaseModel):
    """团队共享账号表"""
    __tablename__ = "team_accounts"

    team_id = Column(UUID(as_uuid=True), ForeignKey("teams.id"), nullable=False)
    account_id = Column(UUID(as_uuid=True), ForeignKey("platform_accounts.id"), nullable=False)

    # 共享配置
    shared_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 权限配置 - 哪些角色可以使用
    allowed_roles = Column(ARRAY(String), default=["owner", "admin", "editor"])

    # 关联
    team = relationship("Team", back_populates="shared_accounts")
    account = relationship("PlatformAccount")

    __table_args__ = (
        UniqueConstraint('team_id', 'account_id', name='uix_team_account'),
    )


class TeamContent(BaseModel):
    """团队共享内容表"""
    __tablename__ = "team_contents"

    team_id = Column(UUID(as_uuid=True), ForeignKey("teams.id"), nullable=False)
    content_id = Column(UUID(as_uuid=True), ForeignKey("contents.id"), nullable=False)

    # 共享配置
    shared_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 权限
    allow_edit = Column(Boolean, default=False)  # 是否允许编辑
    allow_publish = Column(Boolean, default=True)  # 是否允许发布

    # 关联
    team = relationship("Team", back_populates="shared_contents")
    content = relationship("Content")

    __table_args__ = (
        UniqueConstraint('team_id', 'content_id', name='uix_team_content'),
    )
```

### 3.2 权限系统设计

```python
# backend/app/models/permission.py

from sqlalchemy import Column, String, ForeignKey, Boolean
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from .base import BaseModel
from enum import Enum

class Permission(str, Enum):
    """权限枚举"""
    # 团队管理
    TEAM_MANAGE = "team:manage"           # 管理团队设置
    TEAM_INVITE = "team:invite"           # 邀请成员
    TEAM_REMOVE = "team:remove"           # 移除成员

    # 内容权限
    CONTENT_CREATE = "content:create"     # 创建内容
    CONTENT_EDIT = "content:edit"         # 编辑内容
    CONTENT_DELETE = "content:delete"     # 删除内容
    CONTENT_PUBLISH = "content:publish"   # 发布内容

    # 账号权限
    ACCOUNT_ADD = "account:add"           # 添加账号
    ACCOUNT_REMOVE = "account:remove"     # 移除账号
    ACCOUNT_USE = "account:use"           # 使用账号发布

    # 数据权限
    DATA_VIEW = "data:view"               # 查看数据
    DATA_EXPORT = "data:export"           # 导出数据

    # 审批权限
    APPROVAL_APPROVE = "approval:approve" # 审批内容
    APPROVAL_REJECT = "approval:reject"   # 拒绝内容


# 角色-权限映射
ROLE_PERMISSIONS: dict[str, list[Permission]] = {
    "owner": list(Permission),  # 所有者拥有全部权限

    "admin": [
        Permission.TEAM_INVITE,
        Permission.TEAM_REMOVE,
        Permission.CONTENT_CREATE,
        Permission.CONTENT_EDIT,
        Permission.CONTENT_DELETE,
        Permission.CONTENT_PUBLISH,
        Permission.ACCOUNT_ADD,
        Permission.ACCOUNT_REMOVE,
        Permission.ACCOUNT_USE,
        Permission.DATA_VIEW,
        Permission.DATA_EXPORT,
        Permission.APPROVAL_APPROVE,
        Permission.APPROVAL_REJECT,
    ],

    "editor": [
        Permission.CONTENT_CREATE,
        Permission.CONTENT_EDIT,
        Permission.CONTENT_PUBLISH,
        Permission.ACCOUNT_USE,
        Permission.DATA_VIEW,
    ],

    "viewer": [
        Permission.DATA_VIEW,
    ],
}


class PermissionService:
    """权限服务"""

    @staticmethod
    def has_permission(role: str, permission: Permission) -> bool:
        """检查角色是否有指定权限"""
        role_perms = ROLE_PERMISSIONS.get(role, [])
        return permission in role_perms

    @staticmethod
    def get_permissions(role: str) -> list[Permission]:
        """获取角色的所有权限"""
        return ROLE_PERMISSIONS.get(role, [])

    @staticmethod
    async def check_team_permission(
        user_id: str,
        team_id: str,
        permission: Permission,
        db
    ) -> bool:
        """检查用户在团队中是否有指定权限"""
        from .team import TeamMember

        member = await db.execute(
            select(TeamMember).where(
                TeamMember.team_id == team_id,
                TeamMember.user_id == user_id,
                TeamMember.is_active == True
            )
        )
        member = member.scalar_one_or_none()

        if not member:
            return False

        return PermissionService.has_permission(member.role, permission)
```

### 3.3 审批流程设计

```python
# backend/app/models/approval.py

from sqlalchemy import Column, String, ForeignKey, Text, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID
from .base import BaseModel
from enum import Enum
from datetime import datetime

class ApprovalStatus(str, Enum):
    """审批状态"""
    PENDING = "pending"       # 待审批
    APPROVED = "approved"     # 已通过
    REJECTED = "rejected"     # 已拒绝
    CANCELLED = "cancelled"   # 已取消


class ApprovalRequest(BaseModel):
    """审批请求表"""
    __tablename__ = "approval_requests"

    team_id = Column(UUID(as_uuid=True), ForeignKey("teams.id"), nullable=False)

    # 审批类型
    approval_type = Column(String(50), nullable=False)  # publish, edit, delete

    # 关联对象
    target_type = Column(String(50), nullable=False)    # content, publication
    target_id = Column(UUID(as_uuid=True), nullable=False)

    # 申请人
    requester_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 申请说明
    request_note = Column(Text, nullable=True)

    # 状态
    status = Column(SQLEnum(ApprovalStatus), default=ApprovalStatus.PENDING)

    # 审批人
    approver_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    approved_at = Column(DateTime, nullable=True)
    approval_note = Column(Text, nullable=True)

    # 关联
    team = relationship("Team")
    requester = relationship("User", foreign_keys=[requester_id])
    approver = relationship("User", foreign_keys=[approver_id])


class ApprovalRule(BaseModel):
    """审批规则表"""
    __tablename__ = "approval_rules"

    team_id = Column(UUID(as_uuid=True), ForeignKey("teams.id"), nullable=False)

    # 规则配置
    approval_type = Column(String(50), nullable=False)  # publish, edit

    # 触发条件
    trigger_roles = Column(ARRAY(String), default=["editor"])  # 哪些角色需要审批

    # 审批人
    approver_roles = Column(ARRAY(String), default=["admin", "owner"])  # 谁可以审批

    # 是否启用
    is_active = Column(Boolean, default=True)

    __table_args__ = (
        UniqueConstraint('team_id', 'approval_type', name='uix_team_approval_type'),
    )
```

---

## 4. 内容版本历史 UI 设计

### 4.1 版本历史功能需求

| 需求ID | 需求描述 | 优先级 | 验收标准 |
|--------|---------|--------|---------|
| F-VER-001 | 版本列表展示 | P0 | 显示所有历史版本，含时间、操作者、变更摘要 |
| F-VER-002 | 版本内容预览 | P0 | 点击版本可预览该版本内容 |
| F-VER-003 | 版本对比 (Diff) | P0 | 支持任意两个版本对比，高亮差异 |
| F-VER-004 | 版本回滚 | P0 | 支持回滚到任意历史版本 |
| F-VER-005 | 版本备注 | P1 | 支持为版本添加备注说明 |
| F-VER-006 | 自动保存版本 | P0 | 重要操作自动创建版本 |

### 4.2 版本对比 UI 设计

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                           内容版本历史                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  版本列表                                         [版本对比模式]     │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                     │   │
│  │  ○ v5 (当前)    2025-12-26 15:30    张三    AI优化标题             │   │
│  │  ◉ v4           2025-12-26 14:20    张三    修改正文内容           │   │
│  │  ◉ v3           2025-12-26 12:00    AI      AI生成初稿             │   │
│  │  ○ v2           2025-12-25 18:30    张三    添加配图               │   │
│  │  ○ v1           2025-12-25 16:00    张三    创建草稿               │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  版本对比: v3 → v4                              [← 上一组] [下一组 →]│   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                     │   │
│  │  ┌─────────────────────┐   ┌─────────────────────┐                 │   │
│  │  │      v3 (旧版)      │   │      v4 (新版)      │                 │   │
│  │  ├─────────────────────┤   ├─────────────────────┤                 │   │
│  │  │                     │   │                     │                 │   │
│  │  │  标题: 如何高效学习 │   │  标题: 如何高效学习 │                 │   │
│  │  │                     │   │                     │                 │   │
│  │  │  正文:              │   │  正文:              │                 │   │
│  │  │  ━━━━━━━━━━━━━━━━━ │   │  ━━━━━━━━━━━━━━━━━ │                 │   │
│  │  │  学习是一门艺术...  │   │  学习是一门艺术...  │                 │   │
│  │  │  [-删除的段落-]     │   │                     │                 │   │
│  │  │                     │   │  [+新增的段落+]     │                 │   │
│  │  │  总结: 以上是...    │   │  总结: 以上是...    │                 │   │
│  │  │                     │   │                     │                 │   │
│  │  └─────────────────────┘   └─────────────────────┘                 │   │
│  │                                                                     │   │
│  │  变更统计: +128 字  -45 字  修改 3 处                               │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  [查看完整内容]    [回滚到 v3]    [回滚到 v4]    [关闭]             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 版本对比服务实现

```python
# backend/app/services/version_service.py

from difflib import unified_diff, SequenceMatcher
from typing import TypedDict
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

class DiffResult(TypedDict):
    """差异对比结果"""
    additions: int          # 新增字数
    deletions: int          # 删除字数
    changes: list[dict]     # 变更详情


class VersionService:
    """版本管理服务"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_version_history(
        self,
        content_id: str,
        limit: int = 20
    ) -> list[dict]:
        """获取版本历史列表"""
        from app.models.content import ContentVersion

        result = await self.db.execute(
            select(ContentVersion)
            .where(ContentVersion.content_id == content_id)
            .order_by(ContentVersion.version.desc())
            .limit(limit)
        )
        versions = result.scalars().all()

        return [
            {
                "id": str(v.id),
                "version": v.version,
                "title": v.title,
                "change_summary": v.change_summary,
                "changed_by": v.changed_by,
                "created_at": v.created_at.isoformat(),
            }
            for v in versions
        ]

    async def get_version_content(
        self,
        content_id: str,
        version: int
    ) -> dict:
        """获取指定版本的完整内容"""
        from app.models.content import ContentVersion

        result = await self.db.execute(
            select(ContentVersion).where(
                ContentVersion.content_id == content_id,
                ContentVersion.version == version
            )
        )
        v = result.scalar_one_or_none()

        if not v:
            raise ValueError(f"Version {version} not found")

        return {
            "version": v.version,
            "title": v.title,
            "text_content": v.text_content,
            "media_urls": v.media_urls,
            "created_at": v.created_at.isoformat(),
        }

    def compare_versions(
        self,
        old_content: str,
        new_content: str
    ) -> DiffResult:
        """对比两个版本的文本差异"""

        # 使用 SequenceMatcher 计算差异
        matcher = SequenceMatcher(None, old_content, new_content)

        additions = 0
        deletions = 0
        changes = []

        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'replace':
                deletions += i2 - i1
                additions += j2 - j1
                changes.append({
                    "type": "replace",
                    "old": old_content[i1:i2],
                    "new": new_content[j1:j2],
                    "position": i1
                })
            elif tag == 'delete':
                deletions += i2 - i1
                changes.append({
                    "type": "delete",
                    "old": old_content[i1:i2],
                    "position": i1
                })
            elif tag == 'insert':
                additions += j2 - j1
                changes.append({
                    "type": "insert",
                    "new": new_content[j1:j2],
                    "position": i1
                })

        return DiffResult(
            additions=additions,
            deletions=deletions,
            changes=changes
        )

    async def compare_version_pair(
        self,
        content_id: str,
        old_version: int,
        new_version: int
    ) -> dict:
        """对比两个版本"""
        old = await self.get_version_content(content_id, old_version)
        new = await self.get_version_content(content_id, new_version)

        # 对比标题
        title_diff = None
        if old["title"] != new["title"]:
            title_diff = {
                "old": old["title"],
                "new": new["title"]
            }

        # 对比正文
        content_diff = self.compare_versions(
            old["text_content"] or "",
            new["text_content"] or ""
        )

        # 对比媒体
        media_diff = {
            "added": [m for m in new["media_urls"] if m not in old["media_urls"]],
            "removed": [m for m in old["media_urls"] if m not in new["media_urls"]]
        }

        return {
            "old_version": old_version,
            "new_version": new_version,
            "title_diff": title_diff,
            "content_diff": content_diff,
            "media_diff": media_diff,
        }

    async def rollback_to_version(
        self,
        content_id: str,
        target_version: int,
        user_id: str
    ) -> dict:
        """回滚到指定版本"""
        from app.models.content import Content, ContentVersion

        # 获取目标版本
        target = await self.get_version_content(content_id, target_version)

        # 获取当前内容
        result = await self.db.execute(
            select(Content).where(Content.id == content_id)
        )
        content = result.scalar_one()

        # 创建新版本（回滚记录）
        new_version = content.version + 1
        version_record = ContentVersion(
            content_id=content_id,
            version=new_version,
            title=target["title"],
            text_content=target["text_content"],
            media_urls=target["media_urls"],
            change_summary=f"回滚到版本 v{target_version}",
            changed_by=user_id
        )
        self.db.add(version_record)

        # 更新当前内容
        content.title = target["title"]
        content.text_content = target["text_content"]
        content.media_urls = target["media_urls"]
        content.version = new_version

        await self.db.commit()

        return {
            "new_version": new_version,
            "rolled_back_from": content.version - 1,
            "rolled_back_to": target_version
        }
```

---

## 5. 批量发布限流策略

### 5.1 各平台限流规则

```yaml
# config/platform_rate_limits.yaml

rate_limits:
  # 小红书
  xiaohongshu:
    publish:
      max_per_hour: 3
      max_per_day: 10
      min_interval_seconds: 300  # 发布间隔至少 5 分钟
    login:
      max_attempts_per_hour: 5
      cooldown_minutes: 30
    risk_level: high
    notes: "小红书风控严格，建议间隔发布"

  # 抖音
  douyin:
    publish:
      max_per_hour: 5
      max_per_day: 20
      min_interval_seconds: 180
    login:
      max_attempts_per_hour: 10
      cooldown_minutes: 15
    risk_level: medium

  # 微博
  weibo:
    publish:
      max_per_hour: 10
      max_per_day: 50
      min_interval_seconds: 60
    login:
      max_attempts_per_hour: 20
      cooldown_minutes: 10
    risk_level: low

  # 微信公众号
  wechat_mp:
    publish:
      max_per_hour: 8  # API 限制
      max_per_day: 8   # 订阅号每天 1 篇，服务号每月 4 篇
      min_interval_seconds: 0
    risk_level: low
    notes: "使用官方 API，按 API 配额限制"

  # B站
  bilibili:
    publish:
      max_per_hour: 5
      max_per_day: 20
      min_interval_seconds: 120
    login:
      max_attempts_per_hour: 10
      cooldown_minutes: 20
    risk_level: medium

  # 知乎
  zhihu:
    publish:
      max_per_hour: 3
      max_per_day: 15
      min_interval_seconds: 300
    login:
      max_attempts_per_hour: 5
      cooldown_minutes: 30
    risk_level: high
    notes: "知乎反爬严格，建议模拟真实用户行为"

  # 快手
  kuaishou:
    publish:
      max_per_hour: 5
      max_per_day: 15
      min_interval_seconds: 180
    login:
      max_attempts_per_hour: 10
      cooldown_minutes: 15
    risk_level: medium

# 全局配置
global:
  # 同一账号并发限制
  max_concurrent_per_account: 1

  # 同一平台并发限制
  max_concurrent_per_platform: 3

  # 总并发限制
  max_concurrent_total: 10

  # 失败重试配置
  retry:
    max_retries: 3
    base_delay_seconds: 60
    max_delay_seconds: 3600
    exponential_base: 2
```

### 5.2 限流服务实现

```python
# backend/app/services/rate_limiter.py

import asyncio
from datetime import datetime, timedelta
from typing import Optional
import yaml
import redis.asyncio as redis
from pydantic import BaseModel

class RateLimitConfig(BaseModel):
    """限流配置"""
    max_per_hour: int
    max_per_day: int
    min_interval_seconds: int = 0


class RateLimitResult(BaseModel):
    """限流检查结果"""
    allowed: bool
    wait_seconds: int = 0
    reason: str = ""
    remaining_hour: int = 0
    remaining_day: int = 0


class PlatformRateLimiter:
    """平台发布限流器"""

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.config = self._load_config()

    def _load_config(self) -> dict:
        """加载限流配置"""
        with open("config/platform_rate_limits.yaml") as f:
            return yaml.safe_load(f)

    def _get_platform_config(self, platform: str) -> RateLimitConfig:
        """获取平台限流配置"""
        platform_config = self.config["rate_limits"].get(platform, {})
        publish_config = platform_config.get("publish", {})
        return RateLimitConfig(
            max_per_hour=publish_config.get("max_per_hour", 10),
            max_per_day=publish_config.get("max_per_day", 50),
            min_interval_seconds=publish_config.get("min_interval_seconds", 60)
        )

    async def check_rate_limit(
        self,
        user_id: str,
        platform: str,
        account_id: str
    ) -> RateLimitResult:
        """检查是否可以发布"""
        config = self._get_platform_config(platform)

        now = datetime.utcnow()
        hour_key = f"rate:{user_id}:{platform}:{account_id}:hour:{now.strftime('%Y%m%d%H')}"
        day_key = f"rate:{user_id}:{platform}:{account_id}:day:{now.strftime('%Y%m%d')}"
        last_publish_key = f"rate:{user_id}:{platform}:{account_id}:last"

        # 检查小时限制
        hour_count = int(await self.redis.get(hour_key) or 0)
        if hour_count >= config.max_per_hour:
            return RateLimitResult(
                allowed=False,
                wait_seconds=3600 - now.minute * 60 - now.second,
                reason=f"已达到每小时发布上限 ({config.max_per_hour})",
                remaining_hour=0,
                remaining_day=config.max_per_day - int(await self.redis.get(day_key) or 0)
            )

        # 检查每日限制
        day_count = int(await self.redis.get(day_key) or 0)
        if day_count >= config.max_per_day:
            return RateLimitResult(
                allowed=False,
                wait_seconds=86400 - now.hour * 3600 - now.minute * 60 - now.second,
                reason=f"已达到每日发布上限 ({config.max_per_day})",
                remaining_hour=0,
                remaining_day=0
            )

        # 检查最小间隔
        if config.min_interval_seconds > 0:
            last_publish = await self.redis.get(last_publish_key)
            if last_publish:
                last_time = datetime.fromisoformat(last_publish.decode())
                elapsed = (now - last_time).total_seconds()
                if elapsed < config.min_interval_seconds:
                    wait = config.min_interval_seconds - int(elapsed)
                    return RateLimitResult(
                        allowed=False,
                        wait_seconds=wait,
                        reason=f"发布间隔不足 {config.min_interval_seconds} 秒",
                        remaining_hour=config.max_per_hour - hour_count,
                        remaining_day=config.max_per_day - day_count
                    )

        return RateLimitResult(
            allowed=True,
            remaining_hour=config.max_per_hour - hour_count,
            remaining_day=config.max_per_day - day_count
        )

    async def record_publish(
        self,
        user_id: str,
        platform: str,
        account_id: str
    ):
        """记录发布操作"""
        now = datetime.utcnow()
        hour_key = f"rate:{user_id}:{platform}:{account_id}:hour:{now.strftime('%Y%m%d%H')}"
        day_key = f"rate:{user_id}:{platform}:{account_id}:day:{now.strftime('%Y%m%d')}"
        last_publish_key = f"rate:{user_id}:{platform}:{account_id}:last"

        pipe = self.redis.pipeline()

        # 增加计数
        pipe.incr(hour_key)
        pipe.expire(hour_key, 3600)

        pipe.incr(day_key)
        pipe.expire(day_key, 86400)

        # 记录最后发布时间
        pipe.set(last_publish_key, now.isoformat())
        pipe.expire(last_publish_key, 3600)

        await pipe.execute()

    async def get_next_available_time(
        self,
        user_id: str,
        platform: str,
        account_id: str
    ) -> datetime:
        """获取下一个可发布时间"""
        result = await self.check_rate_limit(user_id, platform, account_id)

        if result.allowed:
            return datetime.utcnow()

        return datetime.utcnow() + timedelta(seconds=result.wait_seconds)

    async def schedule_batch_publish(
        self,
        tasks: list[dict]
    ) -> list[dict]:
        """智能排期批量发布任务"""
        scheduled_tasks = []
        platform_times: dict[str, datetime] = {}

        for task in tasks:
            platform = task["platform"]
            account_id = task["account_id"]
            user_id = task["user_id"]

            config = self._get_platform_config(platform)
            key = f"{platform}:{account_id}"

            # 获取该账号的下一个可用时间
            if key in platform_times:
                next_time = platform_times[key] + timedelta(
                    seconds=config.min_interval_seconds
                )
            else:
                next_time = await self.get_next_available_time(
                    user_id, platform, account_id
                )

            scheduled_task = {
                **task,
                "scheduled_at": next_time.isoformat()
            }
            scheduled_tasks.append(scheduled_task)

            platform_times[key] = next_time

        return scheduled_tasks
```

### 5.3 批量发布限流需求表

| 需求ID | 需求描述 | 优先级 | 验收标准 |
|--------|---------|--------|---------|
| F-RATE-001 | 平台限流配置 | P0 | 各平台独立配置发布频率限制 |
| F-RATE-002 | 发布间隔控制 | P0 | 同账号发布间隔不少于配置时间 |
| F-RATE-003 | 小时/日限额 | P0 | 限制每小时、每日发布数量 |
| F-RATE-004 | 智能排期 | P0 | 批量发布自动分散到安全时间 |
| F-RATE-005 | 限流提示 | P0 | 触发限流时显示等待时间 |
| F-RATE-006 | 配额查询 | P0 | 用户可查看剩余发布配额 |
| F-RATE-007 | 失败重试 | P0 | 指数退避重试策略 |
| F-RATE-008 | 并发控制 | P0 | 限制同时进行的发布任务数 |

---

## 6. 视频编辑工具设计

### 6.1 视频编辑器架构

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                           视频编辑器架构                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         前端 UI (React)                              │   │
│  │                                                                       │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │  素材面板   │  │  预览窗口   │  │  属性面板   │  │  导出面板   │ │   │
│  │  │  · 视频    │  │  · 实时预览  │  │  · 裁剪    │  │  · 分辨率   │ │   │
│  │  │  · 图片    │  │  · 播放控制  │  │  · 滤镜    │  │  · 格式     │ │   │
│  │  │  · 音频    │  │  · 缩放     │  │  · 特效    │  │  · 质量     │ │   │
│  │  │  · 文字    │  │             │  │  · 动画    │  │             │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  │                                                                       │   │
│  │  ┌─────────────────────────────────────────────────────────────────┐ │   │
│  │  │                      时间轴 (Timeline)                           │ │   │
│  │  │  ┌─────────────────────────────────────────────────────────────┐│ │   │
│  │  │  │ 🎬 视频轨道 1  [片段A]────[片段B]────[片段C]                  ││ │   │
│  │  │  │ 🎬 视频轨道 2      [叠加层]                                   ││ │   │
│  │  │  │ 🎵 音频轨道 1  [背景音乐]─────────────────────────────────   ││ │   │
│  │  │  │ 🎤 音频轨道 2  [配音]────[配音]                              ││ │   │
│  │  │  │ 📝 字幕轨道    [字幕1]──[字幕2]──[字幕3]──[字幕4]            ││ │   │
│  │  │  └─────────────────────────────────────────────────────────────┘│ │   │
│  │  │  [00:00]═══════════════════════════════════════════════[03:45]  │ │   │
│  │  └─────────────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                               │                                             │
│                               │ 编辑指令                                    │
│                               ▼                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      编辑引擎 (Python Sidecar)                        │   │
│  │                                                                       │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │   │
│  │  │  FFmpeg     │  │  MoviePy    │  │  字幕引擎   │  │  滤镜引擎   │ │   │
│  │  │  · 编解码   │  │  · 剪辑    │  │  · SRT/ASS │  │  · 色彩调整 │ │   │
│  │  │  · 转码    │  │  · 合成    │  │  · 样式    │  │  · 特效    │ │   │
│  │  │  · 流处理   │  │  · 特效    │  │  · 时间轴   │  │  · LUT     │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 视频编辑数据模型

```python
# backend/app/models/video_project.py

from sqlalchemy import Column, String, ForeignKey, JSON, Float, Integer
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from .base import BaseModel, SoftDeleteMixin
from pydantic import BaseModel as PydanticModel
from typing import Literal

class VideoProject(BaseModel, SoftDeleteMixin):
    """视频项目表"""
    __tablename__ = "video_projects"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # 项目信息
    name = Column(String(255), nullable=False)
    description = Column(String(500), nullable=True)

    # 项目配置
    resolution = Column(String(20), default="1080p")  # 1080p, 720p, 4k
    aspect_ratio = Column(String(10), default="16:9")  # 16:9, 9:16, 1:1
    fps = Column(Integer, default=30)
    duration_ms = Column(Integer, default=0)

    # 时间轴数据 (JSON)
    timeline = Column(JSON, default=dict)
    # 结构见下方 TimelineData

    # 状态
    status = Column(String(20), default="draft")  # draft, exporting, completed

    # 导出结果
    export_url = Column(String(500), nullable=True)
    thumbnail_url = Column(String(500), nullable=True)


# Pydantic 模型用于时间轴数据验证
class TrackClip(PydanticModel):
    """轨道片段"""
    id: str
    type: Literal["video", "audio", "image", "text"]
    source_url: str
    start_time_ms: int      # 在时间轴上的开始时间
    duration_ms: int        # 片段时长
    source_start_ms: int = 0  # 源素材的开始位置 (用于裁剪)
    source_end_ms: int | None = None

    # 变换属性
    position: dict = {"x": 0, "y": 0}
    scale: float = 1.0
    rotation: float = 0
    opacity: float = 1.0

    # 音频属性
    volume: float = 1.0
    muted: bool = False

    # 特效
    filters: list[dict] = []
    transitions: dict = {}  # {"in": {...}, "out": {...}}


class Track(PydanticModel):
    """轨道"""
    id: str
    type: Literal["video", "audio", "subtitle"]
    name: str
    clips: list[TrackClip]
    muted: bool = False
    locked: bool = False


class TimelineData(PydanticModel):
    """时间轴数据"""
    tracks: list[Track]
    duration_ms: int
    markers: list[dict] = []  # 标记点


class SubtitleStyle(PydanticModel):
    """字幕样式"""
    font_family: str = "Microsoft YaHei"
    font_size: int = 48
    color: str = "#FFFFFF"
    outline_color: str = "#000000"
    outline_width: int = 2
    position: Literal["bottom", "top", "center"] = "bottom"
    margin_bottom: int = 50
```

### 6.3 视频编辑服务实现

```python
# backend/app/services/video_editor.py

import subprocess
import tempfile
import os
from pathlib import Path
from typing import BinaryIO
import json

class VideoEditorService:
    """视频编辑服务"""

    def __init__(self):
        self.ffmpeg_path = "ffmpeg"
        self.ffprobe_path = "ffprobe"

    async def get_video_info(self, video_path: str) -> dict:
        """获取视频信息"""
        cmd = [
            self.ffprobe_path,
            "-v", "quiet",
            "-print_format", "json",
            "-show_format",
            "-show_streams",
            video_path
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        return json.loads(result.stdout)

    async def trim_video(
        self,
        input_path: str,
        output_path: str,
        start_ms: int,
        end_ms: int
    ) -> str:
        """裁剪视频"""
        start_sec = start_ms / 1000
        duration_sec = (end_ms - start_ms) / 1000

        cmd = [
            self.ffmpeg_path,
            "-y",
            "-ss", str(start_sec),
            "-i", input_path,
            "-t", str(duration_sec),
            "-c", "copy",
            output_path
        ]

        subprocess.run(cmd, check=True)
        return output_path

    async def concat_videos(
        self,
        video_paths: list[str],
        output_path: str,
        transitions: list[dict] | None = None
    ) -> str:
        """拼接视频"""
        # 创建临时文件列表
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            for path in video_paths:
                f.write(f"file '{path}'\n")
            list_file = f.name

        try:
            cmd = [
                self.ffmpeg_path,
                "-y",
                "-f", "concat",
                "-safe", "0",
                "-i", list_file,
                "-c", "copy",
                output_path
            ]

            subprocess.run(cmd, check=True)
            return output_path
        finally:
            os.unlink(list_file)

    async def add_audio(
        self,
        video_path: str,
        audio_path: str,
        output_path: str,
        volume: float = 1.0,
        mix_original: bool = True
    ) -> str:
        """添加音频"""
        filter_complex = []

        if mix_original:
            # 混合原始音频和新音频
            filter_complex = [
                f"[0:a]volume=1[a0];",
                f"[1:a]volume={volume}[a1];",
                f"[a0][a1]amix=inputs=2:duration=first[aout]"
            ]
            audio_map = ["-map", "0:v", "-map", "[aout]"]
        else:
            # 替换音频
            filter_complex = [f"[1:a]volume={volume}[aout]"]
            audio_map = ["-map", "0:v", "-map", "[aout]"]

        cmd = [
            self.ffmpeg_path,
            "-y",
            "-i", video_path,
            "-i", audio_path,
            "-filter_complex", "".join(filter_complex),
            *audio_map,
            "-c:v", "copy",
            "-c:a", "aac",
            output_path
        ]

        subprocess.run(cmd, check=True)
        return output_path

    async def add_subtitles(
        self,
        video_path: str,
        subtitle_path: str,
        output_path: str,
        style: dict | None = None
    ) -> str:
        """添加字幕"""
        # 构建字幕滤镜
        subtitle_filter = f"subtitles={subtitle_path}"

        if style:
            force_style = []
            if "font_family" in style:
                force_style.append(f"FontName={style['font_family']}")
            if "font_size" in style:
                force_style.append(f"FontSize={style['font_size']}")
            if "color" in style:
                # 转换颜色格式 #FFFFFF -> &HFFFFFF&
                color = style['color'].replace('#', '&H') + '&'
                force_style.append(f"PrimaryColour={color}")

            if force_style:
                subtitle_filter += f":force_style='{','.join(force_style)}'"

        cmd = [
            self.ffmpeg_path,
            "-y",
            "-i", video_path,
            "-vf", subtitle_filter,
            "-c:a", "copy",
            output_path
        ]

        subprocess.run(cmd, check=True)
        return output_path

    async def apply_filter(
        self,
        video_path: str,
        output_path: str,
        filter_name: str,
        params: dict
    ) -> str:
        """应用滤镜"""
        filters = {
            "brightness": lambda p: f"eq=brightness={p.get('value', 0)}",
            "contrast": lambda p: f"eq=contrast={p.get('value', 1)}",
            "saturation": lambda p: f"eq=saturation={p.get('value', 1)}",
            "blur": lambda p: f"boxblur={p.get('radius', 5)}:{p.get('radius', 5)}",
            "sharpen": lambda p: f"unsharp=5:5:{p.get('amount', 1)}",
            "grayscale": lambda p: "colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3",
            "sepia": lambda p: "colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131",
        }

        if filter_name not in filters:
            raise ValueError(f"Unknown filter: {filter_name}")

        vf = filters[filter_name](params)

        cmd = [
            self.ffmpeg_path,
            "-y",
            "-i", video_path,
            "-vf", vf,
            "-c:a", "copy",
            output_path
        ]

        subprocess.run(cmd, check=True)
        return output_path

    async def export_project(
        self,
        timeline: dict,
        output_path: str,
        resolution: str = "1080p",
        fps: int = 30
    ) -> str:
        """导出完整项目"""
        # 这里需要根据时间轴数据构建完整的 FFmpeg 命令
        # 实际实现会更复杂，需要处理多轨道合成

        resolutions = {
            "720p": "1280:720",
            "1080p": "1920:1080",
            "4k": "3840:2160"
        }

        scale = resolutions.get(resolution, "1920:1080")

        # 简化示例：实际需要根据 timeline 构建 filter_complex
        # ...

        return output_path
```

### 6.4 视频编辑需求表

| 需求ID | 需求描述 | 优先级 | 验收标准 |
|--------|---------|--------|---------|
| F-EDIT-001 | 视频裁剪 | P0 | 支持精确到帧的裁剪 |
| F-EDIT-002 | 视频拼接 | P0 | 支持多段视频拼接，可选转场 |
| F-EDIT-003 | 添加音频 | P0 | 支持添加背景音乐、配音 |
| F-EDIT-004 | 添加字幕 | P0 | 支持 SRT/ASS 字幕，自定义样式 |
| F-EDIT-005 | 多轨道编辑 | P1 | 支持多视频轨、多音频轨 |
| F-EDIT-006 | 基础滤镜 | P0 | 亮度、对比度、饱和度调整 |
| F-EDIT-007 | 预设滤镜 | P1 | 黑白、复古、电影感等预设 |
| F-EDIT-008 | 转场效果 | P1 | 淡入淡出、滑动、缩放等 |
| F-EDIT-009 | 文字叠加 | P0 | 支持添加文字标题、水印 |
| F-EDIT-010 | 实时预览 | P0 | 编辑时实时预览效果 |
| F-EDIT-011 | 多分辨率导出 | P0 | 支持 720p/1080p/4K 导出 |
| F-EDIT-012 | 导出进度 | P0 | 显示导出进度和预计时间 |

---

## 7. 补充数据模型汇总

### 7.1 新增模型清单

| 模型名称 | 所属模块 | 说明 |
|---------|---------|------|
| `Team` | 团队协作 | 团队基本信息 |
| `TeamMember` | 团队协作 | 团队成员关系 |
| `TeamAccount` | 团队协作 | 团队共享账号 |
| `TeamContent` | 团队协作 | 团队共享内容 |
| `ApprovalRequest` | 团队协作 | 审批请求 |
| `ApprovalRule` | 团队协作 | 审批规则 |
| `VideoProject` | 视频编辑 | 视频项目 |

### 7.2 ER 图补充

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                          补充数据模型关系图                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────┐       ┌──────────────────┐       ┌──────────────────┐    │
│  │    User      │──────<│   TeamMember     │>──────│     Team         │    │
│  │              │       │                  │       │                  │    │
│  │ - id         │       │ - team_id        │       │ - id             │    │
│  │ - email      │       │ - user_id        │       │ - name           │    │
│  └──────────────┘       │ - role           │       │ - owner_id       │    │
│         │               └──────────────────┘       └────────┬─────────┘    │
│         │                                                   │              │
│         │                                          ┌────────┴─────────┐    │
│         │                                          │                  │    │
│         │                                          ▼                  ▼    │
│         │               ┌──────────────────┐  ┌──────────────┐  ┌────────┐│
│         │               │   TeamAccount    │  │ TeamContent  │  │Approval││
│         │               │                  │  │              │  │Request ││
│         │               │ - team_id        │  │ - team_id    │  │        ││
│         │               │ - account_id     │  │ - content_id │  │ -status││
│         │               │ - allowed_roles  │  │ - allow_edit │  │        ││
│         │               └──────────────────┘  └──────────────┘  └────────┘│
│         │                                                                  │
│         │               ┌──────────────────┐                               │
│         └──────────────>│  VideoProject    │                               │
│                         │                  │                               │
│                         │ - user_id        │                               │
│                         │ - timeline (JSON)│                               │
│                         │ - resolution     │                               │
│                         └──────────────────┘                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 8. 相关文档

- [需求规格文档](./13-需求规格.md)
- [数据模型](./08-数据模型.md)
- [AI工作流](./07-AI工作流.md)
- [平台适配器](./06-平台适配器.md)
- [BettaFish 集成](./08-BettaFish舆情分析集成.md)

---

> 文档版本: v1.0
> 更新日期: 2025-12-26
> 状态: 初稿完成
