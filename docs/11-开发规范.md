# AI Creator - 开发规范

> 项目开发规则与约定

## 1. 代码规范

### 1.1 Python 代码规范

```yaml
代码风格:
  格式化工具: ruff format
  Linter: ruff check
  类型检查: pyright (strict mode)

命名规范:
  类名: PascalCase (GraphLoader, ToolRegistry)
  函数/方法: snake_case (load_graph, get_tool)
  常量: UPPER_SNAKE_CASE (MAX_RETRIES, DEFAULT_TIMEOUT)
  私有成员: _leading_underscore (_cache, _validate)

导入顺序:
  1. 标准库
  2. 第三方库
  3. 本地模块
  分组之间空一行

文档字符串:
  风格: Google Style
  必须包含: 函数说明、参数、返回值、异常
```

```python
# 示例：标准函数定义
async def execute_graph(
    graph_name: str,
    inputs: dict[str, Any],
    *,
    timeout: int = 300,
    user_id: str | None = None,
) -> ExecutionResponse:
    """执行指定的 Graph。

    Args:
        graph_name: Graph 定义名称
        inputs: 输入参数字典
        timeout: 执行超时时间（秒）
        user_id: 用户ID，用于权限验证

    Returns:
        ExecutionResponse: 包含执行结果的响应对象

    Raises:
        GraphNotFoundError: Graph 定义不存在
        ValidationError: 输入参数验证失败
        ExecutionTimeoutError: 执行超时
    """
    ...
```

### 1.2 TypeScript/JavaScript 规范

```yaml
代码风格:
  格式化工具: prettier
  Linter: eslint
  类型检查: TypeScript strict mode

命名规范:
  组件: PascalCase (ContentEditor, PublishButton)
  函数/变量: camelCase (handleSubmit, isLoading)
  常量: UPPER_SNAKE_CASE (API_BASE_URL)
  类型/接口: PascalCase (UserProfile, GraphDefinition)

文件命名:
  组件: PascalCase.vue / PascalCase.tsx
  工具函数: camelCase.ts
  类型定义: types.ts / *.d.ts
```

### 1.3 YAML/JSON Graph 定义规范

```yaml
# Graph 定义文件命名: kebab-case.yaml
# 示例: content-creation.yaml, publish-workflow.yaml

必须字段:
  apiVersion: "agent/v1"
  kind: "Graph"
  metadata:
    name: "与文件名一致的 kebab-case"
    version: "语义化版本号 (1.0.0)"
    description: "简短描述"

版本规则:
  MAJOR: 破坏性变更（节点重命名、输入输出变更）
  MINOR: 新增功能（新节点、新参数）
  PATCH: Bug 修复、优化

节点命名:
  使用: snake_case
  动词开头: research, generate_outline, polish_content

工具引用:
  使用注册的工具名: llm_generate, web_search, image_gen
  声明能力要求: capability.required, capability.fallback
```

---

## 2. 项目结构规范

### 2.1 目录结构

```text
ai-creator/
├── agent-definitions/          # Graph 定义（唯一来源）
│   ├── content-creation.yaml
│   ├── publish-workflow.yaml
│   └── schemas/
│       └── graph-schema.json   # JSON Schema 验证
│
├── packages/agent-core/        # 共享核心代码（Python 包）
│   ├── src/
│   │   ├── graph/             # Graph 加载、编译
│   │   ├── runtime/           # 运行时接口
│   │   ├── tools/             # 工具定义
│   │   ├── resource/          # 资源管理
│   │   └── crypto/            # 加密工具
│   ├── tests/
│   └── pyproject.toml
│
├── apps/sidecar/               # 桌面端 Sidecar
│   ├── src/
│   │   ├── runtime/           # 本地执行器
│   │   ├── tools/             # 本地工具实现
│   │   └── ipc/               # IPC 通信
│   └── pyproject.toml
│
├── services/cloud-backend/     # 云端服务 (Git Submodule)
│   ├── backend/
│   │   ├── app/
│   │   │   ├── api/           # API 路由
│   │   │   ├── agent/         # Agent 执行
│   │   │   ├── models/        # 数据模型
│   │   │   └── services/      # 业务服务
│   │   └── pyproject.toml
│
├── apps/desktop/               # Tauri 桌面应用
│   ├── src/                   # 前端代码
│   └── src-tauri/             # Rust 后端
│
├── services/mobile-app/        # 移动端应用 (Git Submodule)
│
└── docs/                       # 文档
```

### 2.2 模块依赖规则

```yaml
依赖方向（单向）:
  apps/sidecar → packages/agent-core
  services/cloud-backend → packages/agent-core
  apps/desktop → apps/sidecar (IPC)
  apps/desktop → services/cloud-backend (HTTP API)

禁止:
  - packages/agent-core 依赖 apps/sidecar 或 services/cloud-backend
  - 循环依赖
  - 跨层直接调用（必须通过接口）

共享代码:
  位置: packages/agent-core
  原则: 端云共用的代码必须放在 packages/agent-core
```

---

## 3. Git 工作流规范

### 3.1 分支策略

```yaml
主分支:
  main: 生产环境，仅通过 PR 合并
  develop: 开发环境，功能分支基准

功能分支:
  命名: feature/{ticket-id}-{short-description}
  示例: feature/AC-123-add-xiaohongshu-adapter

修复分支:
  命名: fix/{ticket-id}-{short-description}
  示例: fix/AC-456-credential-sync-error

发布分支:
  命名: release/v{version}
  示例: release/v1.2.0

热修复:
  命名: hotfix/{ticket-id}-{short-description}
  基于: main
```

### 3.2 Commit 规范

```yaml
格式: "<type>(<scope>): <subject>"

类型:
  feat: 新功能
  fix: Bug 修复
  docs: 文档更新
  style: 代码格式（不影响功能）
  refactor: 重构
  perf: 性能优化
  test: 测试相关
  chore: 构建/工具变更

范围:
  agent-core, backend, sidecar, tauri, docs

示例:
  feat(agent-core): add capability declaration for tools
  fix(backend): resolve credential sync race condition
  docs: update Agent Runtime architecture
```

### 3.3 PR 规范

```yaml
标题: "[{type}] {简短描述}"

描述模板:
  ## 变更说明
  - 变更内容概述

  ## 关联 Issue
  - Closes #{issue-id}

  ## 测试说明
  - 测试方法和结果

  ## 检查清单
  - [ ] 代码已自测
  - [ ] 类型检查通过
  - [ ] 测试覆盖
  - [ ] 文档更新

审核要求:
  - 至少 1 人 Approve
  - CI 通过
  - 无冲突
```

---

## 4. Agent/Graph 开发规范

### 4.1 Graph 定义规则

```yaml
必须遵守:
  1. 版本控制: 所有 Graph 定义必须在 agent-definitions/ 目录
  2. 唯一来源: Graph 代码不允许硬编码在 Python 中
  3. 版本声明: 必须包含 metadata.version
  4. 能力声明: 使用可选工具时必须声明 capability
  5. 输入验证: 必须定义 inputs schema

禁止:
  - 在 Graph 定义中硬编码路径
  - 在 Graph 定义中硬编码 API 密钥
  - 跳过输入验证
```

```yaml
# ✅ 正确示例
nodes:
  - name: generate_images
    tool: image_gen
    capability:
      required: false
      fallback: skip  # 不可用时跳过
    params:
      prompt: "${state.polished_content[:200]}"

# ❌ 错误示例
nodes:
  - name: generate_images
    tool: image_gen
    # 缺少 capability 声明，本地/云端行为可能不一致
    params:
      prompt: "${state.polished_content[:200]}"
```

### 4.2 工具开发规则

```python
# 所有工具必须继承 ToolInterface
class ToolInterface(ABC):
    metadata: ToolMetadata  # 必须声明元数据

    @abstractmethod
    async def execute(self, **kwargs) -> ToolResult:
        """执行工具"""
        pass

    @abstractmethod
    def get_schema(self) -> dict:
        """获取输入参数 Schema"""
        pass

# 工具注册规则
@ToolRegistry.register("tool_name", RuntimeType.LOCAL)
@ToolRegistry.register("tool_name", RuntimeType.CLOUD)
class MyTool(ToolInterface):
    metadata = ToolMetadata(
        name="tool_name",
        description="工具描述",
        capabilities=[ToolCapability.XXX],
        supported_runtimes=["local", "cloud"],  # 声明支持的运行时
        fallback_tool="fallback_tool_name",     # 降级方案
    )
```

```yaml
工具开发规则:
  1. 必须声明 metadata
  2. 必须指定 supported_runtimes
  3. 必须提供 get_schema()
  4. 端云实现必须保证输出格式一致
  5. 不应直接访问全局配置，通过 runtime_context 获取
  6. 必须处理超时和错误
```

### 4.3 端云一致性保证

```python
# 工具一致性测试示例
class ToolConsistencyTest:
    """确保端云工具行为一致"""

    async def test_llm_generate_output_format(self):
        """验证输出格式一致"""
        local_tool = ToolRegistry.get("llm_generate", RuntimeType.LOCAL)
        cloud_tool = ToolRegistry.get("llm_generate", RuntimeType.CLOUD)

        test_params = {"model": "test", "prompt": "hello"}

        local_result = await local_tool.execute(**test_params)
        cloud_result = await cloud_tool.execute(**test_params)

        # 输出结构必须一致
        assert set(local_result.data.keys()) == set(cloud_result.data.keys())
        assert "content" in local_result.data
        assert "content" in cloud_result.data
```

---

## 5. 资源 URI 规范

### 5.1 URI 格式

```yaml
格式: asset://{runtime}/{type}/{id}

runtime:
  - local: 本地资源
  - cloud: 云端资源

type:
  - image: 图片资源
  - credential: 凭证数据
  - temp: 临时文件
  - storage: 用户存储

示例:
  - asset://local/image/abc123
  - asset://cloud/credential/xiaohongshu_user1
  - asset://local/temp/draft_001
```

### 5.2 使用规则

```python
# ✅ 正确做法
image_uri = await asset_resolver.store("image", image_data)
# 返回: "asset://local/image/abc123"

resolved_path = await asset_resolver.resolve(image_uri)
# 本地: "/Users/xxx/.ai-creator/data/image/abc123"
# 云端: "https://s3.xxx/user123/image/abc123?signature=xxx"

# ❌ 错误做法
image_path = "/Users/mac/.ai-creator/images/abc.png"  # 硬编码路径
image_path = "./images/abc.png"  # 相对路径
image_path = "~/images/abc.png"  # 用户目录路径
```

```yaml
禁止:
  - 硬编码绝对路径
  - 使用相对路径
  - 使用 ~ 或 $HOME
  - 在代码中直接拼接路径

必须:
  - 使用 AssetResolver 存储资源
  - 使用 AssetResolver 解析 URI
  - 在 Graph 定义中使用 URI 变量
```

---

## 6. API 设计规范

### 6.1 RESTful API 规范

```yaml
URL 设计:
  - 使用名词复数: /users, /contents, /publications
  - 资源层级: /users/{id}/contents
  - 查询参数: ?page=1&limit=20&status=published

HTTP 方法:
  GET: 查询资源
  POST: 创建资源
  PUT: 完整更新
  PATCH: 部分更新
  DELETE: 删除资源

响应格式:
  成功:
    code: 200
    message: "success"
    data: {...}

  错误:
    code: 400/401/403/404/500
    message: "错误描述"
    details: {...}  # 可选
```

### 6.2 Agent API 规范

```yaml
Agent 执行 API:
  POST /agent/run:
    请求:
      graph_name: string (必需)
      inputs: object (必需)
      async_mode: boolean (默认 false)
    响应:
      execution_id: string
      status: pending | running | completed | failed
      outputs: object | null
      error: string | null

  GET /agent/run/{execution_id}:
    响应: 同上

  POST /agent/tool_callback:
    用途: 客户端回调（凭证解密、操作确认）
    请求:
      execution_id: string
      tool_name: string
      action: request_credential | confirm_action
      payload: object

  WebSocket /agent/run/{execution_id}/ws:
    用途: 实时状态推送
    消息: {status, progress, outputs}
```

---

## 7. 安全规范

### 7.1 凭证处理

```yaml
凭证加密:
  算法: AES-256-GCM
  密钥派生: PBKDF2 + SHA256
  迭代次数: 600000 (OWASP 推荐)
  Salt: 随机 32 字节
  IV: 随机 12 字节

云端同步:
  双重加密: 本地密钥 + 同步密钥
  服务端: 仅存储密文，无解密能力

禁止:
  - 明文存储凭证
  - 日志中打印凭证
  - 在错误消息中暴露凭证
  - 降低加密强度
```

### 7.2 输入验证

```python
# 所有用户输入必须验证
from pydantic import BaseModel, Field, validator

class GraphExecuteRequest(BaseModel):
    graph_name: str = Field(..., min_length=1, max_length=100)
    inputs: dict[str, Any]

    @validator('graph_name')
    def validate_graph_name(cls, v):
        # 只允许字母、数字、下划线、连字符
        if not re.match(r'^[a-zA-Z0-9_-]+$', v):
            raise ValueError('Invalid graph name format')
        return v
```

```yaml
验证规则:
  1. 所有 API 输入必须使用 Pydantic 验证
  2. 文件路径必须验证，防止路径遍历
  3. SQL 查询必须使用参数化
  4. 外部输入必须转义后再使用
```

### 7.3 敏感信息处理

```yaml
禁止日志记录:
  - 密码和密钥
  - 平台凭证 (Cookies, Tokens)
  - 个人身份信息 (手机号、身份证)
  - API 密钥

日志脱敏:
  email: "u***@example.com"
  phone: "138****1234"
  token: "eyJ***...***xyz"
```

---

## 8. 测试规范

### 8.1 测试分层

```yaml
单元测试:
  覆盖率要求: >= 80%
  工具: pytest
  命名: test_{module}/test_{function}.py

集成测试:
  范围: API 端点、数据库操作
  工具: pytest + httpx
  数据库: 使用测试数据库

端到端测试:
  范围: 完整工作流
  工具: Playwright
  频率: 每次发布前
```

### 8.2 Graph 测试

```python
# Graph 定义测试
class TestContentCreationGraph:
    """内容创作 Graph 测试"""

    async def test_graph_loads(self):
        """Graph 能正确加载"""
        loader = GraphLoader()
        definition = loader.load("content-creation")
        assert definition["kind"] == "Graph"

    async def test_graph_validates(self):
        """Graph 定义验证通过"""
        loader = GraphLoader()
        definition = loader.load("content-creation")
        # 使用 JSON Schema 验证
        validate(definition, graph_schema)

    async def test_graph_executes(self):
        """Graph 能正确执行"""
        workflow = ContentCreationWorkflow()
        result = await workflow.run(
            topic="测试主题",
            platform="xiaohongshu",
            style="casual"
        )
        assert result["success"] is True
```

### 8.3 工具一致性测试

```python
# 端云工具一致性测试
@pytest.mark.parametrize("tool_name", [
    "llm_generate",
    "web_search",
    "storage",
])
async def test_tool_consistency(tool_name):
    """验证端云工具行为一致"""
    local_tool = ToolRegistry.get(tool_name, RuntimeType.LOCAL)
    cloud_tool = ToolRegistry.get(tool_name, RuntimeType.CLOUD)

    # Schema 必须一致
    assert local_tool.get_schema() == cloud_tool.get_schema()

    # 元数据中的能力声明必须一致
    assert local_tool.metadata.capabilities == cloud_tool.metadata.capabilities
```

---

## 9. 错误处理规范

### 9.1 异常定义

```python
# 自定义异常基类
class AICreatorError(Exception):
    """AI Creator 异常基类"""
    code: str = "UNKNOWN_ERROR"
    status_code: int = 500

class GraphNotFoundError(AICreatorError):
    """Graph 定义不存在"""
    code = "GRAPH_NOT_FOUND"
    status_code = 404

class ValidationError(AICreatorError):
    """输入验证失败"""
    code = "VALIDATION_ERROR"
    status_code = 400

class ToolNotAvailableError(AICreatorError):
    """工具不可用"""
    code = "TOOL_NOT_AVAILABLE"
    status_code = 503

class CredentialExpiredError(AICreatorError):
    """凭证已过期"""
    code = "CREDENTIAL_EXPIRED"
    status_code = 401
```

### 9.2 错误处理模式

```python
# 工具执行错误处理
async def execute_with_fallback(
    tool_name: str,
    params: dict,
    capability: dict
) -> ToolResult:
    """带降级的工具执行"""
    tool = registry.get(tool_name)

    try:
        result = await tool.execute(**params)
        if result.success:
            return result

        # 执行失败，尝试降级
        if capability.get("fallback"):
            fallback_tool = registry.get(capability["fallback"])
            return await fallback_tool.execute(**params)

        # 无降级方案，根据 required 决定处理方式
        if capability.get("required", True):
            raise ToolExecutionError(f"Required tool {tool_name} failed")

        # 非必需工具，返回空结果
        return ToolResult(success=True, data=None)

    except Exception as e:
        logger.error(f"Tool {tool_name} execution failed: {e}")

        if capability.get("required", True):
            raise

        return ToolResult(success=True, data=None)
```

### 9.3 重试策略

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type(TemporaryError),
)
async def execute_with_retry(tool: ToolInterface, **params) -> ToolResult:
    """带重试的工具执行"""
    return await tool.execute(**params)
```

---

## 10. 文档规范

### 10.1 文档结构

```yaml
docs/ 目录:
  01-系统架构.md: 整体架构概览
  02-桌面端设计.md: Tauri 应用设计
  03-移动端设计.md: 移动端设计
  04-云端服务设计.md: FastAPI 后端设计
  05-Agent-Runtime.md: Agent 运行时架构
  06-平台适配器.md: 平台自动化适配
  07-AI工作流.md: LangGraph 工作流
  08-数据模型.md: SQLAlchemy 模型
  09-商业模式.md: 订阅与计费
  10-约束细则.md: 法律与安全约束
  11-开发规范.md: 本文档
```

### 10.2 文档更新规则

```yaml
必须更新文档:
  - 新增 API 端点
  - 修改 Graph 定义格式
  - 新增工具类型
  - 架构变更
  - 数据模型变更

文档审核:
  - 技术文档: 开发人员审核
  - API 文档: 前后端共同审核
  - 架构文档: 技术负责人审核
```

---

## 11. 性能规范

### 11.1 性能指标

```yaml
响应时间:
  API 接口: P95 < 500ms
  AI 创作: 首次响应 < 3s
  发布操作: < 60s
  数据查询: < 200ms

并发能力:
  API 服务: 1000 QPS
  AI 服务: 100 并发
  浏览器池: 50 实例

资源限制:
  数据库连接池: 200
  Redis 连接池: 500
  单次 AI Token: 按订阅级别
```

### 11.2 优化规则

```yaml
数据库:
  - 使用索引覆盖高频查询
  - 避免 N+1 查询
  - 使用连接池
  - 大查询使用分页

缓存:
  - 热点数据使用 Redis 缓存
  - Graph 定义使用内存缓存
  - API 响应使用 HTTP 缓存头

异步:
  - I/O 操作使用 async/await
  - 长任务使用 Celery 队列
  - 批量操作并行处理
```

---

## 12. 检查清单

### 12.1 代码提交检查

```yaml
提交前检查:
  - [ ] ruff format 格式化通过
  - [ ] ruff check 无错误
  - [ ] pyright 类型检查通过
  - [ ] 单元测试通过
  - [ ] 无硬编码路径
  - [ ] 无硬编码密钥
  - [ ] 文档已更新（如需要）
```

### 12.2 Graph 定义检查

```yaml
Graph 定义检查:
  - [ ] 包含 apiVersion、kind、metadata
  - [ ] metadata 包含 version
  - [ ] 所有工具引用有效
  - [ ] 可选工具声明了 capability
  - [ ] 输入参数有 schema
  - [ ] 路径使用 URI 格式
```

### 12.3 工具开发检查

```yaml
工具开发检查:
  - [ ] 继承 ToolInterface
  - [ ] 声明 metadata
  - [ ] 实现 get_schema()
  - [ ] 注册到 ToolRegistry
  - [ ] 端云实现输出格式一致
  - [ ] 编写一致性测试
```

---

## 相关文档

- [系统架构](./01-系统架构.md)
- [Agent Runtime](./05-Agent-Runtime.md)
- [数据模型](./08-数据模型.md)
- [约束细则](./10-约束细则.md)
